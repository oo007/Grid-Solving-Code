
practice.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002934  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000008c  00800060  00002934  000029c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000020  008000ec  008000ec  00002a54  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00002a54  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000001eb  00000000  00000000  00002a74  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002d99  00000000  00000000  00002c5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000383  00000000  00000000  000059f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000020e4  00000000  00000000  00005d7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001a0  00000000  00000000  00007e60  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001d0  00000000  00000000  00008000  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001bf3  00000000  00000000  000081d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000200  00000000  00000000  00009dc3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e3       	ldi	r30, 0x34	; 52
      68:	f9 e2       	ldi	r31, 0x29	; 41
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 3e       	cpi	r26, 0xEC	; 236
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	ac ee       	ldi	r26, 0xEC	; 236
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 30       	cpi	r26, 0x0C	; 12
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 59 11 	call	0x22b2	; 0x22b2 <main>
      8a:	0c 94 98 14 	jmp	0x2930	; 0x2930 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <turnleft>:
     int top;
};
typedef struct stack stack;
void turnleft()
{
	PORTM=FORWARD;
      92:	89 e0       	ldi	r24, 0x09	; 9
      94:	85 bb       	out	0x15, r24	; 21
      96:	88 ee       	ldi	r24, 0xE8	; 232
      98:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
      9a:	24 e6       	ldi	r18, 0x64	; 100
      9c:	30 e0       	ldi	r19, 0x00	; 0
      9e:	f9 01       	movw	r30, r18
      a0:	31 97       	sbiw	r30, 0x01	; 1
      a2:	f1 f7       	brne	.-4      	; 0xa0 <turnleft+0xe>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
      a4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
      a6:	d9 f7       	brne	.-10     	; 0x9e <turnleft+0xc>
	_delay_ms(100);
    PORTM=STOP;
      a8:	8f e0       	ldi	r24, 0x0F	; 15
      aa:	85 bb       	out	0x15, r24	; 21
      ac:	88 ee       	ldi	r24, 0xE8	; 232
      ae:	93 e0       	ldi	r25, 0x03	; 3
      b0:	24 e6       	ldi	r18, 0x64	; 100
      b2:	30 e0       	ldi	r19, 0x00	; 0
      b4:	f9 01       	movw	r30, r18
      b6:	31 97       	sbiw	r30, 0x01	; 1
      b8:	f1 f7       	brne	.-4      	; 0xb6 <turnleft+0x24>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
      ba:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
      bc:	d9 f7       	brne	.-10     	; 0xb4 <turnleft+0x22>
	_delay_ms(100);
	PORTM=SHARPLEFT;
      be:	85 e0       	ldi	r24, 0x05	; 5
      c0:	85 bb       	out	0x15, r24	; 21
      c2:	8c ed       	ldi	r24, 0xDC	; 220
      c4:	95 e0       	ldi	r25, 0x05	; 5
      c6:	24 e6       	ldi	r18, 0x64	; 100
      c8:	30 e0       	ldi	r19, 0x00	; 0
      ca:	f9 01       	movw	r30, r18
      cc:	31 97       	sbiw	r30, 0x01	; 1
      ce:	f1 f7       	brne	.-4      	; 0xcc <turnleft+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
      d0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
      d2:	d9 f7       	brne	.-10     	; 0xca <turnleft+0x38>
	_delay_ms(150);
	PORTM=STOP;
      d4:	8f e0       	ldi	r24, 0x0F	; 15
      d6:	85 bb       	out	0x15, r24	; 21
    if(dir==4)
      d8:	80 91 e8 00 	lds	r24, 0x00E8
      dc:	90 91 e9 00 	lds	r25, 0x00E9
      e0:	84 30       	cpi	r24, 0x04	; 4
      e2:	91 05       	cpc	r25, r1
      e4:	19 f4       	brne	.+6      	; 0xec <turnleft+0x5a>
	{
	   dir=1;
      e6:	81 e0       	ldi	r24, 0x01	; 1
      e8:	90 e0       	ldi	r25, 0x00	; 0
      ea:	01 c0       	rjmp	.+2      	; 0xee <turnleft+0x5c>
	}
	else
	{
	   dir=dir+1;
      ec:	01 96       	adiw	r24, 0x01	; 1
      ee:	90 93 e9 00 	sts	0x00E9, r25
      f2:	80 93 e8 00 	sts	0x00E8, r24
	}
	PORTM=STOP;
      f6:	8f e0       	ldi	r24, 0x0F	; 15
      f8:	85 bb       	out	0x15, r24	; 21

}
      fa:	08 95       	ret

000000fc <turnright>:
void turnright()
{
	PORTM=FORWARD;
      fc:	89 e0       	ldi	r24, 0x09	; 9
      fe:	85 bb       	out	0x15, r24	; 21
     100:	88 ee       	ldi	r24, 0xE8	; 232
     102:	93 e0       	ldi	r25, 0x03	; 3
     104:	24 e6       	ldi	r18, 0x64	; 100
     106:	30 e0       	ldi	r19, 0x00	; 0
     108:	f9 01       	movw	r30, r18
     10a:	31 97       	sbiw	r30, 0x01	; 1
     10c:	f1 f7       	brne	.-4      	; 0x10a <turnright+0xe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     10e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     110:	d9 f7       	brne	.-10     	; 0x108 <turnright+0xc>
	_delay_ms(100);
	PORTM=STOP;
     112:	8f e0       	ldi	r24, 0x0F	; 15
     114:	85 bb       	out	0x15, r24	; 21
     116:	88 ee       	ldi	r24, 0xE8	; 232
     118:	93 e0       	ldi	r25, 0x03	; 3
     11a:	24 e6       	ldi	r18, 0x64	; 100
     11c:	30 e0       	ldi	r19, 0x00	; 0
     11e:	f9 01       	movw	r30, r18
     120:	31 97       	sbiw	r30, 0x01	; 1
     122:	f1 f7       	brne	.-4      	; 0x120 <turnright+0x24>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     124:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     126:	d9 f7       	brne	.-10     	; 0x11e <turnright+0x22>
    _delay_ms(100);
    PORTM=SHARPRIGHT;
     128:	8a e0       	ldi	r24, 0x0A	; 10
     12a:	85 bb       	out	0x15, r24	; 21
     12c:	8c ed       	ldi	r24, 0xDC	; 220
     12e:	95 e0       	ldi	r25, 0x05	; 5
     130:	24 e6       	ldi	r18, 0x64	; 100
     132:	30 e0       	ldi	r19, 0x00	; 0
     134:	f9 01       	movw	r30, r18
     136:	31 97       	sbiw	r30, 0x01	; 1
     138:	f1 f7       	brne	.-4      	; 0x136 <turnright+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     13a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     13c:	d9 f7       	brne	.-10     	; 0x134 <turnright+0x38>
	_delay_ms(150);
	PORTM=STOP;	
     13e:	8f e0       	ldi	r24, 0x0F	; 15
     140:	85 bb       	out	0x15, r24	; 21
	if(dir==1)
     142:	80 91 e8 00 	lds	r24, 0x00E8
     146:	90 91 e9 00 	lds	r25, 0x00E9
     14a:	81 30       	cpi	r24, 0x01	; 1
     14c:	91 05       	cpc	r25, r1
     14e:	19 f4       	brne	.+6      	; 0x156 <turnright+0x5a>
	{
	  dir=4;
     150:	84 e0       	ldi	r24, 0x04	; 4
     152:	90 e0       	ldi	r25, 0x00	; 0
     154:	01 c0       	rjmp	.+2      	; 0x158 <turnright+0x5c>
	}
	else
	{
	  dir=dir-1;
     156:	01 97       	sbiw	r24, 0x01	; 1
     158:	90 93 e9 00 	sts	0x00E9, r25
     15c:	80 93 e8 00 	sts	0x00E8, r24
     160:	08 95       	ret

00000162 <buzzer>:
	}
}
void buzzer()
{
      PORTB=0x01;
     162:	81 e0       	ldi	r24, 0x01	; 1
     164:	88 bb       	out	0x18, r24	; 24
     166:	80 e1       	ldi	r24, 0x10	; 16
     168:	97 e2       	ldi	r25, 0x27	; 39
     16a:	01 97       	sbiw	r24, 0x01	; 1
     16c:	f1 f7       	brne	.-4      	; 0x16a <buzzer+0x8>
	  _delay_ms(10);
   	  PORTB=0x00;
     16e:	18 ba       	out	0x18, r1	; 24
     170:	80 e5       	ldi	r24, 0x50	; 80
     172:	93 ec       	ldi	r25, 0xC3	; 195
     174:	01 97       	sbiw	r24, 0x01	; 1
     176:	f1 f7       	brne	.-4      	; 0x174 <buzzer+0x12>
	  _delay_ms(50);
}
     178:	08 95       	ret

0000017a <aboutturn>:
void aboutturn()
{
    PORTM=FORWARD;
     17a:	89 e0       	ldi	r24, 0x09	; 9
     17c:	85 bb       	out	0x15, r24	; 21
     17e:	88 ee       	ldi	r24, 0xE8	; 232
     180:	93 e0       	ldi	r25, 0x03	; 3
     182:	24 e6       	ldi	r18, 0x64	; 100
     184:	30 e0       	ldi	r19, 0x00	; 0
     186:	f9 01       	movw	r30, r18
     188:	31 97       	sbiw	r30, 0x01	; 1
     18a:	f1 f7       	brne	.-4      	; 0x188 <aboutturn+0xe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     18c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     18e:	d9 f7       	brne	.-10     	; 0x186 <aboutturn+0xc>
	_delay_ms(100);
	PORTM=STOP;
     190:	8f e0       	ldi	r24, 0x0F	; 15
     192:	85 bb       	out	0x15, r24	; 21
     194:	88 ee       	ldi	r24, 0xE8	; 232
     196:	93 e0       	ldi	r25, 0x03	; 3
     198:	24 e6       	ldi	r18, 0x64	; 100
     19a:	30 e0       	ldi	r19, 0x00	; 0
     19c:	f9 01       	movw	r30, r18
     19e:	31 97       	sbiw	r30, 0x01	; 1
     1a0:	f1 f7       	brne	.-4      	; 0x19e <aboutturn+0x24>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     1a2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     1a4:	d9 f7       	brne	.-10     	; 0x19c <aboutturn+0x22>
	_delay_ms(100);
    PORTM=SHARPRIGHT;
     1a6:	8a e0       	ldi	r24, 0x0A	; 10
     1a8:	85 bb       	out	0x15, r24	; 21
     1aa:	8a ea       	ldi	r24, 0xAA	; 170
     1ac:	95 e0       	ldi	r25, 0x05	; 5
     1ae:	24 e6       	ldi	r18, 0x64	; 100
     1b0:	30 e0       	ldi	r19, 0x00	; 0
     1b2:	f9 01       	movw	r30, r18
     1b4:	31 97       	sbiw	r30, 0x01	; 1
     1b6:	f1 f7       	brne	.-4      	; 0x1b4 <aboutturn+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     1b8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     1ba:	d9 f7       	brne	.-10     	; 0x1b2 <aboutturn+0x38>
	_delay_ms(145);
	PORTM=STOP;	
     1bc:	8f e0       	ldi	r24, 0x0F	; 15
     1be:	85 bb       	out	0x15, r24	; 21
	if(dir==1)
     1c0:	80 91 e8 00 	lds	r24, 0x00E8
     1c4:	90 91 e9 00 	lds	r25, 0x00E9
     1c8:	81 30       	cpi	r24, 0x01	; 1
     1ca:	91 05       	cpc	r25, r1
     1cc:	19 f4       	brne	.+6      	; 0x1d4 <aboutturn+0x5a>
	{
	  dir=4;
     1ce:	84 e0       	ldi	r24, 0x04	; 4
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	01 c0       	rjmp	.+2      	; 0x1d6 <aboutturn+0x5c>
	}
	else
	{
	  dir=dir-1;
     1d4:	01 97       	sbiw	r24, 0x01	; 1
     1d6:	90 93 e9 00 	sts	0x00E9, r25
     1da:	80 93 e8 00 	sts	0x00E8, r24
	}
	PORTM=STOP;
     1de:	8f e0       	ldi	r24, 0x0F	; 15
     1e0:	85 bb       	out	0x15, r24	; 21
    PORTM=SHARPRIGHT;
     1e2:	8a e0       	ldi	r24, 0x0A	; 10
     1e4:	85 bb       	out	0x15, r24	; 21
     1e6:	8c ed       	ldi	r24, 0xDC	; 220
     1e8:	95 e0       	ldi	r25, 0x05	; 5
     1ea:	24 e6       	ldi	r18, 0x64	; 100
     1ec:	30 e0       	ldi	r19, 0x00	; 0
     1ee:	f9 01       	movw	r30, r18
     1f0:	31 97       	sbiw	r30, 0x01	; 1
     1f2:	f1 f7       	brne	.-4      	; 0x1f0 <aboutturn+0x76>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     1f4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     1f6:	d9 f7       	brne	.-10     	; 0x1ee <aboutturn+0x74>
	_delay_ms(150);
	PORTM=STOP;	
     1f8:	8f e0       	ldi	r24, 0x0F	; 15
     1fa:	85 bb       	out	0x15, r24	; 21
	if(dir==1)
     1fc:	80 91 e8 00 	lds	r24, 0x00E8
     200:	90 91 e9 00 	lds	r25, 0x00E9
     204:	81 30       	cpi	r24, 0x01	; 1
     206:	91 05       	cpc	r25, r1
     208:	19 f4       	brne	.+6      	; 0x210 <aboutturn+0x96>
	{
	  dir=4;
     20a:	84 e0       	ldi	r24, 0x04	; 4
     20c:	90 e0       	ldi	r25, 0x00	; 0
     20e:	01 c0       	rjmp	.+2      	; 0x212 <aboutturn+0x98>
	}
	else
	{
	  dir=dir-1;
     210:	01 97       	sbiw	r24, 0x01	; 1
     212:	90 93 e9 00 	sts	0x00E9, r25
     216:	80 93 e8 00 	sts	0x00E8, r24
	}
	PORTM=STOP;
     21a:	8f e0       	ldi	r24, 0x0F	; 15
     21c:	85 bb       	out	0x15, r24	; 21
}
     21e:	08 95       	ret

00000220 <backturn>:

void backturn()
{
    PORTM=SHARPRIGHT;
     220:	8a e0       	ldi	r24, 0x0A	; 10
     222:	85 bb       	out	0x15, r24	; 21
     224:	8a ea       	ldi	r24, 0xAA	; 170
     226:	95 e0       	ldi	r25, 0x05	; 5
     228:	24 e6       	ldi	r18, 0x64	; 100
     22a:	30 e0       	ldi	r19, 0x00	; 0
     22c:	f9 01       	movw	r30, r18
     22e:	31 97       	sbiw	r30, 0x01	; 1
     230:	f1 f7       	brne	.-4      	; 0x22e <backturn+0xe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     232:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     234:	d9 f7       	brne	.-10     	; 0x22c <backturn+0xc>
	_delay_ms(145);
	PORTM=STOP;	
     236:	8f e0       	ldi	r24, 0x0F	; 15
     238:	85 bb       	out	0x15, r24	; 21
	if(dir==1)
     23a:	80 91 e8 00 	lds	r24, 0x00E8
     23e:	90 91 e9 00 	lds	r25, 0x00E9
     242:	81 30       	cpi	r24, 0x01	; 1
     244:	91 05       	cpc	r25, r1
     246:	19 f4       	brne	.+6      	; 0x24e <backturn+0x2e>
	{
	  dir=4;
     248:	84 e0       	ldi	r24, 0x04	; 4
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	01 c0       	rjmp	.+2      	; 0x250 <backturn+0x30>
	}
	else
	{
	  dir=dir-1;
     24e:	01 97       	sbiw	r24, 0x01	; 1
     250:	90 93 e9 00 	sts	0x00E9, r25
     254:	80 93 e8 00 	sts	0x00E8, r24
	}
	PORTM=STOP;
     258:	8f e0       	ldi	r24, 0x0F	; 15
     25a:	85 bb       	out	0x15, r24	; 21
    PORTM=SHARPRIGHT;
     25c:	8a e0       	ldi	r24, 0x0A	; 10
     25e:	85 bb       	out	0x15, r24	; 21
     260:	8c ed       	ldi	r24, 0xDC	; 220
     262:	95 e0       	ldi	r25, 0x05	; 5
     264:	24 e6       	ldi	r18, 0x64	; 100
     266:	30 e0       	ldi	r19, 0x00	; 0
     268:	f9 01       	movw	r30, r18
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	f1 f7       	brne	.-4      	; 0x26a <backturn+0x4a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     26e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     270:	d9 f7       	brne	.-10     	; 0x268 <backturn+0x48>
	_delay_ms(150);
	PORTM=STOP;	
     272:	8f e0       	ldi	r24, 0x0F	; 15
     274:	85 bb       	out	0x15, r24	; 21
	if(dir==1)
     276:	80 91 e8 00 	lds	r24, 0x00E8
     27a:	90 91 e9 00 	lds	r25, 0x00E9
     27e:	81 30       	cpi	r24, 0x01	; 1
     280:	91 05       	cpc	r25, r1
     282:	19 f4       	brne	.+6      	; 0x28a <backturn+0x6a>
	{
	  dir=4;
     284:	84 e0       	ldi	r24, 0x04	; 4
     286:	90 e0       	ldi	r25, 0x00	; 0
     288:	01 c0       	rjmp	.+2      	; 0x28c <backturn+0x6c>
	}
	else
	{
	  dir=dir-1;
     28a:	01 97       	sbiw	r24, 0x01	; 1
     28c:	90 93 e9 00 	sts	0x00E9, r25
     290:	80 93 e8 00 	sts	0x00E8, r24
	}
	PORTM=STOP;
     294:	8f e0       	ldi	r24, 0x0F	; 15
     296:	85 bb       	out	0x15, r24	; 21
}
     298:	08 95       	ret

0000029a <pickup>:
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     29a:	81 e0       	ldi	r24, 0x01	; 1
     29c:	88 bb       	out	0x18, r24	; 24
     29e:	80 e1       	ldi	r24, 0x10	; 16
     2a0:	97 e2       	ldi	r25, 0x27	; 39
     2a2:	01 97       	sbiw	r24, 0x01	; 1
     2a4:	f1 f7       	brne	.-4      	; 0x2a2 <pickup+0x8>
	  _delay_ms(10);
   	  PORTB=0x00;
     2a6:	18 ba       	out	0x18, r1	; 24
     2a8:	80 e5       	ldi	r24, 0x50	; 80
     2aa:	93 ec       	ldi	r25, 0xC3	; 195
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	f1 f7       	brne	.-4      	; 0x2ac <pickup+0x12>
}

void pickup()
{
        buzzer();
		PORTH=HANDOPEN;
     2b0:	82 e0       	ldi	r24, 0x02	; 2
     2b2:	82 bb       	out	0x12, r24	; 18
     2b4:	88 ee       	ldi	r24, 0xE8	; 232
     2b6:	93 e0       	ldi	r25, 0x03	; 3
     2b8:	24 e6       	ldi	r18, 0x64	; 100
     2ba:	30 e0       	ldi	r19, 0x00	; 0
     2bc:	f9 01       	movw	r30, r18
     2be:	31 97       	sbiw	r30, 0x01	; 1
     2c0:	f1 f7       	brne	.-4      	; 0x2be <pickup+0x24>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     2c2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     2c4:	d9 f7       	brne	.-10     	; 0x2bc <pickup+0x22>
		_delay_ms(100);
		PORTH=STOP;
     2c6:	8f e0       	ldi	r24, 0x0F	; 15
     2c8:	82 bb       	out	0x12, r24	; 18
     2ca:	88 ee       	ldi	r24, 0xE8	; 232
     2cc:	93 e0       	ldi	r25, 0x03	; 3
     2ce:	24 e6       	ldi	r18, 0x64	; 100
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	f9 01       	movw	r30, r18
     2d4:	31 97       	sbiw	r30, 0x01	; 1
     2d6:	f1 f7       	brne	.-4      	; 0x2d4 <pickup+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     2d8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     2da:	d9 f7       	brne	.-10     	; 0x2d2 <pickup+0x38>
		_delay_ms(100);
		PORTH=HANDDOWN;
     2dc:	84 e0       	ldi	r24, 0x04	; 4
     2de:	82 bb       	out	0x12, r24	; 18
     2e0:	80 e2       	ldi	r24, 0x20	; 32
     2e2:	93 e0       	ldi	r25, 0x03	; 3
     2e4:	24 e6       	ldi	r18, 0x64	; 100
     2e6:	30 e0       	ldi	r19, 0x00	; 0
     2e8:	f9 01       	movw	r30, r18
     2ea:	31 97       	sbiw	r30, 0x01	; 1
     2ec:	f1 f7       	brne	.-4      	; 0x2ea <pickup+0x50>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     2ee:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     2f0:	d9 f7       	brne	.-10     	; 0x2e8 <pickup+0x4e>
		_delay_ms(80);
		PORTH=STOP;
     2f2:	8f e0       	ldi	r24, 0x0F	; 15
     2f4:	82 bb       	out	0x12, r24	; 18
     2f6:	88 ee       	ldi	r24, 0xE8	; 232
     2f8:	93 e0       	ldi	r25, 0x03	; 3
     2fa:	24 e6       	ldi	r18, 0x64	; 100
     2fc:	30 e0       	ldi	r19, 0x00	; 0
     2fe:	f9 01       	movw	r30, r18
     300:	31 97       	sbiw	r30, 0x01	; 1
     302:	f1 f7       	brne	.-4      	; 0x300 <pickup+0x66>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     304:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     306:	d9 f7       	brne	.-10     	; 0x2fe <pickup+0x64>
		_delay_ms(100);
        PORTH=HANDCLOSE;
     308:	81 e0       	ldi	r24, 0x01	; 1
     30a:	82 bb       	out	0x12, r24	; 18
     30c:	80 ed       	ldi	r24, 0xD0	; 208
     30e:	97 e0       	ldi	r25, 0x07	; 7
     310:	24 e6       	ldi	r18, 0x64	; 100
     312:	30 e0       	ldi	r19, 0x00	; 0
     314:	f9 01       	movw	r30, r18
     316:	31 97       	sbiw	r30, 0x01	; 1
     318:	f1 f7       	brne	.-4      	; 0x316 <pickup+0x7c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     31a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     31c:	d9 f7       	brne	.-10     	; 0x314 <pickup+0x7a>
		_delay_ms(200);
		PORTH=STOP;
     31e:	8f e0       	ldi	r24, 0x0F	; 15
     320:	82 bb       	out	0x12, r24	; 18
     322:	88 ee       	ldi	r24, 0xE8	; 232
     324:	93 e0       	ldi	r25, 0x03	; 3
     326:	24 e6       	ldi	r18, 0x64	; 100
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	f9 01       	movw	r30, r18
     32c:	31 97       	sbiw	r30, 0x01	; 1
     32e:	f1 f7       	brne	.-4      	; 0x32c <pickup+0x92>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     330:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     332:	d9 f7       	brne	.-10     	; 0x32a <pickup+0x90>
		_delay_ms(100);
		PORTH=HANDUP;
     334:	88 e0       	ldi	r24, 0x08	; 8
     336:	82 bb       	out	0x12, r24	; 18
     338:	88 eb       	ldi	r24, 0xB8	; 184
     33a:	9b e0       	ldi	r25, 0x0B	; 11
     33c:	24 e6       	ldi	r18, 0x64	; 100
     33e:	30 e0       	ldi	r19, 0x00	; 0
     340:	f9 01       	movw	r30, r18
     342:	31 97       	sbiw	r30, 0x01	; 1
     344:	f1 f7       	brne	.-4      	; 0x342 <pickup+0xa8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     346:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     348:	d9 f7       	brne	.-10     	; 0x340 <pickup+0xa6>
	    _delay_ms(300);
	    PORTH=STOP;
     34a:	8f e0       	ldi	r24, 0x0F	; 15
     34c:	82 bb       	out	0x12, r24	; 18
     34e:	20 e5       	ldi	r18, 0x50	; 80
     350:	33 ec       	ldi	r19, 0xC3	; 195
     352:	c9 01       	movw	r24, r18
     354:	01 97       	sbiw	r24, 0x01	; 1
     356:	f1 f7       	brne	.-4      	; 0x354 <pickup+0xba>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	88 bb       	out	0x18, r24	; 24
     35c:	80 e1       	ldi	r24, 0x10	; 16
     35e:	97 e2       	ldi	r25, 0x27	; 39
     360:	01 97       	sbiw	r24, 0x01	; 1
     362:	f1 f7       	brne	.-4      	; 0x360 <pickup+0xc6>
	  _delay_ms(10);
   	  PORTB=0x00;
     364:	18 ba       	out	0x18, r1	; 24
     366:	c9 01       	movw	r24, r18
     368:	01 97       	sbiw	r24, 0x01	; 1
     36a:	f1 f7       	brne	.-4      	; 0x368 <pickup+0xce>
		PORTH=HANDUP;
	    _delay_ms(300);
	    PORTH=STOP;
	 	_delay_ms(50);
		buzzer();
}
     36c:	08 95       	ret

0000036e <place>:
void place()
{
		PORTH=HANDDOWN;
     36e:	84 e0       	ldi	r24, 0x04	; 4
     370:	82 bb       	out	0x12, r24	; 18
     372:	80 e6       	ldi	r24, 0x60	; 96
     374:	9a ee       	ldi	r25, 0xEA	; 234
     376:	01 97       	sbiw	r24, 0x01	; 1
     378:	f1 f7       	brne	.-4      	; 0x376 <place+0x8>
		_delay_ms(60);
		PORTH=STOP;
     37a:	8f e0       	ldi	r24, 0x0F	; 15
     37c:	82 bb       	out	0x12, r24	; 18
     37e:	8c eb       	ldi	r24, 0xBC	; 188
     380:	92 e0       	ldi	r25, 0x02	; 2
     382:	24 e6       	ldi	r18, 0x64	; 100
     384:	30 e0       	ldi	r19, 0x00	; 0
     386:	f9 01       	movw	r30, r18
     388:	31 97       	sbiw	r30, 0x01	; 1
     38a:	f1 f7       	brne	.-4      	; 0x388 <place+0x1a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     38c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     38e:	d9 f7       	brne	.-10     	; 0x386 <place+0x18>
		_delay_ms(70);
        PORTH=HANDOPEN;
     390:	82 e0       	ldi	r24, 0x02	; 2
     392:	82 bb       	out	0x12, r24	; 18
     394:	8c eb       	ldi	r24, 0xBC	; 188
     396:	92 e0       	ldi	r25, 0x02	; 2
     398:	24 e6       	ldi	r18, 0x64	; 100
     39a:	30 e0       	ldi	r19, 0x00	; 0
     39c:	f9 01       	movw	r30, r18
     39e:	31 97       	sbiw	r30, 0x01	; 1
     3a0:	f1 f7       	brne	.-4      	; 0x39e <place+0x30>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     3a2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     3a4:	d9 f7       	brne	.-10     	; 0x39c <place+0x2e>
		_delay_ms(70);
		PORTH=STOP;
     3a6:	8f e0       	ldi	r24, 0x0F	; 15
     3a8:	82 bb       	out	0x12, r24	; 18
     3aa:	8c eb       	ldi	r24, 0xBC	; 188
     3ac:	92 e0       	ldi	r25, 0x02	; 2
     3ae:	24 e6       	ldi	r18, 0x64	; 100
     3b0:	30 e0       	ldi	r19, 0x00	; 0
     3b2:	f9 01       	movw	r30, r18
     3b4:	31 97       	sbiw	r30, 0x01	; 1
     3b6:	f1 f7       	brne	.-4      	; 0x3b4 <place+0x46>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     3b8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     3ba:	d9 f7       	brne	.-10     	; 0x3b2 <place+0x44>
		_delay_ms(70);
		PORTH=HANDUP;
     3bc:	88 e0       	ldi	r24, 0x08	; 8
     3be:	82 bb       	out	0x12, r24	; 18
     3c0:	84 ec       	ldi	r24, 0xC4	; 196
     3c2:	99 e0       	ldi	r25, 0x09	; 9
     3c4:	24 e6       	ldi	r18, 0x64	; 100
     3c6:	30 e0       	ldi	r19, 0x00	; 0
     3c8:	f9 01       	movw	r30, r18
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	f1 f7       	brne	.-4      	; 0x3ca <place+0x5c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     3ce:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     3d0:	d9 f7       	brne	.-10     	; 0x3c8 <place+0x5a>
		_delay_ms(250);
		PORTH=STOP;
     3d2:	8f e0       	ldi	r24, 0x0F	; 15
     3d4:	82 bb       	out	0x12, r24	; 18
     3d6:	8c eb       	ldi	r24, 0xBC	; 188
     3d8:	92 e0       	ldi	r25, 0x02	; 2
     3da:	24 e6       	ldi	r18, 0x64	; 100
     3dc:	30 e0       	ldi	r19, 0x00	; 0
     3de:	f9 01       	movw	r30, r18
     3e0:	31 97       	sbiw	r30, 0x01	; 1
     3e2:	f1 f7       	brne	.-4      	; 0x3e0 <place+0x72>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     3e4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     3e6:	d9 f7       	brne	.-10     	; 0x3de <place+0x70>
		_delay_ms(70);
		PORTH=HANDCLOSE;
     3e8:	81 e0       	ldi	r24, 0x01	; 1
     3ea:	82 bb       	out	0x12, r24	; 18
     3ec:	8c ed       	ldi	r24, 0xDC	; 220
     3ee:	95 e0       	ldi	r25, 0x05	; 5
     3f0:	24 e6       	ldi	r18, 0x64	; 100
     3f2:	30 e0       	ldi	r19, 0x00	; 0
     3f4:	f9 01       	movw	r30, r18
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	f1 f7       	brne	.-4      	; 0x3f6 <place+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     3fa:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     3fc:	d9 f7       	brne	.-10     	; 0x3f4 <place+0x86>
		_delay_ms(150);
		PORTH=STOP;
     3fe:	8f e0       	ldi	r24, 0x0F	; 15
     400:	82 bb       	out	0x12, r24	; 18
}
     402:	08 95       	ret

00000404 <node>:

void node()
{  if(((PINI & 0x04)==0x04)||((PINI & 0x08)==0x08)||((PINI & 0x02)==0x02)) //&&((PINI & 0x20)==0b00000000))
     404:	ca 99       	sbic	0x19, 2	; 25
     406:	04 c0       	rjmp	.+8      	; 0x410 <node+0xc>
     408:	cb 99       	sbic	0x19, 3	; 25
     40a:	02 c0       	rjmp	.+4      	; 0x410 <node+0xc>
     40c:	c9 9b       	sbis	0x19, 1	; 25
     40e:	75 c0       	rjmp	.+234    	; 0x4fa <node+0xf6>
   {
     eeprom_write_byte((uint8_t *)j,((10*X)+Y));
     410:	60 91 ea 00 	lds	r22, 0x00EA
     414:	70 91 eb 00 	lds	r23, 0x00EB
     418:	20 91 e0 00 	lds	r18, 0x00E0
     41c:	30 91 e1 00 	lds	r19, 0x00E1
     420:	40 91 ec 00 	lds	r20, 0x00EC
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
     424:	e1 99       	sbic	0x1c, 1	; 28
     426:	fe cf       	rjmp	.-4      	; 0x424 <node+0x20>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     428:	7f bb       	out	0x1f, r23	; 31
     42a:	6e bb       	out	0x1e, r22	; 30
     42c:	c9 01       	movw	r24, r18
     42e:	e3 e0       	ldi	r30, 0x03	; 3
     430:	22 0f       	add	r18, r18
     432:	33 1f       	adc	r19, r19
     434:	ea 95       	dec	r30
     436:	e1 f7       	brne	.-8      	; 0x430 <node+0x2c>
     438:	88 0f       	add	r24, r24
     43a:	99 1f       	adc	r25, r25
     43c:	28 0f       	add	r18, r24
     43e:	39 1f       	adc	r19, r25
     440:	42 0f       	add	r20, r18
#endif
    EEDR = __value;
     442:	4d bb       	out	0x1d, r20	; 29

    __asm__ __volatile__ (
     444:	0f b6       	in	r0, 0x3f	; 63
     446:	f8 94       	cli
     448:	e2 9a       	sbi	0x1c, 2	; 28
     44a:	e1 9a       	sbi	0x1c, 1	; 28
     44c:	0f be       	out	0x3f, r0	; 63
	  if(j==2)
     44e:	62 30       	cpi	r22, 0x02	; 2
     450:	71 05       	cpc	r23, r1
     452:	51 f4       	brne	.+20     	; 0x468 <node+0x64>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     454:	81 e0       	ldi	r24, 0x01	; 1
     456:	88 bb       	out	0x18, r24	; 24
     458:	80 e1       	ldi	r24, 0x10	; 16
     45a:	97 e2       	ldi	r25, 0x27	; 39
     45c:	01 97       	sbiw	r24, 0x01	; 1
     45e:	f1 f7       	brne	.-4      	; 0x45c <node+0x58>
	  _delay_ms(10);
   	  PORTB=0x00;
     460:	18 ba       	out	0x18, r1	; 24
     462:	80 e5       	ldi	r24, 0x50	; 80
     464:	93 ec       	ldi	r25, 0xC3	; 195
     466:	41 c0       	rjmp	.+130    	; 0x4ea <node+0xe6>
{  if(((PINI & 0x04)==0x04)||((PINI & 0x08)==0x08)||((PINI & 0x02)==0x02)) //&&((PINI & 0x20)==0b00000000))
   {
     eeprom_write_byte((uint8_t *)j,((10*X)+Y));
	  if(j==2)
	  buzzer();
	  if(j==3)
     468:	63 30       	cpi	r22, 0x03	; 3
     46a:	71 05       	cpc	r23, r1
     46c:	59 f4       	brne	.+22     	; 0x484 <node+0x80>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     46e:	41 e0       	ldi	r20, 0x01	; 1
     470:	48 bb       	out	0x18, r20	; 24
     472:	20 e1       	ldi	r18, 0x10	; 16
     474:	37 e2       	ldi	r19, 0x27	; 39
     476:	c9 01       	movw	r24, r18
     478:	01 97       	sbiw	r24, 0x01	; 1
     47a:	f1 f7       	brne	.-4      	; 0x478 <node+0x74>
	  _delay_ms(10);
   	  PORTB=0x00;
     47c:	18 ba       	out	0x18, r1	; 24
     47e:	80 e5       	ldi	r24, 0x50	; 80
     480:	93 ec       	ldi	r25, 0xC3	; 195
     482:	2b c0       	rjmp	.+86     	; 0x4da <node+0xd6>
	  buzzer();
	  if(j==3)
	  { buzzer();
	    buzzer();
      }
	  if(j==4)
     484:	64 30       	cpi	r22, 0x04	; 4
     486:	71 05       	cpc	r23, r1
     488:	59 f4       	brne	.+22     	; 0x4a0 <node+0x9c>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     48a:	41 e0       	ldi	r20, 0x01	; 1
     48c:	48 bb       	out	0x18, r20	; 24
     48e:	20 e1       	ldi	r18, 0x10	; 16
     490:	37 e2       	ldi	r19, 0x27	; 39
     492:	c9 01       	movw	r24, r18
     494:	01 97       	sbiw	r24, 0x01	; 1
     496:	f1 f7       	brne	.-4      	; 0x494 <node+0x90>
	  _delay_ms(10);
   	  PORTB=0x00;
     498:	18 ba       	out	0x18, r1	; 24
     49a:	80 e5       	ldi	r24, 0x50	; 80
     49c:	93 ec       	ldi	r25, 0xC3	; 195
     49e:	15 c0       	rjmp	.+42     	; 0x4ca <node+0xc6>
      }
	  if(j==4)
	  { buzzer();
	    buzzer();
		buzzer();
      }if(j==5)
     4a0:	65 30       	cpi	r22, 0x05	; 5
     4a2:	71 05       	cpc	r23, r1
     4a4:	21 f5       	brne	.+72     	; 0x4ee <node+0xea>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     4a6:	41 e0       	ldi	r20, 0x01	; 1
     4a8:	48 bb       	out	0x18, r20	; 24
     4aa:	20 e1       	ldi	r18, 0x10	; 16
     4ac:	37 e2       	ldi	r19, 0x27	; 39
     4ae:	c9 01       	movw	r24, r18
     4b0:	01 97       	sbiw	r24, 0x01	; 1
     4b2:	f1 f7       	brne	.-4      	; 0x4b0 <node+0xac>
	  _delay_ms(10);
   	  PORTB=0x00;
     4b4:	18 ba       	out	0x18, r1	; 24
     4b6:	80 e5       	ldi	r24, 0x50	; 80
     4b8:	93 ec       	ldi	r25, 0xC3	; 195
     4ba:	fc 01       	movw	r30, r24
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	f1 f7       	brne	.-4      	; 0x4bc <node+0xb8>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     4c0:	48 bb       	out	0x18, r20	; 24
     4c2:	f9 01       	movw	r30, r18
     4c4:	31 97       	sbiw	r30, 0x01	; 1
     4c6:	f1 f7       	brne	.-4      	; 0x4c4 <node+0xc0>
	  _delay_ms(10);
   	  PORTB=0x00;
     4c8:	18 ba       	out	0x18, r1	; 24
     4ca:	fc 01       	movw	r30, r24
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	f1 f7       	brne	.-4      	; 0x4cc <node+0xc8>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     4d0:	48 bb       	out	0x18, r20	; 24
     4d2:	f9 01       	movw	r30, r18
     4d4:	31 97       	sbiw	r30, 0x01	; 1
     4d6:	f1 f7       	brne	.-4      	; 0x4d4 <node+0xd0>
	  _delay_ms(10);
   	  PORTB=0x00;
     4d8:	18 ba       	out	0x18, r1	; 24
     4da:	fc 01       	movw	r30, r24
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	f1 f7       	brne	.-4      	; 0x4dc <node+0xd8>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
     4e0:	48 bb       	out	0x18, r20	; 24
     4e2:	f9 01       	movw	r30, r18
     4e4:	31 97       	sbiw	r30, 0x01	; 1
     4e6:	f1 f7       	brne	.-4      	; 0x4e4 <node+0xe0>
	  _delay_ms(10);
   	  PORTB=0x00;
     4e8:	18 ba       	out	0x18, r1	; 24
     4ea:	01 97       	sbiw	r24, 0x01	; 1
     4ec:	f1 f7       	brne	.-4      	; 0x4ea <node+0xe6>
	  { buzzer();
	    buzzer();
		buzzer();
		buzzer();
      }
	  j++;
     4ee:	6f 5f       	subi	r22, 0xFF	; 255
     4f0:	7f 4f       	sbci	r23, 0xFF	; 255
     4f2:	70 93 eb 00 	sts	0x00EB, r23
     4f6:	60 93 ea 00 	sts	0x00EA, r22
     4fa:	08 95       	ret

000004fc <gridfollow>:
	  
   }
}
void gridfollow()
{
     4fc:	ef 92       	push	r14
     4fe:	ff 92       	push	r15
     500:	0f 93       	push	r16
     502:	1f 93       	push	r17
     504:	cf 93       	push	r28
     506:	df 93       	push	r29
   PORTM=FORWARD;
     508:	89 e0       	ldi	r24, 0x09	; 9
     50a:	85 bb       	out	0x15, r24	; 21
     50c:	8c eb       	ldi	r24, 0xBC	; 188
     50e:	92 e0       	ldi	r25, 0x02	; 2
     510:	24 e6       	ldi	r18, 0x64	; 100
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	f9 01       	movw	r30, r18
     516:	31 97       	sbiw	r30, 0x01	; 1
     518:	f1 f7       	brne	.-4      	; 0x516 <gridfollow+0x1a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     51a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     51c:	d9 f7       	brne	.-10     	; 0x514 <gridfollow+0x18>
     51e:	20 91 fa 00 	lds	r18, 0x00FA
     522:	30 91 fb 00 	lds	r19, 0x00FB
	  {
	   X1=xx1;Y1=yy1;
	   X2=xx2;Y2=yy2;
	   if(grab==0)
	   {
	    PORTM=STOP;
     526:	af e0       	ldi	r26, 0x0F	; 15
     528:	ea 2e       	mov	r14, r26
     52a:	c4 e6       	ldi	r28, 0x64	; 100
     52c:	d0 e0       	ldi	r29, 0x00	; 0
	  {
	    PORTM=SMOOTHLEFT;
	  }
	  else if((PINI & 0x35)==0b00010001) 
	  {
	    PORTM=FORWARD;
     52e:	f9 e0       	ldi	r31, 0x09	; 9
     530:	ff 2e       	mov	r15, r31
	  {
	    PORTM=SMOOTHLEFT;
	  }
      else if((PINI & 0x35)==0b00000101) 
	  {
	    PORTM=SMOOTHLEFT;
     532:	01 e0       	ldi	r16, 0x01	; 1
	  {
	    PORTM=SMOOTHRIGHT;
      }
      else if((PINI & 0x35)==0b00010100) 
	  {
	    PORTM=SMOOTHRIGHT;
     534:	18 e0       	ldi	r17, 0x08	; 8
     536:	78 c0       	rjmp	.+240    	; 0x628 <gridfollow+0x12c>
{
   PORTM=FORWARD;
   _delay_ms( 70);
   while(/*((PINI & 0x31)!=0b00000000)||*/((PINI & 0x33)!=0b00000000)||((PINI & 0x39)!=0b00000000)) 
   {
      if((PINI & 0x35)==0b00010001)  
     538:	89 b3       	in	r24, 0x19	; 25
     53a:	85 73       	andi	r24, 0x35	; 53
     53c:	81 31       	cpi	r24, 0x11	; 17
     53e:	c1 f0       	breq	.+48     	; 0x570 <gridfollow+0x74>
	  {
    	PORTM=FORWARD;
	  }
	  else if((PINI & 0x35)==0b00010000) 
     540:	89 b3       	in	r24, 0x19	; 25
     542:	85 73       	andi	r24, 0x35	; 53
     544:	80 31       	cpi	r24, 0x10	; 16
     546:	21 f0       	breq	.+8      	; 0x550 <gridfollow+0x54>
	  {
	    PORTM=SMOOTHRIGHT;
      }
      else if((PINI & 0x35)==0b00010100) 
     548:	89 b3       	in	r24, 0x19	; 25
     54a:	85 73       	andi	r24, 0x35	; 53
     54c:	84 31       	cpi	r24, 0x14	; 20
     54e:	11 f4       	brne	.+4      	; 0x554 <gridfollow+0x58>
	  {
	    PORTM=SMOOTHRIGHT;
     550:	15 bb       	out	0x15, r17	; 21
     552:	6a c0       	rjmp	.+212    	; 0x628 <gridfollow+0x12c>
	  }
	  else if((PINI & 0x35)==0b00000001) 
     554:	89 b3       	in	r24, 0x19	; 25
     556:	85 73       	andi	r24, 0x35	; 53
     558:	81 30       	cpi	r24, 0x01	; 1
     55a:	21 f0       	breq	.+8      	; 0x564 <gridfollow+0x68>
	  {
	    PORTM=SMOOTHLEFT;
	  }
      else if((PINI & 0x35)==0b00000101) 
     55c:	89 b3       	in	r24, 0x19	; 25
     55e:	85 73       	andi	r24, 0x35	; 53
     560:	85 30       	cpi	r24, 0x05	; 5
     562:	11 f4       	brne	.+4      	; 0x568 <gridfollow+0x6c>
	  {
	    PORTM=SMOOTHLEFT;
     564:	05 bb       	out	0x15, r16	; 21
     566:	60 c0       	rjmp	.+192    	; 0x628 <gridfollow+0x12c>
	  }
	  else if((PINI & 0x35)==0b00010001) 
     568:	89 b3       	in	r24, 0x19	; 25
     56a:	85 73       	andi	r24, 0x35	; 53
     56c:	81 31       	cpi	r24, 0x11	; 17
     56e:	11 f4       	brne	.+4      	; 0x574 <gridfollow+0x78>
	  {
	    PORTM=FORWARD;
     570:	f5 ba       	out	0x15, r15	; 21
     572:	5a c0       	rjmp	.+180    	; 0x628 <gridfollow+0x12c>
	  }
	  else if((PINI & 0x35)==0b00010101) 
     574:	89 b3       	in	r24, 0x19	; 25
     576:	85 73       	andi	r24, 0x35	; 53
     578:	85 31       	cpi	r24, 0x15	; 21
     57a:	11 f4       	brne	.+4      	; 0x580 <gridfollow+0x84>
	  {
	    PORTM=STOP;
     57c:	e5 ba       	out	0x15, r14	; 21
     57e:	54 c0       	rjmp	.+168    	; 0x628 <gridfollow+0x12c>
	  }
	  else if((PINI & 0x35)==0b00110001)
     580:	89 b3       	in	r24, 0x19	; 25
     582:	85 73       	andi	r24, 0x35	; 53
     584:	81 33       	cpi	r24, 0x31	; 49
     586:	09 f0       	breq	.+2      	; 0x58a <gridfollow+0x8e>
     588:	4f c0       	rjmp	.+158    	; 0x628 <gridfollow+0x12c>
	  {
	   X1=xx1;Y1=yy1;
     58a:	80 91 00 01 	lds	r24, 0x0100
     58e:	90 91 01 01 	lds	r25, 0x0101
     592:	90 93 07 01 	sts	0x0107, r25
     596:	80 93 06 01 	sts	0x0106, r24
     59a:	80 91 fe 00 	lds	r24, 0x00FE
     59e:	90 91 ff 00 	lds	r25, 0x00FF
     5a2:	90 93 0b 01 	sts	0x010B, r25
     5a6:	80 93 0a 01 	sts	0x010A, r24
	   X2=xx2;Y2=yy2;
     5aa:	80 91 fc 00 	lds	r24, 0x00FC
     5ae:	90 91 fd 00 	lds	r25, 0x00FD
     5b2:	90 93 05 01 	sts	0x0105, r25
     5b6:	80 93 04 01 	sts	0x0104, r24
     5ba:	80 91 08 01 	lds	r24, 0x0108
     5be:	90 91 09 01 	lds	r25, 0x0109
     5c2:	90 93 03 01 	sts	0x0103, r25
     5c6:	80 93 02 01 	sts	0x0102, r24
	   if(grab==0)
     5ca:	21 15       	cp	r18, r1
     5cc:	31 05       	cpc	r19, r1
     5ce:	61 f4       	brne	.+24     	; 0x5e8 <gridfollow+0xec>
	   {
	    PORTM=STOP;
     5d0:	e5 ba       	out	0x15, r14	; 21
     5d2:	88 ee       	ldi	r24, 0xE8	; 232
     5d4:	93 e0       	ldi	r25, 0x03	; 3
     5d6:	fe 01       	movw	r30, r28
     5d8:	31 97       	sbiw	r30, 0x01	; 1
     5da:	f1 f7       	brne	.-4      	; 0x5d8 <gridfollow+0xdc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     5dc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     5de:	d9 f7       	brne	.-10     	; 0x5d6 <gridfollow+0xda>
		_delay_ms(100);
	    pickup();
     5e0:	0e 94 4d 01 	call	0x29a	; 0x29a <pickup>
     5e4:	21 e0       	ldi	r18, 0x01	; 1
     5e6:	30 e0       	ldi	r19, 0x00	; 0
	    grab=1;
       }
	    xx1=X1;yy1=Y1;
     5e8:	80 91 06 01 	lds	r24, 0x0106
     5ec:	90 91 07 01 	lds	r25, 0x0107
     5f0:	90 93 01 01 	sts	0x0101, r25
     5f4:	80 93 00 01 	sts	0x0100, r24
     5f8:	80 91 0a 01 	lds	r24, 0x010A
     5fc:	90 91 0b 01 	lds	r25, 0x010B
     600:	90 93 ff 00 	sts	0x00FF, r25
     604:	80 93 fe 00 	sts	0x00FE, r24
	    xx2=X2;yy2=Y2;       
     608:	80 91 04 01 	lds	r24, 0x0104
     60c:	90 91 05 01 	lds	r25, 0x0105
     610:	90 93 fd 00 	sts	0x00FD, r25
     614:	80 93 fc 00 	sts	0x00FC, r24
     618:	80 91 02 01 	lds	r24, 0x0102
     61c:	90 91 03 01 	lds	r25, 0x0103
     620:	90 93 09 01 	sts	0x0109, r25
     624:	80 93 08 01 	sts	0x0108, r24
}
void gridfollow()
{
   PORTM=FORWARD;
   _delay_ms( 70);
   while(/*((PINI & 0x31)!=0b00000000)||*/((PINI & 0x33)!=0b00000000)||((PINI & 0x39)!=0b00000000)) 
     628:	89 b3       	in	r24, 0x19	; 25
     62a:	83 73       	andi	r24, 0x33	; 51
     62c:	09 f0       	breq	.+2      	; 0x630 <gridfollow+0x134>
     62e:	84 cf       	rjmp	.-248    	; 0x538 <gridfollow+0x3c>
     630:	89 b3       	in	r24, 0x19	; 25
     632:	89 73       	andi	r24, 0x39	; 57
     634:	09 f0       	breq	.+2      	; 0x638 <gridfollow+0x13c>
     636:	80 cf       	rjmp	.-256    	; 0x538 <gridfollow+0x3c>
     638:	30 93 fb 00 	sts	0x00FB, r19
     63c:	20 93 fa 00 	sts	0x00FA, r18
       }
	    xx1=X1;yy1=Y1;
	    xx2=X2;yy2=Y2;       
	  }
   }
   PORTM=STOP;
     640:	8f e0       	ldi	r24, 0x0F	; 15
     642:	85 bb       	out	0x15, r24	; 21
     644:	80 e3       	ldi	r24, 0x30	; 48
     646:	95 e7       	ldi	r25, 0x75	; 117
     648:	01 97       	sbiw	r24, 0x01	; 1
     64a:	f1 f7       	brne	.-4      	; 0x648 <gridfollow+0x14c>
   _delay_ms(30);
   if(dir==3)
     64c:	80 91 e8 00 	lds	r24, 0x00E8
     650:	90 91 e9 00 	lds	r25, 0x00E9
     654:	83 30       	cpi	r24, 0x03	; 3
     656:	91 05       	cpc	r25, r1
     658:	31 f4       	brne	.+12     	; 0x666 <gridfollow+0x16a>
   {
     X=X+1;
     65a:	80 91 e0 00 	lds	r24, 0x00E0
     65e:	90 91 e1 00 	lds	r25, 0x00E1
     662:	01 96       	adiw	r24, 0x01	; 1
     664:	11 c0       	rjmp	.+34     	; 0x688 <gridfollow+0x18c>
   }
   if(dir==2)
     666:	82 30       	cpi	r24, 0x02	; 2
     668:	91 05       	cpc	r25, r1
     66a:	31 f4       	brne	.+12     	; 0x678 <gridfollow+0x17c>
   {
     Y=Y+1;
     66c:	80 91 ec 00 	lds	r24, 0x00EC
     670:	90 91 ed 00 	lds	r25, 0x00ED
     674:	01 96       	adiw	r24, 0x01	; 1
     676:	14 c0       	rjmp	.+40     	; 0x6a0 <gridfollow+0x1a4>
   }
   if(dir==1)
     678:	81 30       	cpi	r24, 0x01	; 1
     67a:	91 05       	cpc	r25, r1
     67c:	51 f4       	brne	.+20     	; 0x692 <gridfollow+0x196>
   {
     X=X-1;
     67e:	80 91 e0 00 	lds	r24, 0x00E0
     682:	90 91 e1 00 	lds	r25, 0x00E1
     686:	01 97       	sbiw	r24, 0x01	; 1
     688:	90 93 e1 00 	sts	0x00E1, r25
     68c:	80 93 e0 00 	sts	0x00E0, r24
     690:	0b c0       	rjmp	.+22     	; 0x6a8 <gridfollow+0x1ac>
   }
   if(dir==4)
     692:	04 97       	sbiw	r24, 0x04	; 4
     694:	49 f4       	brne	.+18     	; 0x6a8 <gridfollow+0x1ac>
   {
     Y=Y-1;
     696:	80 91 ec 00 	lds	r24, 0x00EC
     69a:	90 91 ed 00 	lds	r25, 0x00ED
     69e:	01 97       	sbiw	r24, 0x01	; 1
     6a0:	90 93 ed 00 	sts	0x00ED, r25
     6a4:	80 93 ec 00 	sts	0x00EC, r24
   }
}
     6a8:	df 91       	pop	r29
     6aa:	cf 91       	pop	r28
     6ac:	1f 91       	pop	r17
     6ae:	0f 91       	pop	r16
     6b0:	ff 90       	pop	r15
     6b2:	ef 90       	pop	r14
     6b4:	08 95       	ret

000006b6 <gridfollowfinal>:

void gridfollowfinal()
{
   PORTM=FORWARD;
     6b6:	89 e0       	ldi	r24, 0x09	; 9
     6b8:	85 bb       	out	0x15, r24	; 21
     6ba:	8c eb       	ldi	r24, 0xBC	; 188
     6bc:	92 e0       	ldi	r25, 0x02	; 2
     6be:	24 e6       	ldi	r18, 0x64	; 100
     6c0:	30 e0       	ldi	r19, 0x00	; 0
     6c2:	f9 01       	movw	r30, r18
     6c4:	31 97       	sbiw	r30, 0x01	; 1
     6c6:	f1 f7       	brne	.-4      	; 0x6c4 <gridfollowfinal+0xe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6c8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6ca:	d9 f7       	brne	.-10     	; 0x6c2 <gridfollowfinal+0xc>
     6cc:	24 c0       	rjmp	.+72     	; 0x716 <gridfollowfinal+0x60>
   _delay_ms( 70);
   while((PINI & 0x35)!=0b00110001) 
   {
      if((PINI & 0x35)==0b00010001)  
     6ce:	89 b3       	in	r24, 0x19	; 25
     6d0:	85 73       	andi	r24, 0x35	; 53
     6d2:	81 31       	cpi	r24, 0x11	; 17
     6d4:	c1 f0       	breq	.+48     	; 0x706 <gridfollowfinal+0x50>
	  {
    	PORTM=FORWARD;
	  }
	  else if((PINI & 0x35)==0b00010000) 
     6d6:	89 b3       	in	r24, 0x19	; 25
     6d8:	85 73       	andi	r24, 0x35	; 53
     6da:	80 31       	cpi	r24, 0x10	; 16
     6dc:	21 f0       	breq	.+8      	; 0x6e6 <gridfollowfinal+0x30>
	  {
	    PORTM=SMOOTHRIGHT;
      }
      else if((PINI & 0x35)==0b00010100) 
     6de:	89 b3       	in	r24, 0x19	; 25
     6e0:	85 73       	andi	r24, 0x35	; 53
     6e2:	84 31       	cpi	r24, 0x14	; 20
     6e4:	11 f4       	brne	.+4      	; 0x6ea <gridfollowfinal+0x34>
	  {
	    PORTM=SMOOTHRIGHT;
     6e6:	95 bb       	out	0x15, r25	; 21
     6e8:	1a c0       	rjmp	.+52     	; 0x71e <gridfollowfinal+0x68>
	  }
	  else if((PINI & 0x35)==0b00000001) 
     6ea:	89 b3       	in	r24, 0x19	; 25
     6ec:	85 73       	andi	r24, 0x35	; 53
     6ee:	81 30       	cpi	r24, 0x01	; 1
     6f0:	21 f0       	breq	.+8      	; 0x6fa <gridfollowfinal+0x44>
	  {
	    PORTM=SMOOTHLEFT;
	  }
      else if((PINI & 0x35)==0b00000101) 
     6f2:	89 b3       	in	r24, 0x19	; 25
     6f4:	85 73       	andi	r24, 0x35	; 53
     6f6:	85 30       	cpi	r24, 0x05	; 5
     6f8:	11 f4       	brne	.+4      	; 0x6fe <gridfollowfinal+0x48>
	  {
	    PORTM=SMOOTHLEFT;
     6fa:	25 bb       	out	0x15, r18	; 21
     6fc:	10 c0       	rjmp	.+32     	; 0x71e <gridfollowfinal+0x68>
	  }
	  else if((PINI & 0x35)==0b00010001) 
     6fe:	89 b3       	in	r24, 0x19	; 25
     700:	85 73       	andi	r24, 0x35	; 53
     702:	81 31       	cpi	r24, 0x11	; 17
     704:	11 f4       	brne	.+4      	; 0x70a <gridfollowfinal+0x54>
	  {
	    PORTM=FORWARD;
     706:	35 bb       	out	0x15, r19	; 21
     708:	0a c0       	rjmp	.+20     	; 0x71e <gridfollowfinal+0x68>
	  }
	  else if((PINI & 0x35)==0b00010101) 
     70a:	89 b3       	in	r24, 0x19	; 25
     70c:	85 73       	andi	r24, 0x35	; 53
     70e:	85 31       	cpi	r24, 0x15	; 21
     710:	31 f4       	brne	.+12     	; 0x71e <gridfollowfinal+0x68>
	  {
	    PORTM=STOP;
     712:	45 bb       	out	0x15, r20	; 21
     714:	04 c0       	rjmp	.+8      	; 0x71e <gridfollowfinal+0x68>
     716:	4f e0       	ldi	r20, 0x0F	; 15
	  {
	    PORTM=SMOOTHLEFT;
	  }
	  else if((PINI & 0x35)==0b00010001) 
	  {
	    PORTM=FORWARD;
     718:	39 e0       	ldi	r19, 0x09	; 9
	  {
	    PORTM=SMOOTHLEFT;
	  }
      else if((PINI & 0x35)==0b00000101) 
	  {
	    PORTM=SMOOTHLEFT;
     71a:	21 e0       	ldi	r18, 0x01	; 1
	  {
	    PORTM=SMOOTHRIGHT;
      }
      else if((PINI & 0x35)==0b00010100) 
	  {
	    PORTM=SMOOTHRIGHT;
     71c:	98 e0       	ldi	r25, 0x08	; 8

void gridfollowfinal()
{
   PORTM=FORWARD;
   _delay_ms( 70);
   while((PINI & 0x35)!=0b00110001) 
     71e:	89 b3       	in	r24, 0x19	; 25
     720:	85 73       	andi	r24, 0x35	; 53
     722:	81 33       	cpi	r24, 0x31	; 49
     724:	a1 f6       	brne	.-88     	; 0x6ce <gridfollowfinal+0x18>
	  else if((PINI & 0x35)==0b00010101) 
	  {
	    PORTM=STOP;
	  }
   }
}
     726:	08 95       	ret

00000728 <linefollow>:


void linefollow()
{
     728:	ef 92       	push	r14
     72a:	ff 92       	push	r15
     72c:	0f 93       	push	r16
     72e:	1f 93       	push	r17
     730:	cf 93       	push	r28
     732:	df 93       	push	r29
	    turnright();
	  }
      else if((PINI & 0x3F)== 0b00000001)
	  {
	    turnleft();
		PORTH=HANDUP;
     734:	18 e0       	ldi	r17, 0x08	; 8
     736:	c4 e6       	ldi	r28, 0x64	; 100
     738:	d0 e0       	ldi	r29, 0x00	; 0
		_delay_ms(250);
		PORTH=STOP;
     73a:	0f e0       	ldi	r16, 0x0F	; 15
     73c:	e0 2e       	mov	r14, r16
	  {
	    PORTM=SMOOTHLEFT;
	  }
	  else if((PINA & 0x3F)==0b00011011)
	  {
	    PORTM=FORWARD;
     73e:	b9 e0       	ldi	r27, 0x09	; 9
     740:	fb 2e       	mov	r15, r27
	  {
	    PORTM=SMOOTHLEFT;
	  }
      else if((PINI & 0x3F)==0b00000111)
	  {
	    PORTM=SMOOTHLEFT;
     742:	01 e0       	ldi	r16, 0x01	; 1
     744:	41 c0       	rjmp	.+130    	; 0x7c8 <linefollow+0xa0>

void linefollow()
{
while((PINI & 0x35)!=0b00110001)
   { 
      if((PINI & 0x3F)==0b00010001)
     746:	89 b3       	in	r24, 0x19	; 25
     748:	8f 73       	andi	r24, 0x3F	; 63
     74a:	81 31       	cpi	r24, 0x11	; 17
     74c:	c1 f0       	breq	.+48     	; 0x77e <linefollow+0x56>
	  {
    	PORTM=FORWARD;
	  }
	  else if((PINI & 0x3F)==0b00011000)
     74e:	89 b3       	in	r24, 0x19	; 25
     750:	8f 73       	andi	r24, 0x3F	; 63
     752:	88 31       	cpi	r24, 0x18	; 24
     754:	21 f0       	breq	.+8      	; 0x75e <linefollow+0x36>
	  {
	    PORTM=SMOOTHRIGHT;
      }
      else if((PINI & 0x3F)==0b00011100)
     756:	89 b3       	in	r24, 0x19	; 25
     758:	8f 73       	andi	r24, 0x3F	; 63
     75a:	8c 31       	cpi	r24, 0x1C	; 28
     75c:	11 f4       	brne	.+4      	; 0x762 <linefollow+0x3a>
	  {
	    PORTM=SMOOTHRIGHT;
     75e:	15 bb       	out	0x15, r17	; 21
     760:	33 c0       	rjmp	.+102    	; 0x7c8 <linefollow+0xa0>
	  }
	  else if((PINI & 0x3F)==0b00000011)
     762:	89 b3       	in	r24, 0x19	; 25
     764:	8f 73       	andi	r24, 0x3F	; 63
     766:	83 30       	cpi	r24, 0x03	; 3
     768:	21 f0       	breq	.+8      	; 0x772 <linefollow+0x4a>
	  {
	    PORTM=SMOOTHLEFT;
	  }
      else if((PINI & 0x3F)==0b00000111)
     76a:	89 b3       	in	r24, 0x19	; 25
     76c:	8f 73       	andi	r24, 0x3F	; 63
     76e:	87 30       	cpi	r24, 0x07	; 7
     770:	11 f4       	brne	.+4      	; 0x776 <linefollow+0x4e>
	  {
	    PORTM=SMOOTHLEFT;
     772:	05 bb       	out	0x15, r16	; 21
     774:	29 c0       	rjmp	.+82     	; 0x7c8 <linefollow+0xa0>
	  }
	  else if((PINA & 0x3F)==0b00011011)
     776:	89 b3       	in	r24, 0x19	; 25
     778:	8f 73       	andi	r24, 0x3F	; 63
     77a:	8b 31       	cpi	r24, 0x1B	; 27
     77c:	11 f4       	brne	.+4      	; 0x782 <linefollow+0x5a>
	  {
	    PORTM=FORWARD;
     77e:	f5 ba       	out	0x15, r15	; 21
     780:	23 c0       	rjmp	.+70     	; 0x7c8 <linefollow+0xa0>
	  }
	  else if((PINI & 0x3F)==0b00011111)
     782:	89 b3       	in	r24, 0x19	; 25
     784:	8f 73       	andi	r24, 0x3F	; 63
     786:	8f 31       	cpi	r24, 0x1F	; 31
     788:	11 f4       	brne	.+4      	; 0x78e <linefollow+0x66>
	  {
	    PORTM=STOP;
     78a:	e5 ba       	out	0x15, r14	; 21
     78c:	1d c0       	rjmp	.+58     	; 0x7c8 <linefollow+0xa0>
	  }
      else if((PINI & 0x3F)== 0b00010000)
     78e:	89 b3       	in	r24, 0x19	; 25
     790:	8f 73       	andi	r24, 0x3F	; 63
     792:	80 31       	cpi	r24, 0x10	; 16
     794:	19 f4       	brne	.+6      	; 0x79c <linefollow+0x74>
	  {
	    turnright();
     796:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
     79a:	16 c0       	rjmp	.+44     	; 0x7c8 <linefollow+0xa0>
	  }
      else if((PINI & 0x3F)== 0b00000001)
     79c:	89 b3       	in	r24, 0x19	; 25
     79e:	8f 73       	andi	r24, 0x3F	; 63
     7a0:	81 30       	cpi	r24, 0x01	; 1
     7a2:	91 f4       	brne	.+36     	; 0x7c8 <linefollow+0xa0>
	  {
	    turnleft();
     7a4:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
		PORTH=HANDUP;
     7a8:	12 bb       	out	0x12, r17	; 18
     7aa:	84 ec       	ldi	r24, 0xC4	; 196
     7ac:	99 e0       	ldi	r25, 0x09	; 9
     7ae:	fe 01       	movw	r30, r28
     7b0:	31 97       	sbiw	r30, 0x01	; 1
     7b2:	f1 f7       	brne	.-4      	; 0x7b0 <linefollow+0x88>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7b4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7b6:	d9 f7       	brne	.-10     	; 0x7ae <linefollow+0x86>
		_delay_ms(250);
		PORTH=STOP;
     7b8:	e2 ba       	out	0x12, r14	; 18
     7ba:	8c eb       	ldi	r24, 0xBC	; 188
     7bc:	92 e0       	ldi	r25, 0x02	; 2
     7be:	fe 01       	movw	r30, r28
     7c0:	31 97       	sbiw	r30, 0x01	; 1
     7c2:	f1 f7       	brne	.-4      	; 0x7c0 <linefollow+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7c4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7c6:	d9 f7       	brne	.-10     	; 0x7be <linefollow+0x96>
}


void linefollow()
{
while((PINI & 0x35)!=0b00110001)
     7c8:	89 b3       	in	r24, 0x19	; 25
     7ca:	85 73       	andi	r24, 0x35	; 53
     7cc:	81 33       	cpi	r24, 0x31	; 49
     7ce:	09 f0       	breq	.+2      	; 0x7d2 <linefollow+0xaa>
     7d0:	ba cf       	rjmp	.-140    	; 0x746 <linefollow+0x1e>
		_delay_ms(250);
		PORTH=STOP;
		_delay_ms(70);
	  }
   }
}
     7d2:	df 91       	pop	r29
     7d4:	cf 91       	pop	r28
     7d6:	1f 91       	pop	r17
     7d8:	0f 91       	pop	r16
     7da:	ff 90       	pop	r15
     7dc:	ef 90       	pop	r14
     7de:	08 95       	ret

000007e0 <push>:
void push(stack *p,int n)
{
     7e0:	dc 01       	movw	r26, r24
 	 if(p->top==MAX-1)
     7e2:	dc 96       	adiw	r26, 0x3c	; 60
     7e4:	ed 91       	ld	r30, X+
     7e6:	fc 91       	ld	r31, X
     7e8:	dd 97       	sbiw	r26, 0x3d	; 61
     7ea:	ed 31       	cpi	r30, 0x1D	; 29
     7ec:	f1 05       	cpc	r31, r1
     7ee:	59 f0       	breq	.+22     	; 0x806 <push+0x26>
	     return;
     p->top++;
     7f0:	31 96       	adiw	r30, 0x01	; 1
     7f2:	dd 96       	adiw	r26, 0x3d	; 61
     7f4:	fc 93       	st	X, r31
     7f6:	ee 93       	st	-X, r30
     7f8:	dc 97       	sbiw	r26, 0x3c	; 60
     p->a[p->top]=n;
     7fa:	ee 0f       	add	r30, r30
     7fc:	ff 1f       	adc	r31, r31
     7fe:	ea 0f       	add	r30, r26
     800:	fb 1f       	adc	r31, r27
     802:	71 83       	std	Z+1, r23	; 0x01
     804:	60 83       	st	Z, r22
     806:	08 95       	ret

00000808 <pop>:
}
int pop(stack *p)
{
     808:	dc 01       	movw	r26, r24
 	 int n;
 	 if(p->top==-1)
     80a:	dc 96       	adiw	r26, 0x3c	; 60
     80c:	2d 91       	ld	r18, X+
     80e:	3c 91       	ld	r19, X
     810:	dd 97       	sbiw	r26, 0x3d	; 61
     812:	8f ef       	ldi	r24, 0xFF	; 255
     814:	2f 3f       	cpi	r18, 0xFF	; 255
     816:	38 07       	cpc	r19, r24
     818:	19 f4       	brne	.+6      	; 0x820 <pop+0x18>
     81a:	e0 e0       	ldi	r30, 0x00	; 0
     81c:	f0 e0       	ldi	r31, 0x00	; 0
     81e:	0e c0       	rjmp	.+28     	; 0x83c <pop+0x34>
 	     return 0;
     n=p->a[p->top];
     820:	f9 01       	movw	r30, r18
     822:	ee 0f       	add	r30, r30
     824:	ff 1f       	adc	r31, r31
     826:	ea 0f       	add	r30, r26
     828:	fb 1f       	adc	r31, r27
     82a:	01 90       	ld	r0, Z+
     82c:	f0 81       	ld	r31, Z
     82e:	e0 2d       	mov	r30, r0
     p->top--;
     830:	21 50       	subi	r18, 0x01	; 1
     832:	30 40       	sbci	r19, 0x00	; 0
     834:	dd 96       	adiw	r26, 0x3d	; 61
     836:	3c 93       	st	X, r19
     838:	2e 93       	st	-X, r18
     83a:	dc 97       	sbiw	r26, 0x3c	; 60
     return n;
}
     83c:	cf 01       	movw	r24, r30
     83e:	08 95       	ret

00000840 <pushcheck>:
int pushcheck(stack s,int n)
{
     840:	df 93       	push	r29
     842:	cf 93       	push	r28
     844:	cd b7       	in	r28, 0x3d	; 61
     846:	de b7       	in	r29, 0x3e	; 62
     848:	25 96       	adiw	r28, 0x05	; 5
     84a:	4e ad       	ldd	r20, Y+62	; 0x3e
     84c:	5f ad       	ldd	r21, Y+63	; 0x3f
     84e:	25 97       	sbiw	r28, 0x05	; 5
     850:	23 96       	adiw	r28, 0x03	; 3
     852:	8e ad       	ldd	r24, Y+62	; 0x3e
     854:	9f ad       	ldd	r25, Y+63	; 0x3f
     856:	23 97       	sbiw	r28, 0x03	; 3
     858:	fc 01       	movw	r30, r24
     85a:	ee 0f       	add	r30, r30
     85c:	ff 1f       	adc	r31, r31
     85e:	25 e0       	ldi	r18, 0x05	; 5
     860:	30 e0       	ldi	r19, 0x00	; 0
     862:	2c 0f       	add	r18, r28
     864:	3d 1f       	adc	r19, r29
     866:	e2 0f       	add	r30, r18
     868:	f3 1f       	adc	r31, r19
     86a:	9c 01       	movw	r18, r24
     86c:	0b c0       	rjmp	.+22     	; 0x884 <__stack+0x25>
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
     86e:	80 81       	ld	r24, Z
     870:	91 81       	ldd	r25, Z+1	; 0x01
     872:	32 97       	sbiw	r30, 0x02	; 2
     874:	48 17       	cp	r20, r24
     876:	59 07       	cpc	r21, r25
     878:	19 f4       	brne	.+6      	; 0x880 <__stack+0x21>
     87a:	20 e0       	ldi	r18, 0x00	; 0
     87c:	30 e0       	ldi	r19, 0x00	; 0
     87e:	06 c0       	rjmp	.+12     	; 0x88c <__stack+0x2d>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
     880:	21 50       	subi	r18, 0x01	; 1
     882:	30 40       	sbci	r19, 0x00	; 0
     884:	37 ff       	sbrs	r19, 7
     886:	f3 cf       	rjmp	.-26     	; 0x86e <__stack+0xf>
     888:	21 e0       	ldi	r18, 0x01	; 1
     88a:	30 e0       	ldi	r19, 0x00	; 0
      if(n==s.a[i])
         return 0;
      return 1;
}
     88c:	c9 01       	movw	r24, r18
     88e:	cf 91       	pop	r28
     890:	df 91       	pop	r29
     892:	08 95       	ret

00000894 <TOP>:
int TOP(stack s)
{
     894:	df 93       	push	r29
     896:	cf 93       	push	r28
     898:	cd b7       	in	r28, 0x3d	; 61
     89a:	de b7       	in	r29, 0x3e	; 62
     89c:	23 96       	adiw	r28, 0x03	; 3
     89e:	ee ad       	ldd	r30, Y+62	; 0x3e
     8a0:	ff ad       	ldd	r31, Y+63	; 0x3f
     8a2:	23 97       	sbiw	r28, 0x03	; 3
     8a4:	ee 0f       	add	r30, r30
     8a6:	ff 1f       	adc	r31, r31
     8a8:	85 e0       	ldi	r24, 0x05	; 5
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	8c 0f       	add	r24, r28
     8ae:	9d 1f       	adc	r25, r29
     8b0:	e8 0f       	add	r30, r24
     8b2:	f9 1f       	adc	r31, r25
 	return s.a[s.top];
}
     8b4:	80 81       	ld	r24, Z
     8b6:	91 81       	ldd	r25, Z+1	; 0x01
     8b8:	cf 91       	pop	r28
     8ba:	df 91       	pop	r29
     8bc:	08 95       	ret

000008be <left>:
void left(stack *p,int n,int *d)
{ if(n!=0)
     8be:	0f 93       	push	r16
     8c0:	1f 93       	push	r17
     8c2:	df 93       	push	r29
     8c4:	cf 93       	push	r28
     8c6:	cd b7       	in	r28, 0x3d	; 61
     8c8:	de b7       	in	r29, 0x3e	; 62
     8ca:	ee 97       	sbiw	r28, 0x3e	; 62
     8cc:	0f b6       	in	r0, 0x3f	; 63
     8ce:	f8 94       	cli
     8d0:	de bf       	out	0x3e, r29	; 62
     8d2:	0f be       	out	0x3f, r0	; 63
     8d4:	cd bf       	out	0x3d, r28	; 61
     8d6:	8c 01       	movw	r16, r24
     8d8:	61 15       	cp	r22, r1
     8da:	71 05       	cpc	r23, r1
     8dc:	c9 f1       	breq	.+114    	; 0x950 <left+0x92>
 	 if(pushcheck(*p,n))
     8de:	de 01       	movw	r26, r28
     8e0:	11 96       	adiw	r26, 0x01	; 1
     8e2:	fc 01       	movw	r30, r24
     8e4:	8e e3       	ldi	r24, 0x3E	; 62
     8e6:	01 90       	ld	r0, Z+
     8e8:	0d 92       	st	X+, r0
     8ea:	81 50       	subi	r24, 0x01	; 1
     8ec:	e1 f7       	brne	.-8      	; 0x8e6 <left+0x28>
     8ee:	2d ad       	ldd	r18, Y+61	; 0x3d
     8f0:	3e ad       	ldd	r19, Y+62	; 0x3e
     8f2:	c9 01       	movw	r24, r18
     8f4:	88 0f       	add	r24, r24
     8f6:	99 1f       	adc	r25, r25
     8f8:	fe 01       	movw	r30, r28
     8fa:	31 96       	adiw	r30, 0x01	; 1
     8fc:	e8 0f       	add	r30, r24
     8fe:	f9 1f       	adc	r31, r25
     900:	08 c0       	rjmp	.+16     	; 0x912 <left+0x54>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
     902:	80 81       	ld	r24, Z
     904:	91 81       	ldd	r25, Z+1	; 0x01
     906:	21 50       	subi	r18, 0x01	; 1
     908:	30 40       	sbci	r19, 0x00	; 0
     90a:	32 97       	sbiw	r30, 0x02	; 2
     90c:	68 17       	cp	r22, r24
     90e:	79 07       	cpc	r23, r25
     910:	f9 f0       	breq	.+62     	; 0x950 <left+0x92>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
     912:	37 ff       	sbrs	r19, 7
     914:	f6 cf       	rjmp	.-20     	; 0x902 <left+0x44>
     916:	13 c0       	rjmp	.+38     	; 0x93e <left+0x80>
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
	     return;
     p->top++;
     918:	31 96       	adiw	r30, 0x01	; 1
     91a:	d8 01       	movw	r26, r16
     91c:	dd 96       	adiw	r26, 0x3d	; 61
     91e:	fc 93       	st	X, r31
     920:	ee 93       	st	-X, r30
     922:	dc 97       	sbiw	r26, 0x3c	; 60
     p->a[p->top]=n;
     924:	ee 0f       	add	r30, r30
     926:	ff 1f       	adc	r31, r31
     928:	e0 0f       	add	r30, r16
     92a:	f1 1f       	adc	r31, r17
     92c:	71 83       	std	Z+1, r23	; 0x01
     92e:	60 83       	st	Z, r22
}
void left(stack *p,int n,int *d)
{ if(n!=0)
 	 if(pushcheck(*p,n))
 	 {
      push(p,n);*d=*d+1;
     930:	fa 01       	movw	r30, r20
     932:	80 81       	ld	r24, Z
     934:	91 81       	ldd	r25, Z+1	; 0x01
     936:	01 96       	adiw	r24, 0x01	; 1
     938:	91 83       	std	Z+1, r25	; 0x01
     93a:	80 83       	st	Z, r24
     93c:	09 c0       	rjmp	.+18     	; 0x950 <left+0x92>
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
     93e:	d8 01       	movw	r26, r16
     940:	dc 96       	adiw	r26, 0x3c	; 60
     942:	ed 91       	ld	r30, X+
     944:	fc 91       	ld	r31, X
     946:	dd 97       	sbiw	r26, 0x3d	; 61
     948:	ed 31       	cpi	r30, 0x1D	; 29
     94a:	f1 05       	cpc	r31, r1
     94c:	29 f7       	brne	.-54     	; 0x918 <left+0x5a>
     94e:	f0 cf       	rjmp	.-32     	; 0x930 <left+0x72>
{ if(n!=0)
 	 if(pushcheck(*p,n))
 	 {
      push(p,n);*d=*d+1;
     }
}
     950:	ee 96       	adiw	r28, 0x3e	; 62
     952:	0f b6       	in	r0, 0x3f	; 63
     954:	f8 94       	cli
     956:	de bf       	out	0x3e, r29	; 62
     958:	0f be       	out	0x3f, r0	; 63
     95a:	cd bf       	out	0x3d, r28	; 61
     95c:	cf 91       	pop	r28
     95e:	df 91       	pop	r29
     960:	1f 91       	pop	r17
     962:	0f 91       	pop	r16
     964:	08 95       	ret

00000966 <below>:
void below(stack *p,int n,int *d)
{ if(n!=0)
     966:	0f 93       	push	r16
     968:	1f 93       	push	r17
     96a:	df 93       	push	r29
     96c:	cf 93       	push	r28
     96e:	cd b7       	in	r28, 0x3d	; 61
     970:	de b7       	in	r29, 0x3e	; 62
     972:	ee 97       	sbiw	r28, 0x3e	; 62
     974:	0f b6       	in	r0, 0x3f	; 63
     976:	f8 94       	cli
     978:	de bf       	out	0x3e, r29	; 62
     97a:	0f be       	out	0x3f, r0	; 63
     97c:	cd bf       	out	0x3d, r28	; 61
     97e:	8c 01       	movw	r16, r24
     980:	61 15       	cp	r22, r1
     982:	71 05       	cpc	r23, r1
     984:	c9 f1       	breq	.+114    	; 0x9f8 <below+0x92>
   	 if(pushcheck(*p,n))
     986:	de 01       	movw	r26, r28
     988:	11 96       	adiw	r26, 0x01	; 1
     98a:	fc 01       	movw	r30, r24
     98c:	8e e3       	ldi	r24, 0x3E	; 62
     98e:	01 90       	ld	r0, Z+
     990:	0d 92       	st	X+, r0
     992:	81 50       	subi	r24, 0x01	; 1
     994:	e1 f7       	brne	.-8      	; 0x98e <below+0x28>
     996:	2d ad       	ldd	r18, Y+61	; 0x3d
     998:	3e ad       	ldd	r19, Y+62	; 0x3e
     99a:	c9 01       	movw	r24, r18
     99c:	88 0f       	add	r24, r24
     99e:	99 1f       	adc	r25, r25
     9a0:	fe 01       	movw	r30, r28
     9a2:	31 96       	adiw	r30, 0x01	; 1
     9a4:	e8 0f       	add	r30, r24
     9a6:	f9 1f       	adc	r31, r25
     9a8:	08 c0       	rjmp	.+16     	; 0x9ba <below+0x54>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
     9aa:	80 81       	ld	r24, Z
     9ac:	91 81       	ldd	r25, Z+1	; 0x01
     9ae:	21 50       	subi	r18, 0x01	; 1
     9b0:	30 40       	sbci	r19, 0x00	; 0
     9b2:	32 97       	sbiw	r30, 0x02	; 2
     9b4:	68 17       	cp	r22, r24
     9b6:	79 07       	cpc	r23, r25
     9b8:	f9 f0       	breq	.+62     	; 0x9f8 <below+0x92>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
     9ba:	37 ff       	sbrs	r19, 7
     9bc:	f6 cf       	rjmp	.-20     	; 0x9aa <below+0x44>
     9be:	13 c0       	rjmp	.+38     	; 0x9e6 <below+0x80>
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
	     return;
     p->top++;
     9c0:	31 96       	adiw	r30, 0x01	; 1
     9c2:	d8 01       	movw	r26, r16
     9c4:	dd 96       	adiw	r26, 0x3d	; 61
     9c6:	fc 93       	st	X, r31
     9c8:	ee 93       	st	-X, r30
     9ca:	dc 97       	sbiw	r26, 0x3c	; 60
     p->a[p->top]=n;
     9cc:	ee 0f       	add	r30, r30
     9ce:	ff 1f       	adc	r31, r31
     9d0:	e0 0f       	add	r30, r16
     9d2:	f1 1f       	adc	r31, r17
     9d4:	71 83       	std	Z+1, r23	; 0x01
     9d6:	60 83       	st	Z, r22
}
void below(stack *p,int n,int *d)
{ if(n!=0)
   	 if(pushcheck(*p,n))
     {
	   push(p,n);*d=*d+1;
     9d8:	fa 01       	movw	r30, r20
     9da:	80 81       	ld	r24, Z
     9dc:	91 81       	ldd	r25, Z+1	; 0x01
     9de:	01 96       	adiw	r24, 0x01	; 1
     9e0:	91 83       	std	Z+1, r25	; 0x01
     9e2:	80 83       	st	Z, r24
     9e4:	09 c0       	rjmp	.+18     	; 0x9f8 <below+0x92>
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
     9e6:	d8 01       	movw	r26, r16
     9e8:	dc 96       	adiw	r26, 0x3c	; 60
     9ea:	ed 91       	ld	r30, X+
     9ec:	fc 91       	ld	r31, X
     9ee:	dd 97       	sbiw	r26, 0x3d	; 61
     9f0:	ed 31       	cpi	r30, 0x1D	; 29
     9f2:	f1 05       	cpc	r31, r1
     9f4:	29 f7       	brne	.-54     	; 0x9c0 <below+0x5a>
     9f6:	f0 cf       	rjmp	.-32     	; 0x9d8 <below+0x72>
{ if(n!=0)
   	 if(pushcheck(*p,n))
     {
	   push(p,n);*d=*d+1;
     }  
}
     9f8:	ee 96       	adiw	r28, 0x3e	; 62
     9fa:	0f b6       	in	r0, 0x3f	; 63
     9fc:	f8 94       	cli
     9fe:	de bf       	out	0x3e, r29	; 62
     a00:	0f be       	out	0x3f, r0	; 63
     a02:	cd bf       	out	0x3d, r28	; 61
     a04:	cf 91       	pop	r28
     a06:	df 91       	pop	r29
     a08:	1f 91       	pop	r17
     a0a:	0f 91       	pop	r16
     a0c:	08 95       	ret

00000a0e <right>:
void right(stack *p,int n,int *d)
{ if(n!=0)
     a0e:	0f 93       	push	r16
     a10:	1f 93       	push	r17
     a12:	df 93       	push	r29
     a14:	cf 93       	push	r28
     a16:	cd b7       	in	r28, 0x3d	; 61
     a18:	de b7       	in	r29, 0x3e	; 62
     a1a:	ee 97       	sbiw	r28, 0x3e	; 62
     a1c:	0f b6       	in	r0, 0x3f	; 63
     a1e:	f8 94       	cli
     a20:	de bf       	out	0x3e, r29	; 62
     a22:	0f be       	out	0x3f, r0	; 63
     a24:	cd bf       	out	0x3d, r28	; 61
     a26:	8c 01       	movw	r16, r24
     a28:	61 15       	cp	r22, r1
     a2a:	71 05       	cpc	r23, r1
     a2c:	c9 f1       	breq	.+114    	; 0xaa0 <right+0x92>
 	 if(pushcheck(*p,n))
     a2e:	de 01       	movw	r26, r28
     a30:	11 96       	adiw	r26, 0x01	; 1
     a32:	fc 01       	movw	r30, r24
     a34:	8e e3       	ldi	r24, 0x3E	; 62
     a36:	01 90       	ld	r0, Z+
     a38:	0d 92       	st	X+, r0
     a3a:	81 50       	subi	r24, 0x01	; 1
     a3c:	e1 f7       	brne	.-8      	; 0xa36 <right+0x28>
     a3e:	2d ad       	ldd	r18, Y+61	; 0x3d
     a40:	3e ad       	ldd	r19, Y+62	; 0x3e
     a42:	c9 01       	movw	r24, r18
     a44:	88 0f       	add	r24, r24
     a46:	99 1f       	adc	r25, r25
     a48:	fe 01       	movw	r30, r28
     a4a:	31 96       	adiw	r30, 0x01	; 1
     a4c:	e8 0f       	add	r30, r24
     a4e:	f9 1f       	adc	r31, r25
     a50:	08 c0       	rjmp	.+16     	; 0xa62 <right+0x54>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
     a52:	80 81       	ld	r24, Z
     a54:	91 81       	ldd	r25, Z+1	; 0x01
     a56:	21 50       	subi	r18, 0x01	; 1
     a58:	30 40       	sbci	r19, 0x00	; 0
     a5a:	32 97       	sbiw	r30, 0x02	; 2
     a5c:	68 17       	cp	r22, r24
     a5e:	79 07       	cpc	r23, r25
     a60:	f9 f0       	breq	.+62     	; 0xaa0 <right+0x92>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
     a62:	37 ff       	sbrs	r19, 7
     a64:	f6 cf       	rjmp	.-20     	; 0xa52 <right+0x44>
     a66:	13 c0       	rjmp	.+38     	; 0xa8e <right+0x80>
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
	     return;
     p->top++;
     a68:	31 96       	adiw	r30, 0x01	; 1
     a6a:	d8 01       	movw	r26, r16
     a6c:	dd 96       	adiw	r26, 0x3d	; 61
     a6e:	fc 93       	st	X, r31
     a70:	ee 93       	st	-X, r30
     a72:	dc 97       	sbiw	r26, 0x3c	; 60
     p->a[p->top]=n;
     a74:	ee 0f       	add	r30, r30
     a76:	ff 1f       	adc	r31, r31
     a78:	e0 0f       	add	r30, r16
     a7a:	f1 1f       	adc	r31, r17
     a7c:	71 83       	std	Z+1, r23	; 0x01
     a7e:	60 83       	st	Z, r22
}
void right(stack *p,int n,int *d)
{ if(n!=0)
 	 if(pushcheck(*p,n))
 	 {
         push(p,n);*d=*d+1;
     a80:	fa 01       	movw	r30, r20
     a82:	80 81       	ld	r24, Z
     a84:	91 81       	ldd	r25, Z+1	; 0x01
     a86:	01 96       	adiw	r24, 0x01	; 1
     a88:	91 83       	std	Z+1, r25	; 0x01
     a8a:	80 83       	st	Z, r24
     a8c:	09 c0       	rjmp	.+18     	; 0xaa0 <right+0x92>
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
     a8e:	d8 01       	movw	r26, r16
     a90:	dc 96       	adiw	r26, 0x3c	; 60
     a92:	ed 91       	ld	r30, X+
     a94:	fc 91       	ld	r31, X
     a96:	dd 97       	sbiw	r26, 0x3d	; 61
     a98:	ed 31       	cpi	r30, 0x1D	; 29
     a9a:	f1 05       	cpc	r31, r1
     a9c:	29 f7       	brne	.-54     	; 0xa68 <right+0x5a>
     a9e:	f0 cf       	rjmp	.-32     	; 0xa80 <right+0x72>
{ if(n!=0)
 	 if(pushcheck(*p,n))
 	 {
         push(p,n);*d=*d+1;
     }
}
     aa0:	ee 96       	adiw	r28, 0x3e	; 62
     aa2:	0f b6       	in	r0, 0x3f	; 63
     aa4:	f8 94       	cli
     aa6:	de bf       	out	0x3e, r29	; 62
     aa8:	0f be       	out	0x3f, r0	; 63
     aaa:	cd bf       	out	0x3d, r28	; 61
     aac:	cf 91       	pop	r28
     aae:	df 91       	pop	r29
     ab0:	1f 91       	pop	r17
     ab2:	0f 91       	pop	r16
     ab4:	08 95       	ret

00000ab6 <up>:
void up(stack *p,int n,int *d)
{ if(n!=0)
     ab6:	0f 93       	push	r16
     ab8:	1f 93       	push	r17
     aba:	df 93       	push	r29
     abc:	cf 93       	push	r28
     abe:	cd b7       	in	r28, 0x3d	; 61
     ac0:	de b7       	in	r29, 0x3e	; 62
     ac2:	ee 97       	sbiw	r28, 0x3e	; 62
     ac4:	0f b6       	in	r0, 0x3f	; 63
     ac6:	f8 94       	cli
     ac8:	de bf       	out	0x3e, r29	; 62
     aca:	0f be       	out	0x3f, r0	; 63
     acc:	cd bf       	out	0x3d, r28	; 61
     ace:	8c 01       	movw	r16, r24
     ad0:	61 15       	cp	r22, r1
     ad2:	71 05       	cpc	r23, r1
     ad4:	c9 f1       	breq	.+114    	; 0xb48 <up+0x92>
 	 if(pushcheck(*p,n))
     ad6:	de 01       	movw	r26, r28
     ad8:	11 96       	adiw	r26, 0x01	; 1
     ada:	fc 01       	movw	r30, r24
     adc:	8e e3       	ldi	r24, 0x3E	; 62
     ade:	01 90       	ld	r0, Z+
     ae0:	0d 92       	st	X+, r0
     ae2:	81 50       	subi	r24, 0x01	; 1
     ae4:	e1 f7       	brne	.-8      	; 0xade <up+0x28>
     ae6:	2d ad       	ldd	r18, Y+61	; 0x3d
     ae8:	3e ad       	ldd	r19, Y+62	; 0x3e
     aea:	c9 01       	movw	r24, r18
     aec:	88 0f       	add	r24, r24
     aee:	99 1f       	adc	r25, r25
     af0:	fe 01       	movw	r30, r28
     af2:	31 96       	adiw	r30, 0x01	; 1
     af4:	e8 0f       	add	r30, r24
     af6:	f9 1f       	adc	r31, r25
     af8:	08 c0       	rjmp	.+16     	; 0xb0a <up+0x54>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
     afa:	80 81       	ld	r24, Z
     afc:	91 81       	ldd	r25, Z+1	; 0x01
     afe:	21 50       	subi	r18, 0x01	; 1
     b00:	30 40       	sbci	r19, 0x00	; 0
     b02:	32 97       	sbiw	r30, 0x02	; 2
     b04:	68 17       	cp	r22, r24
     b06:	79 07       	cpc	r23, r25
     b08:	f9 f0       	breq	.+62     	; 0xb48 <up+0x92>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
     b0a:	37 ff       	sbrs	r19, 7
     b0c:	f6 cf       	rjmp	.-20     	; 0xafa <up+0x44>
     b0e:	13 c0       	rjmp	.+38     	; 0xb36 <up+0x80>
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
	     return;
     p->top++;
     b10:	31 96       	adiw	r30, 0x01	; 1
     b12:	d8 01       	movw	r26, r16
     b14:	dd 96       	adiw	r26, 0x3d	; 61
     b16:	fc 93       	st	X, r31
     b18:	ee 93       	st	-X, r30
     b1a:	dc 97       	sbiw	r26, 0x3c	; 60
     p->a[p->top]=n;
     b1c:	ee 0f       	add	r30, r30
     b1e:	ff 1f       	adc	r31, r31
     b20:	e0 0f       	add	r30, r16
     b22:	f1 1f       	adc	r31, r17
     b24:	71 83       	std	Z+1, r23	; 0x01
     b26:	60 83       	st	Z, r22
}
void up(stack *p,int n,int *d)
{ if(n!=0)
 	 if(pushcheck(*p,n))
 	 {
         push(p,n);*d=*d+1;
     b28:	fa 01       	movw	r30, r20
     b2a:	80 81       	ld	r24, Z
     b2c:	91 81       	ldd	r25, Z+1	; 0x01
     b2e:	01 96       	adiw	r24, 0x01	; 1
     b30:	91 83       	std	Z+1, r25	; 0x01
     b32:	80 83       	st	Z, r24
     b34:	09 c0       	rjmp	.+18     	; 0xb48 <up+0x92>
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
     b36:	d8 01       	movw	r26, r16
     b38:	dc 96       	adiw	r26, 0x3c	; 60
     b3a:	ed 91       	ld	r30, X+
     b3c:	fc 91       	ld	r31, X
     b3e:	dd 97       	sbiw	r26, 0x3d	; 61
     b40:	ed 31       	cpi	r30, 0x1D	; 29
     b42:	f1 05       	cpc	r31, r1
     b44:	29 f7       	brne	.-54     	; 0xb10 <up+0x5a>
     b46:	f0 cf       	rjmp	.-32     	; 0xb28 <up+0x72>
{ if(n!=0)
 	 if(pushcheck(*p,n))
 	 {
         push(p,n);*d=*d+1;
     }
}
     b48:	ee 96       	adiw	r28, 0x3e	; 62
     b4a:	0f b6       	in	r0, 0x3f	; 63
     b4c:	f8 94       	cli
     b4e:	de bf       	out	0x3e, r29	; 62
     b50:	0f be       	out	0x3f, r0	; 63
     b52:	cd bf       	out	0x3d, r28	; 61
     b54:	cf 91       	pop	r28
     b56:	df 91       	pop	r29
     b58:	1f 91       	pop	r17
     b5a:	0f 91       	pop	r16
     b5c:	08 95       	ret

00000b5e <checkarray>:
int checkarray(int n,int p[][4])
{  int i,j;
     b5e:	dc 01       	movw	r26, r24
     b60:	9b 01       	movw	r18, r22
     b62:	40 e0       	ldi	r20, 0x00	; 0
     b64:	50 e0       	ldi	r21, 0x00	; 0
     b66:	20 c0       	rjmp	.+64     	; 0xba8 <checkarray+0x4a>
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
     b68:	80 81       	ld	r24, Z
     b6a:	91 81       	ldd	r25, Z+1	; 0x01
     b6c:	a8 17       	cp	r26, r24
     b6e:	b9 07       	cpc	r27, r25
     b70:	71 f4       	brne	.+28     	; 0xb8e <checkarray+0x30>
     b72:	9a 01       	movw	r18, r20
     b74:	a3 e0       	ldi	r26, 0x03	; 3
     b76:	22 0f       	add	r18, r18
     b78:	33 1f       	adc	r19, r19
     b7a:	aa 95       	dec	r26
     b7c:	e1 f7       	brne	.-8      	; 0xb76 <checkarray+0x18>
     b7e:	44 0f       	add	r20, r20
     b80:	55 1f       	adc	r21, r21
     b82:	24 0f       	add	r18, r20
     b84:	35 1f       	adc	r19, r21
     b86:	26 0f       	add	r18, r22
     b88:	37 1f       	adc	r19, r23
  				        { return 10*i+j;}
			 }
	 }
}
     b8a:	c9 01       	movw	r24, r18
     b8c:	08 95       	ret
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
     b8e:	6f 5f       	subi	r22, 0xFF	; 255
     b90:	7f 4f       	sbci	r23, 0xFF	; 255
     b92:	32 96       	adiw	r30, 0x02	; 2
     b94:	64 30       	cpi	r22, 0x04	; 4
     b96:	71 05       	cpc	r23, r1
     b98:	39 f7       	brne	.-50     	; 0xb68 <checkarray+0xa>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
     b9a:	4f 5f       	subi	r20, 0xFF	; 255
     b9c:	5f 4f       	sbci	r21, 0xFF	; 255
     b9e:	28 5f       	subi	r18, 0xF8	; 248
     ba0:	3f 4f       	sbci	r19, 0xFF	; 255
     ba2:	44 30       	cpi	r20, 0x04	; 4
     ba4:	51 05       	cpc	r21, r1
     ba6:	21 f0       	breq	.+8      	; 0xbb0 <checkarray+0x52>
     ba8:	f9 01       	movw	r30, r18
     baa:	60 e0       	ldi	r22, 0x00	; 0
     bac:	70 e0       	ldi	r23, 0x00	; 0
     bae:	dc cf       	rjmp	.-72     	; 0xb68 <checkarray+0xa>
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
  				        { return 10*i+j;}
			 }
	 }
}
     bb0:	08 95       	ret

00000bb2 <go>:
void go(int start,int stop)
{
     bb2:	0f 93       	push	r16
     bb4:	1f 93       	push	r17
     bb6:	cf 93       	push	r28
     bb8:	df 93       	push	r29
     bba:	9c 01       	movw	r18, r24
     bbc:	8b 01       	movw	r16, r22
	int i;
	xx1=start/10;
     bbe:	6a e0       	ldi	r22, 0x0A	; 10
     bc0:	70 e0       	ldi	r23, 0x00	; 0
     bc2:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
     bc6:	70 93 01 01 	sts	0x0101, r23
     bca:	60 93 00 01 	sts	0x0100, r22
	yy1=start%10;
     bce:	c9 01       	movw	r24, r18
     bd0:	6a e0       	ldi	r22, 0x0A	; 10
     bd2:	70 e0       	ldi	r23, 0x00	; 0
     bd4:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
     bd8:	fc 01       	movw	r30, r24
     bda:	90 93 ff 00 	sts	0x00FF, r25
     bde:	80 93 fe 00 	sts	0x00FE, r24
	xx2=stop/10;
     be2:	c8 01       	movw	r24, r16
     be4:	6a e0       	ldi	r22, 0x0A	; 10
     be6:	70 e0       	ldi	r23, 0x00	; 0
     be8:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
     bec:	70 93 fd 00 	sts	0x00FD, r23
     bf0:	60 93 fc 00 	sts	0x00FC, r22
	yy2=stop%10;
     bf4:	c8 01       	movw	r24, r16
     bf6:	6a e0       	ldi	r22, 0x0A	; 10
     bf8:	70 e0       	ldi	r23, 0x00	; 0
     bfa:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
     bfe:	9c 01       	movw	r18, r24
     c00:	90 93 09 01 	sts	0x0109, r25
     c04:	80 93 08 01 	sts	0x0108, r24
	                                         // y-cordinate solving
	 if((yy2-yy1>=1) && (dir==3))
     c08:	2e 1b       	sub	r18, r30
     c0a:	3f 0b       	sbc	r19, r31
     c0c:	12 16       	cp	r1, r18
     c0e:	13 06       	cpc	r1, r19
     c10:	0c f0       	brlt	.+2      	; 0xc14 <go+0x62>
     c12:	66 c0       	rjmp	.+204    	; 0xce0 <go+0x12e>
     c14:	80 91 e8 00 	lds	r24, 0x00E8
     c18:	90 91 e9 00 	lds	r25, 0x00E9
     c1c:	83 30       	cpi	r24, 0x03	; 3
     c1e:	91 05       	cpc	r25, r1
     c20:	b1 f4       	brne	.+44     	; 0xc4e <go+0x9c>
	 {
	 turnright();
     c22:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
     c26:	c0 e0       	ldi	r28, 0x00	; 0
     c28:	d0 e0       	ldi	r29, 0x00	; 0
     c2a:	03 c0       	rjmp	.+6      	; 0xc32 <go+0x80>
	 for(i=0;i<yy2-yy1;i++)
	 {
	 gridfollow();
     c2c:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	yy2=stop%10;
	                                         // y-cordinate solving
	 if((yy2-yy1>=1) && (dir==3))
	 {
	 turnright();
	 for(i=0;i<yy2-yy1;i++)
     c30:	21 96       	adiw	r28, 0x01	; 1
     c32:	80 91 08 01 	lds	r24, 0x0108
     c36:	90 91 09 01 	lds	r25, 0x0109
     c3a:	20 91 fe 00 	lds	r18, 0x00FE
     c3e:	30 91 ff 00 	lds	r19, 0x00FF
     c42:	82 1b       	sub	r24, r18
     c44:	93 0b       	sbc	r25, r19
     c46:	c8 17       	cp	r28, r24
     c48:	d9 07       	cpc	r29, r25
     c4a:	84 f3       	brlt	.-32     	; 0xc2c <go+0x7a>
     c4c:	b0 c0       	rjmp	.+352    	; 0xdae <go+0x1fc>
	 {
	 gridfollow();
	 }
	 }
	 else if((yy2-yy1>=1) && (dir==1))
     c4e:	81 30       	cpi	r24, 0x01	; 1
     c50:	91 05       	cpc	r25, r1
     c52:	b1 f4       	brne	.+44     	; 0xc80 <go+0xce>
	 {
	 turnleft();	
     c54:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
     c58:	c0 e0       	ldi	r28, 0x00	; 0
     c5a:	d0 e0       	ldi	r29, 0x00	; 0
     c5c:	03 c0       	rjmp	.+6      	; 0xc64 <go+0xb2>
	 for(i=0;i<yy2-yy1;i++)
	 {
	 gridfollow();
     c5e:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((yy2-yy1>=1) && (dir==1))
	 {
	 turnleft();	
	 for(i=0;i<yy2-yy1;i++)
     c62:	21 96       	adiw	r28, 0x01	; 1
     c64:	80 91 08 01 	lds	r24, 0x0108
     c68:	90 91 09 01 	lds	r25, 0x0109
     c6c:	20 91 fe 00 	lds	r18, 0x00FE
     c70:	30 91 ff 00 	lds	r19, 0x00FF
     c74:	82 1b       	sub	r24, r18
     c76:	93 0b       	sbc	r25, r19
     c78:	c8 17       	cp	r28, r24
     c7a:	d9 07       	cpc	r29, r25
     c7c:	84 f3       	brlt	.-32     	; 0xc5e <go+0xac>
     c7e:	97 c0       	rjmp	.+302    	; 0xdae <go+0x1fc>
	 {
	 gridfollow();
	 }
	 }
	 else if((yy2-yy1>=1) && (dir==4))
     c80:	84 30       	cpi	r24, 0x04	; 4
     c82:	91 05       	cpc	r25, r1
     c84:	b1 f4       	brne	.+44     	; 0xcb2 <go+0x100>
	 {
	 aboutturn();	
     c86:	0e 94 bd 00 	call	0x17a	; 0x17a <aboutturn>
     c8a:	c0 e0       	ldi	r28, 0x00	; 0
     c8c:	d0 e0       	ldi	r29, 0x00	; 0
     c8e:	03 c0       	rjmp	.+6      	; 0xc96 <go+0xe4>
	 for(i=0;i<yy2-yy1;i++)
	 {
	 gridfollow();
     c90:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((yy2-yy1>=1) && (dir==4))
	 {
	 aboutturn();	
	 for(i=0;i<yy2-yy1;i++)
     c94:	21 96       	adiw	r28, 0x01	; 1
     c96:	80 91 08 01 	lds	r24, 0x0108
     c9a:	90 91 09 01 	lds	r25, 0x0109
     c9e:	20 91 fe 00 	lds	r18, 0x00FE
     ca2:	30 91 ff 00 	lds	r19, 0x00FF
     ca6:	82 1b       	sub	r24, r18
     ca8:	93 0b       	sbc	r25, r19
     caa:	c8 17       	cp	r28, r24
     cac:	d9 07       	cpc	r29, r25
     cae:	84 f3       	brlt	.-32     	; 0xc90 <go+0xde>
     cb0:	7e c0       	rjmp	.+252    	; 0xdae <go+0x1fc>
	 {
	 gridfollow();
	 }
	 }
	 else if((yy2-yy1>=1) && (dir==2))
     cb2:	02 97       	sbiw	r24, 0x02	; 2
     cb4:	09 f0       	breq	.+2      	; 0xcb8 <go+0x106>
     cb6:	7b c0       	rjmp	.+246    	; 0xdae <go+0x1fc>
     cb8:	c0 e0       	ldi	r28, 0x00	; 0
     cba:	d0 e0       	ldi	r29, 0x00	; 0
     cbc:	03 c0       	rjmp	.+6      	; 0xcc4 <go+0x112>
	 {	
	 for(i=0;i<yy2-yy1;i++)
	 {
	 gridfollow();
     cbe:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 gridfollow();
	 }
	 }
	 else if((yy2-yy1>=1) && (dir==2))
	 {	
	 for(i=0;i<yy2-yy1;i++)
     cc2:	21 96       	adiw	r28, 0x01	; 1
     cc4:	80 91 08 01 	lds	r24, 0x0108
     cc8:	90 91 09 01 	lds	r25, 0x0109
     ccc:	20 91 fe 00 	lds	r18, 0x00FE
     cd0:	30 91 ff 00 	lds	r19, 0x00FF
     cd4:	82 1b       	sub	r24, r18
     cd6:	93 0b       	sbc	r25, r19
     cd8:	c8 17       	cp	r28, r24
     cda:	d9 07       	cpc	r29, r25
     cdc:	84 f3       	brlt	.-32     	; 0xcbe <go+0x10c>
     cde:	67 c0       	rjmp	.+206    	; 0xdae <go+0x1fc>
	 {
	 gridfollow();
	 }
	 }
	 else if((yy2-yy1<=-1) && (dir==1))
     ce0:	23 2b       	or	r18, r19
     ce2:	09 f4       	brne	.+2      	; 0xce6 <go+0x134>
     ce4:	64 c0       	rjmp	.+200    	; 0xdae <go+0x1fc>
     ce6:	80 91 e8 00 	lds	r24, 0x00E8
     cea:	90 91 e9 00 	lds	r25, 0x00E9
     cee:	81 30       	cpi	r24, 0x01	; 1
     cf0:	91 05       	cpc	r25, r1
     cf2:	b1 f4       	brne	.+44     	; 0xd20 <go+0x16e>
	 {
	 turnright();
     cf4:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
     cf8:	c0 e0       	ldi	r28, 0x00	; 0
     cfa:	d0 e0       	ldi	r29, 0x00	; 0
     cfc:	03 c0       	rjmp	.+6      	; 0xd04 <go+0x152>
	 for(i=0;i<yy1-yy2;i++)
	 {
	 gridfollow();
     cfe:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((yy2-yy1<=-1) && (dir==1))
	 {
	 turnright();
	 for(i=0;i<yy1-yy2;i++)
     d02:	21 96       	adiw	r28, 0x01	; 1
     d04:	80 91 fe 00 	lds	r24, 0x00FE
     d08:	90 91 ff 00 	lds	r25, 0x00FF
     d0c:	20 91 08 01 	lds	r18, 0x0108
     d10:	30 91 09 01 	lds	r19, 0x0109
     d14:	82 1b       	sub	r24, r18
     d16:	93 0b       	sbc	r25, r19
     d18:	c8 17       	cp	r28, r24
     d1a:	d9 07       	cpc	r29, r25
     d1c:	84 f3       	brlt	.-32     	; 0xcfe <go+0x14c>
     d1e:	47 c0       	rjmp	.+142    	; 0xdae <go+0x1fc>
	 {
	 gridfollow();
	 }
	 }
	 else if((yy2-yy1<=-1) && (dir==3))
     d20:	83 30       	cpi	r24, 0x03	; 3
     d22:	91 05       	cpc	r25, r1
     d24:	b1 f4       	brne	.+44     	; 0xd52 <go+0x1a0>
	 {
	 turnleft();
     d26:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
     d2a:	c0 e0       	ldi	r28, 0x00	; 0
     d2c:	d0 e0       	ldi	r29, 0x00	; 0
     d2e:	03 c0       	rjmp	.+6      	; 0xd36 <go+0x184>
	 for(i=0;i<yy1-yy2;i++)
	 {
	 gridfollow();
     d30:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((yy2-yy1<=-1) && (dir==3))
	 {
	 turnleft();
	 for(i=0;i<yy1-yy2;i++)
     d34:	21 96       	adiw	r28, 0x01	; 1
     d36:	80 91 fe 00 	lds	r24, 0x00FE
     d3a:	90 91 ff 00 	lds	r25, 0x00FF
     d3e:	20 91 08 01 	lds	r18, 0x0108
     d42:	30 91 09 01 	lds	r19, 0x0109
     d46:	82 1b       	sub	r24, r18
     d48:	93 0b       	sbc	r25, r19
     d4a:	c8 17       	cp	r28, r24
     d4c:	d9 07       	cpc	r29, r25
     d4e:	84 f3       	brlt	.-32     	; 0xd30 <go+0x17e>
     d50:	2e c0       	rjmp	.+92     	; 0xdae <go+0x1fc>
	 {
	 gridfollow();
	 } 
	 }
	 else if((yy2-yy1<=-1) && (dir==4))
     d52:	84 30       	cpi	r24, 0x04	; 4
     d54:	91 05       	cpc	r25, r1
     d56:	a1 f4       	brne	.+40     	; 0xd80 <go+0x1ce>
     d58:	c0 e0       	ldi	r28, 0x00	; 0
     d5a:	d0 e0       	ldi	r29, 0x00	; 0
     d5c:	03 c0       	rjmp	.+6      	; 0xd64 <go+0x1b2>
	 {
	 for(i=0;i<yy1-yy2;i++)
	 {
	 gridfollow();
     d5e:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 gridfollow();
	 } 
	 }
	 else if((yy2-yy1<=-1) && (dir==4))
	 {
	 for(i=0;i<yy1-yy2;i++)
     d62:	21 96       	adiw	r28, 0x01	; 1
     d64:	80 91 fe 00 	lds	r24, 0x00FE
     d68:	90 91 ff 00 	lds	r25, 0x00FF
     d6c:	20 91 08 01 	lds	r18, 0x0108
     d70:	30 91 09 01 	lds	r19, 0x0109
     d74:	82 1b       	sub	r24, r18
     d76:	93 0b       	sbc	r25, r19
     d78:	c8 17       	cp	r28, r24
     d7a:	d9 07       	cpc	r29, r25
     d7c:	84 f3       	brlt	.-32     	; 0xd5e <go+0x1ac>
     d7e:	17 c0       	rjmp	.+46     	; 0xdae <go+0x1fc>
	 {
	 gridfollow();
	 }
	 }
	 else if((yy2-yy1<=-1) && (dir==2))
     d80:	02 97       	sbiw	r24, 0x02	; 2
     d82:	a9 f4       	brne	.+42     	; 0xdae <go+0x1fc>
	 {
	 aboutturn();	
     d84:	0e 94 bd 00 	call	0x17a	; 0x17a <aboutturn>
     d88:	c0 e0       	ldi	r28, 0x00	; 0
     d8a:	d0 e0       	ldi	r29, 0x00	; 0
     d8c:	03 c0       	rjmp	.+6      	; 0xd94 <go+0x1e2>
	 for(i=0;i<yy1-yy2;i++)
	 {
	 gridfollow();
     d8e:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((yy2-yy1<=-1) && (dir==2))
	 {
	 aboutturn();	
	 for(i=0;i<yy1-yy2;i++)
     d92:	21 96       	adiw	r28, 0x01	; 1
     d94:	80 91 fe 00 	lds	r24, 0x00FE
     d98:	90 91 ff 00 	lds	r25, 0x00FF
     d9c:	20 91 08 01 	lds	r18, 0x0108
     da0:	30 91 09 01 	lds	r19, 0x0109
     da4:	82 1b       	sub	r24, r18
     da6:	93 0b       	sbc	r25, r19
     da8:	c8 17       	cp	r28, r24
     daa:	d9 07       	cpc	r29, r25
     dac:	84 f3       	brlt	.-32     	; 0xd8e <go+0x1dc>
	 {
	 gridfollow();
	 }
	 }
	                                         //x-cordinate solving...
	 if((xx2-xx1>=1) && (dir==3))
     dae:	20 91 fc 00 	lds	r18, 0x00FC
     db2:	30 91 fd 00 	lds	r19, 0x00FD
     db6:	80 91 00 01 	lds	r24, 0x0100
     dba:	90 91 01 01 	lds	r25, 0x0101
     dbe:	28 1b       	sub	r18, r24
     dc0:	39 0b       	sbc	r19, r25
     dc2:	12 16       	cp	r1, r18
     dc4:	13 06       	cpc	r1, r19
     dc6:	0c f0       	brlt	.+2      	; 0xdca <go+0x218>
     dc8:	66 c0       	rjmp	.+204    	; 0xe96 <go+0x2e4>
     dca:	80 91 e8 00 	lds	r24, 0x00E8
     dce:	90 91 e9 00 	lds	r25, 0x00E9
     dd2:	83 30       	cpi	r24, 0x03	; 3
     dd4:	91 05       	cpc	r25, r1
     dd6:	a1 f4       	brne	.+40     	; 0xe00 <go+0x24e>
     dd8:	c0 e0       	ldi	r28, 0x00	; 0
     dda:	d0 e0       	ldi	r29, 0x00	; 0
     ddc:	03 c0       	rjmp	.+6      	; 0xde4 <go+0x232>
	 {
	 for(i=0;i<xx2-xx1;i++)
	 {
	 gridfollow();
     dde:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	                                         //x-cordinate solving...
	 if((xx2-xx1>=1) && (dir==3))
	 {
	 for(i=0;i<xx2-xx1;i++)
     de2:	21 96       	adiw	r28, 0x01	; 1
     de4:	80 91 fc 00 	lds	r24, 0x00FC
     de8:	90 91 fd 00 	lds	r25, 0x00FD
     dec:	20 91 00 01 	lds	r18, 0x0100
     df0:	30 91 01 01 	lds	r19, 0x0101
     df4:	82 1b       	sub	r24, r18
     df6:	93 0b       	sbc	r25, r19
     df8:	c8 17       	cp	r28, r24
     dfa:	d9 07       	cpc	r29, r25
     dfc:	84 f3       	brlt	.-32     	; 0xdde <go+0x22c>
     dfe:	b2 c0       	rjmp	.+356    	; 0xf64 <go+0x3b2>
	 {
	 gridfollow();
	 }
	 }
	 else if((xx2-xx1>=1) && (dir==1))
     e00:	81 30       	cpi	r24, 0x01	; 1
     e02:	91 05       	cpc	r25, r1
     e04:	b1 f4       	brne	.+44     	; 0xe32 <go+0x280>
	 {
     aboutturn();
     e06:	0e 94 bd 00 	call	0x17a	; 0x17a <aboutturn>
     e0a:	c0 e0       	ldi	r28, 0x00	; 0
     e0c:	d0 e0       	ldi	r29, 0x00	; 0
     e0e:	03 c0       	rjmp	.+6      	; 0xe16 <go+0x264>
	 for(i=0;i<xx2-xx1;i++)
	 {
	 gridfollow();
     e10:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((xx2-xx1>=1) && (dir==1))
	 {
     aboutturn();
	 for(i=0;i<xx2-xx1;i++)
     e14:	21 96       	adiw	r28, 0x01	; 1
     e16:	80 91 fc 00 	lds	r24, 0x00FC
     e1a:	90 91 fd 00 	lds	r25, 0x00FD
     e1e:	20 91 00 01 	lds	r18, 0x0100
     e22:	30 91 01 01 	lds	r19, 0x0101
     e26:	82 1b       	sub	r24, r18
     e28:	93 0b       	sbc	r25, r19
     e2a:	c8 17       	cp	r28, r24
     e2c:	d9 07       	cpc	r29, r25
     e2e:	84 f3       	brlt	.-32     	; 0xe10 <go+0x25e>
     e30:	99 c0       	rjmp	.+306    	; 0xf64 <go+0x3b2>
	 {
	 gridfollow();
	 }
	 }
	 else if((xx2-xx1>=1) && (dir==4))
     e32:	84 30       	cpi	r24, 0x04	; 4
     e34:	91 05       	cpc	r25, r1
     e36:	b1 f4       	brne	.+44     	; 0xe64 <go+0x2b2>
	 {	
	 turnright();
     e38:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
     e3c:	c0 e0       	ldi	r28, 0x00	; 0
     e3e:	d0 e0       	ldi	r29, 0x00	; 0
     e40:	03 c0       	rjmp	.+6      	; 0xe48 <go+0x296>
	 for(i=0;i<xx2-xx1;i++)
	 {
	 gridfollow();
     e42:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((xx2-xx1>=1) && (dir==4))
	 {	
	 turnright();
	 for(i=0;i<xx2-xx1;i++)
     e46:	21 96       	adiw	r28, 0x01	; 1
     e48:	80 91 fc 00 	lds	r24, 0x00FC
     e4c:	90 91 fd 00 	lds	r25, 0x00FD
     e50:	20 91 00 01 	lds	r18, 0x0100
     e54:	30 91 01 01 	lds	r19, 0x0101
     e58:	82 1b       	sub	r24, r18
     e5a:	93 0b       	sbc	r25, r19
     e5c:	c8 17       	cp	r28, r24
     e5e:	d9 07       	cpc	r29, r25
     e60:	84 f3       	brlt	.-32     	; 0xe42 <go+0x290>
     e62:	80 c0       	rjmp	.+256    	; 0xf64 <go+0x3b2>
	 {
	 gridfollow();
	 }
	 }
	 else if((xx2-xx1>=1) && (dir==2))
     e64:	02 97       	sbiw	r24, 0x02	; 2
     e66:	09 f0       	breq	.+2      	; 0xe6a <go+0x2b8>
     e68:	7d c0       	rjmp	.+250    	; 0xf64 <go+0x3b2>
	 {
	 turnleft();	
     e6a:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
     e6e:	c0 e0       	ldi	r28, 0x00	; 0
     e70:	d0 e0       	ldi	r29, 0x00	; 0
     e72:	03 c0       	rjmp	.+6      	; 0xe7a <go+0x2c8>
	 for(i=0;i<xx2-xx1;i++)
	 {
	 gridfollow();
     e74:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((xx2-xx1>=1) && (dir==2))
	 {
	 turnleft();	
	 for(i=0;i<xx2-xx1;i++)
     e78:	21 96       	adiw	r28, 0x01	; 1
     e7a:	80 91 fc 00 	lds	r24, 0x00FC
     e7e:	90 91 fd 00 	lds	r25, 0x00FD
     e82:	20 91 00 01 	lds	r18, 0x0100
     e86:	30 91 01 01 	lds	r19, 0x0101
     e8a:	82 1b       	sub	r24, r18
     e8c:	93 0b       	sbc	r25, r19
     e8e:	c8 17       	cp	r28, r24
     e90:	d9 07       	cpc	r29, r25
     e92:	84 f3       	brlt	.-32     	; 0xe74 <go+0x2c2>
     e94:	67 c0       	rjmp	.+206    	; 0xf64 <go+0x3b2>
	 {
	 gridfollow();
	 }
	 }
	 else if((xx2-xx1<=-1) && (dir==3))
     e96:	23 2b       	or	r18, r19
     e98:	09 f4       	brne	.+2      	; 0xe9c <go+0x2ea>
     e9a:	64 c0       	rjmp	.+200    	; 0xf64 <go+0x3b2>
     e9c:	80 91 e8 00 	lds	r24, 0x00E8
     ea0:	90 91 e9 00 	lds	r25, 0x00E9
     ea4:	83 30       	cpi	r24, 0x03	; 3
     ea6:	91 05       	cpc	r25, r1
     ea8:	b1 f4       	brne	.+44     	; 0xed6 <go+0x324>
	 {
	 aboutturn();
     eaa:	0e 94 bd 00 	call	0x17a	; 0x17a <aboutturn>
     eae:	c0 e0       	ldi	r28, 0x00	; 0
     eb0:	d0 e0       	ldi	r29, 0x00	; 0
     eb2:	03 c0       	rjmp	.+6      	; 0xeba <go+0x308>
	 for(i=0;i<xx1-xx2;i++)
	 {
	 gridfollow();
     eb4:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((xx2-xx1<=-1) && (dir==3))
	 {
	 aboutturn();
	 for(i=0;i<xx1-xx2;i++)
     eb8:	21 96       	adiw	r28, 0x01	; 1
     eba:	80 91 00 01 	lds	r24, 0x0100
     ebe:	90 91 01 01 	lds	r25, 0x0101
     ec2:	20 91 fc 00 	lds	r18, 0x00FC
     ec6:	30 91 fd 00 	lds	r19, 0x00FD
     eca:	82 1b       	sub	r24, r18
     ecc:	93 0b       	sbc	r25, r19
     ece:	c8 17       	cp	r28, r24
     ed0:	d9 07       	cpc	r29, r25
     ed2:	84 f3       	brlt	.-32     	; 0xeb4 <go+0x302>
     ed4:	47 c0       	rjmp	.+142    	; 0xf64 <go+0x3b2>
	 {
	 gridfollow();
	 }
	 }
	 else if((xx2-xx1<=-1) && (dir==1))
     ed6:	81 30       	cpi	r24, 0x01	; 1
     ed8:	91 05       	cpc	r25, r1
     eda:	a1 f4       	brne	.+40     	; 0xf04 <go+0x352>
     edc:	c0 e0       	ldi	r28, 0x00	; 0
     ede:	d0 e0       	ldi	r29, 0x00	; 0
     ee0:	03 c0       	rjmp	.+6      	; 0xee8 <go+0x336>
	 {
	 for(i=0;i<xx1-xx2;i++)
	 {
	 gridfollow();
     ee2:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 gridfollow();
	 }
	 }
	 else if((xx2-xx1<=-1) && (dir==1))
	 {
	 for(i=0;i<xx1-xx2;i++)
     ee6:	21 96       	adiw	r28, 0x01	; 1
     ee8:	80 91 00 01 	lds	r24, 0x0100
     eec:	90 91 01 01 	lds	r25, 0x0101
     ef0:	20 91 fc 00 	lds	r18, 0x00FC
     ef4:	30 91 fd 00 	lds	r19, 0x00FD
     ef8:	82 1b       	sub	r24, r18
     efa:	93 0b       	sbc	r25, r19
     efc:	c8 17       	cp	r28, r24
     efe:	d9 07       	cpc	r29, r25
     f00:	84 f3       	brlt	.-32     	; 0xee2 <go+0x330>
     f02:	30 c0       	rjmp	.+96     	; 0xf64 <go+0x3b2>
	 {
	 gridfollow();
	 }
	 }
	 else if((xx2-xx1<=-1) && (dir==2))
     f04:	82 30       	cpi	r24, 0x02	; 2
     f06:	91 05       	cpc	r25, r1
     f08:	b1 f4       	brne	.+44     	; 0xf36 <go+0x384>
	 {
	 turnright();	
     f0a:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
     f0e:	c0 e0       	ldi	r28, 0x00	; 0
     f10:	d0 e0       	ldi	r29, 0x00	; 0
     f12:	03 c0       	rjmp	.+6      	; 0xf1a <go+0x368>
	 for(i=0;i<xx1-xx2;i++)
	 {
     gridfollow();
     f14:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((xx2-xx1<=-1) && (dir==2))
	 {
	 turnright();	
	 for(i=0;i<xx1-xx2;i++)
     f18:	21 96       	adiw	r28, 0x01	; 1
     f1a:	80 91 00 01 	lds	r24, 0x0100
     f1e:	90 91 01 01 	lds	r25, 0x0101
     f22:	20 91 fc 00 	lds	r18, 0x00FC
     f26:	30 91 fd 00 	lds	r19, 0x00FD
     f2a:	82 1b       	sub	r24, r18
     f2c:	93 0b       	sbc	r25, r19
     f2e:	c8 17       	cp	r28, r24
     f30:	d9 07       	cpc	r29, r25
     f32:	84 f3       	brlt	.-32     	; 0xf14 <go+0x362>
     f34:	17 c0       	rjmp	.+46     	; 0xf64 <go+0x3b2>
	 {
     gridfollow();
	 }
	 }
	 else if((xx2-xx1<=-1) && (dir==4))
     f36:	04 97       	sbiw	r24, 0x04	; 4
     f38:	a9 f4       	brne	.+42     	; 0xf64 <go+0x3b2>
	 {
	 turnleft();
     f3a:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
     f3e:	c0 e0       	ldi	r28, 0x00	; 0
     f40:	d0 e0       	ldi	r29, 0x00	; 0
     f42:	03 c0       	rjmp	.+6      	; 0xf4a <go+0x398>
	 for(i=0;i<xx1-xx2;i++)
	 {
	 gridfollow();
     f44:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 }
	 }
	 else if((xx2-xx1<=-1) && (dir==4))
	 {
	 turnleft();
	 for(i=0;i<xx1-xx2;i++)
     f48:	21 96       	adiw	r28, 0x01	; 1
     f4a:	80 91 00 01 	lds	r24, 0x0100
     f4e:	90 91 01 01 	lds	r25, 0x0101
     f52:	20 91 fc 00 	lds	r18, 0x00FC
     f56:	30 91 fd 00 	lds	r19, 0x00FD
     f5a:	82 1b       	sub	r24, r18
     f5c:	93 0b       	sbc	r25, r19
     f5e:	c8 17       	cp	r28, r24
     f60:	d9 07       	cpc	r29, r25
     f62:	84 f3       	brlt	.-32     	; 0xf44 <go+0x392>
	 {
	 gridfollow();
	 }
	 }
}
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	1f 91       	pop	r17
     f6a:	0f 91       	pop	r16
     f6c:	08 95       	ret

00000f6e <travel>:


void travel(stack path,int a[][4])
{
     f6e:	4f 92       	push	r4
     f70:	5f 92       	push	r5
     f72:	6f 92       	push	r6
     f74:	7f 92       	push	r7
     f76:	8f 92       	push	r8
     f78:	9f 92       	push	r9
     f7a:	af 92       	push	r10
     f7c:	bf 92       	push	r11
     f7e:	cf 92       	push	r12
     f80:	df 92       	push	r13
     f82:	ef 92       	push	r14
     f84:	ff 92       	push	r15
     f86:	0f 93       	push	r16
     f88:	1f 93       	push	r17
     f8a:	df 93       	push	r29
     f8c:	cf 93       	push	r28
     f8e:	cd b7       	in	r28, 0x3d	; 61
     f90:	de b7       	in	r29, 0x3e	; 62
     f92:	62 96       	adiw	r28, 0x12	; 18
     f94:	4f ac       	ldd	r4, Y+63	; 0x3f
     f96:	62 97       	sbiw	r28, 0x12	; 18
     f98:	63 96       	adiw	r28, 0x13	; 19
     f9a:	5f ac       	ldd	r5, Y+63	; 0x3f
     f9c:	63 97       	sbiw	r28, 0x13	; 19
     f9e:	61 96       	adiw	r28, 0x11	; 17
     fa0:	8e ad       	ldd	r24, Y+62	; 0x3e
     fa2:	9f ad       	ldd	r25, Y+63	; 0x3f
     fa4:	61 97       	sbiw	r28, 0x11	; 17
    int i,start,stop,t;
 	if(path.top==-1)  return ; 
     fa6:	2f ef       	ldi	r18, 0xFF	; 255
     fa8:	8f 3f       	cpi	r24, 0xFF	; 255
     faa:	92 07       	cpc	r25, r18
     fac:	09 f4       	brne	.+2      	; 0xfb0 <travel+0x42>
     fae:	98 c0       	rjmp	.+304    	; 0x10e0 <travel+0x172>
     fb0:	3c 01       	movw	r6, r24
     fb2:	8c 01       	movw	r16, r24
     fb4:	91 c0       	rjmp	.+290    	; 0x10d8 <travel+0x16a>
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
     fb6:	8f ef       	ldi	r24, 0xFF	; 255
     fb8:	0f 3f       	cpi	r16, 0xFF	; 255
     fba:	18 07       	cpc	r17, r24
     fbc:	19 f4       	brne	.+6      	; 0xfc4 <travel+0x56>
     fbe:	e0 e0       	ldi	r30, 0x00	; 0
     fc0:	f0 e0       	ldi	r31, 0x00	; 0
     fc2:	0e c0       	rjmp	.+28     	; 0xfe0 <travel+0x72>
 	     return 0;
     n=p->a[p->top];
     fc4:	f8 01       	movw	r30, r16
     fc6:	ee 0f       	add	r30, r30
     fc8:	ff 1f       	adc	r31, r31
     fca:	83 e1       	ldi	r24, 0x13	; 19
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	8c 0f       	add	r24, r28
     fd0:	9d 1f       	adc	r25, r29
     fd2:	e8 0f       	add	r30, r24
     fd4:	f9 1f       	adc	r31, r25
     fd6:	01 90       	ld	r0, Z+
     fd8:	f0 81       	ld	r31, Z
     fda:	e0 2d       	mov	r30, r0
     p->top--;
     fdc:	01 50       	subi	r16, 0x01	; 1
     fde:	10 40       	sbci	r17, 0x00	; 0
     fe0:	62 01       	movw	r12, r4
     fe2:	92 01       	movw	r18, r4
     fe4:	40 e0       	ldi	r20, 0x00	; 0
     fe6:	50 e0       	ldi	r21, 0x00	; 0
     fe8:	20 c0       	rjmp	.+64     	; 0x102a <travel+0xbc>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
     fea:	8d 91       	ld	r24, X+
     fec:	9c 91       	ld	r25, X
     fee:	11 97       	sbiw	r26, 0x01	; 1
     ff0:	e8 17       	cp	r30, r24
     ff2:	f9 07       	cpc	r31, r25
     ff4:	69 f4       	brne	.+26     	; 0x1010 <travel+0xa2>
  				        { return 10*i+j;}
     ff6:	4a 01       	movw	r8, r20
     ff8:	e3 e0       	ldi	r30, 0x03	; 3
     ffa:	88 0c       	add	r8, r8
     ffc:	99 1c       	adc	r9, r9
     ffe:	ea 95       	dec	r30
    1000:	e1 f7       	brne	.-8      	; 0xffa <travel+0x8c>
    1002:	44 0f       	add	r20, r20
    1004:	55 1f       	adc	r21, r21
    1006:	84 0e       	add	r8, r20
    1008:	95 1e       	adc	r9, r21
    100a:	86 0e       	add	r8, r22
    100c:	97 1e       	adc	r9, r23
    100e:	11 c0       	rjmp	.+34     	; 0x1032 <travel+0xc4>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    1010:	6f 5f       	subi	r22, 0xFF	; 255
    1012:	7f 4f       	sbci	r23, 0xFF	; 255
    1014:	12 96       	adiw	r26, 0x02	; 2
    1016:	64 30       	cpi	r22, 0x04	; 4
    1018:	71 05       	cpc	r23, r1
    101a:	39 f7       	brne	.-50     	; 0xfea <travel+0x7c>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    101c:	4f 5f       	subi	r20, 0xFF	; 255
    101e:	5f 4f       	sbci	r21, 0xFF	; 255
    1020:	28 5f       	subi	r18, 0xF8	; 248
    1022:	3f 4f       	sbci	r19, 0xFF	; 255
    1024:	44 30       	cpi	r20, 0x04	; 4
    1026:	51 05       	cpc	r21, r1
    1028:	21 f0       	breq	.+8      	; 0x1032 <travel+0xc4>
    102a:	d9 01       	movw	r26, r18
    102c:	60 e0       	ldi	r22, 0x00	; 0
    102e:	70 e0       	ldi	r23, 0x00	; 0
    1030:	dc cf       	rjmp	.-72     	; 0xfea <travel+0x7c>
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    1032:	9f ef       	ldi	r25, 0xFF	; 255
    1034:	0f 3f       	cpi	r16, 0xFF	; 255
    1036:	19 07       	cpc	r17, r25
    1038:	19 f4       	brne	.+6      	; 0x1040 <travel+0xd2>
    103a:	ee 24       	eor	r14, r14
    103c:	ff 24       	eor	r15, r15
    103e:	0d c0       	rjmp	.+26     	; 0x105a <travel+0xec>
 	     return 0;
     n=p->a[p->top];
    1040:	f8 01       	movw	r30, r16
    1042:	ee 0f       	add	r30, r30
    1044:	ff 1f       	adc	r31, r31
    1046:	83 e1       	ldi	r24, 0x13	; 19
    1048:	90 e0       	ldi	r25, 0x00	; 0
    104a:	8c 0f       	add	r24, r28
    104c:	9d 1f       	adc	r25, r29
    104e:	e8 0f       	add	r30, r24
    1050:	f9 1f       	adc	r31, r25
    1052:	e0 80       	ld	r14, Z
    1054:	f1 80       	ldd	r15, Z+1	; 0x01
     p->top--;
    1056:	01 50       	subi	r16, 0x01	; 1
    1058:	10 40       	sbci	r17, 0x00	; 0
    105a:	40 e0       	ldi	r20, 0x00	; 0
    105c:	50 e0       	ldi	r21, 0x00	; 0
    105e:	21 c0       	rjmp	.+66     	; 0x10a2 <travel+0x134>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1060:	80 81       	ld	r24, Z
    1062:	91 81       	ldd	r25, Z+1	; 0x01
    1064:	e8 16       	cp	r14, r24
    1066:	f9 06       	cpc	r15, r25
    1068:	69 f4       	brne	.+26     	; 0x1084 <travel+0x116>
  				        { return 10*i+j;}
    106a:	5a 01       	movw	r10, r20
    106c:	93 e0       	ldi	r25, 0x03	; 3
    106e:	aa 0c       	add	r10, r10
    1070:	bb 1c       	adc	r11, r11
    1072:	9a 95       	dec	r25
    1074:	e1 f7       	brne	.-8      	; 0x106e <travel+0x100>
    1076:	44 0f       	add	r20, r20
    1078:	55 1f       	adc	r21, r21
    107a:	a4 0e       	add	r10, r20
    107c:	b5 1e       	adc	r11, r21
    107e:	a6 0e       	add	r10, r22
    1080:	b7 1e       	adc	r11, r23
    1082:	13 c0       	rjmp	.+38     	; 0x10aa <travel+0x13c>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    1084:	6f 5f       	subi	r22, 0xFF	; 255
    1086:	7f 4f       	sbci	r23, 0xFF	; 255
    1088:	32 96       	adiw	r30, 0x02	; 2
    108a:	64 30       	cpi	r22, 0x04	; 4
    108c:	71 05       	cpc	r23, r1
    108e:	41 f7       	brne	.-48     	; 0x1060 <travel+0xf2>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    1090:	4f 5f       	subi	r20, 0xFF	; 255
    1092:	5f 4f       	sbci	r21, 0xFF	; 255
    1094:	88 e0       	ldi	r24, 0x08	; 8
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	c8 0e       	add	r12, r24
    109a:	d9 1e       	adc	r13, r25
    109c:	44 30       	cpi	r20, 0x04	; 4
    109e:	51 05       	cpc	r21, r1
    10a0:	21 f0       	breq	.+8      	; 0x10aa <travel+0x13c>
    10a2:	f6 01       	movw	r30, r12
    10a4:	60 e0       	ldi	r22, 0x00	; 0
    10a6:	70 e0       	ldi	r23, 0x00	; 0
    10a8:	db cf       	rjmp	.-74     	; 0x1060 <travel+0xf2>
    for(i=path.top;i>0;i--)
	{
	   start=checkarray(pop(&path),a);
	   t=pop(&path);
	   stop=checkarray(t,a);
	   go(start,stop);
    10aa:	c4 01       	movw	r24, r8
    10ac:	b5 01       	movw	r22, r10
    10ae:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <go>
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    10b2:	0d 31       	cpi	r16, 0x1D	; 29
    10b4:	11 05       	cpc	r17, r1
    10b6:	69 f0       	breq	.+26     	; 0x10d2 <travel+0x164>
	     return;
     p->top++;
    10b8:	0f 5f       	subi	r16, 0xFF	; 255
    10ba:	1f 4f       	sbci	r17, 0xFF	; 255
     p->a[p->top]=n;
    10bc:	f8 01       	movw	r30, r16
    10be:	ee 0f       	add	r30, r30
    10c0:	ff 1f       	adc	r31, r31
    10c2:	83 e1       	ldi	r24, 0x13	; 19
    10c4:	90 e0       	ldi	r25, 0x00	; 0
    10c6:	8c 0f       	add	r24, r28
    10c8:	9d 1f       	adc	r25, r29
    10ca:	e8 0f       	add	r30, r24
    10cc:	f9 1f       	adc	r31, r25
    10ce:	f1 82       	std	Z+1, r15	; 0x01
    10d0:	e0 82       	st	Z, r14

void travel(stack path,int a[][4])
{
    int i,start,stop,t;
 	if(path.top==-1)  return ; 
    for(i=path.top;i>0;i--)
    10d2:	08 94       	sec
    10d4:	61 08       	sbc	r6, r1
    10d6:	71 08       	sbc	r7, r1
    10d8:	16 14       	cp	r1, r6
    10da:	17 04       	cpc	r1, r7
    10dc:	0c f4       	brge	.+2      	; 0x10e0 <travel+0x172>
    10de:	6b cf       	rjmp	.-298    	; 0xfb6 <travel+0x48>
	   t=pop(&path);
	   stop=checkarray(t,a);
	   go(start,stop);
	   push(&path,t); 
	}
}
    10e0:	cf 91       	pop	r28
    10e2:	df 91       	pop	r29
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	ff 90       	pop	r15
    10ea:	ef 90       	pop	r14
    10ec:	df 90       	pop	r13
    10ee:	cf 90       	pop	r12
    10f0:	bf 90       	pop	r11
    10f2:	af 90       	pop	r10
    10f4:	9f 90       	pop	r9
    10f6:	8f 90       	pop	r8
    10f8:	7f 90       	pop	r7
    10fa:	6f 90       	pop	r6
    10fc:	5f 90       	pop	r5
    10fe:	4f 90       	pop	r4
    1100:	08 95       	ret

00001102 <checkpoint>:

int checkpoint(int a[][4],int p,int *d,stack t)
{
    1102:	cf 92       	push	r12
    1104:	df 92       	push	r13
    1106:	ef 92       	push	r14
    1108:	ff 92       	push	r15
    110a:	0f 93       	push	r16
    110c:	1f 93       	push	r17
    110e:	df 93       	push	r29
    1110:	cf 93       	push	r28
    1112:	cd b7       	in	r28, 0x3d	; 61
    1114:	de b7       	in	r29, 0x3e	; 62
    1116:	ee 97       	sbiw	r28, 0x3e	; 62
    1118:	0f b6       	in	r0, 0x3f	; 63
    111a:	f8 94       	cli
    111c:	de bf       	out	0x3e, r29	; 62
    111e:	0f be       	out	0x3f, r0	; 63
    1120:	cd bf       	out	0x3d, r28	; 61
    1122:	6c 01       	movw	r12, r24
    1124:	9b 01       	movw	r18, r22
    1126:	7a 01       	movw	r14, r20
 	int x=p/10;int y=p%10;
    1128:	cb 01       	movw	r24, r22
    112a:	6a e0       	ldi	r22, 0x0A	; 10
    112c:	70 e0       	ldi	r23, 0x00	; 0
    112e:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1132:	8b 01       	movw	r16, r22
    1134:	c9 01       	movw	r24, r18
    1136:	6a e0       	ldi	r22, 0x0A	; 10
    1138:	70 e0       	ldi	r23, 0x00	; 0
    113a:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    113e:	ac 01       	movw	r20, r24
             if(x+1<=3){if(a[x+1][y]!=0 && pushcheck(t,a[x+1][y]))        *d=*d+1;}
    1140:	03 30       	cpi	r16, 0x03	; 3
    1142:	11 05       	cpc	r17, r1
    1144:	94 f5       	brge	.+100    	; 0x11aa <checkpoint+0xa8>
    1146:	f8 01       	movw	r30, r16
    1148:	31 96       	adiw	r30, 0x01	; 1
    114a:	b3 e0       	ldi	r27, 0x03	; 3
    114c:	ee 0f       	add	r30, r30
    114e:	ff 1f       	adc	r31, r31
    1150:	ba 95       	dec	r27
    1152:	e1 f7       	brne	.-8      	; 0x114c <checkpoint+0x4a>
    1154:	ec 0d       	add	r30, r12
    1156:	fd 1d       	adc	r31, r13
    1158:	88 0f       	add	r24, r24
    115a:	99 1f       	adc	r25, r25
    115c:	e8 0f       	add	r30, r24
    115e:	f9 1f       	adc	r31, r25
    1160:	60 81       	ld	r22, Z
    1162:	71 81       	ldd	r23, Z+1	; 0x01
    1164:	61 15       	cp	r22, r1
    1166:	71 05       	cpc	r23, r1
    1168:	01 f1       	breq	.+64     	; 0x11aa <checkpoint+0xa8>
    116a:	fe 01       	movw	r30, r28
    116c:	31 96       	adiw	r30, 0x01	; 1
    116e:	de 01       	movw	r26, r28
    1170:	a7 5b       	subi	r26, 0xB7	; 183
    1172:	bf 4f       	sbci	r27, 0xFF	; 255
    1174:	8e e3       	ldi	r24, 0x3E	; 62
    1176:	0d 90       	ld	r0, X+
    1178:	01 92       	st	Z+, r0
    117a:	81 50       	subi	r24, 0x01	; 1
    117c:	e1 f7       	brne	.-8      	; 0x1176 <checkpoint+0x74>
    117e:	2d ad       	ldd	r18, Y+61	; 0x3d
    1180:	3e ad       	ldd	r19, Y+62	; 0x3e
    1182:	c9 01       	movw	r24, r18
    1184:	88 0f       	add	r24, r24
    1186:	99 1f       	adc	r25, r25
    1188:	de 01       	movw	r26, r28
    118a:	11 96       	adiw	r26, 0x01	; 1
    118c:	a8 0f       	add	r26, r24
    118e:	b9 1f       	adc	r27, r25
    1190:	09 c0       	rjmp	.+18     	; 0x11a4 <checkpoint+0xa2>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
    1192:	8d 91       	ld	r24, X+
    1194:	9c 91       	ld	r25, X
    1196:	11 97       	sbiw	r26, 0x01	; 1
    1198:	21 50       	subi	r18, 0x01	; 1
    119a:	30 40       	sbci	r19, 0x00	; 0
    119c:	12 97       	sbiw	r26, 0x02	; 2
    119e:	68 17       	cp	r22, r24
    11a0:	79 07       	cpc	r23, r25
    11a2:	19 f0       	breq	.+6      	; 0x11aa <checkpoint+0xa8>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
    11a4:	37 ff       	sbrs	r19, 7
    11a6:	f5 cf       	rjmp	.-22     	; 0x1192 <checkpoint+0x90>
    11a8:	b3 c0       	rjmp	.+358    	; 0x1310 <checkpoint+0x20e>

int checkpoint(int a[][4],int p,int *d,stack t)
{
 	int x=p/10;int y=p%10;
             if(x+1<=3){if(a[x+1][y]!=0 && pushcheck(t,a[x+1][y]))        *d=*d+1;}
             if(y+1<=3){if(a[x][y+1]!=0 && pushcheck(t,a[x][y+1]))        *d=*d+1;}
    11aa:	43 30       	cpi	r20, 0x03	; 3
    11ac:	51 05       	cpc	r21, r1
    11ae:	9c f5       	brge	.+102    	; 0x1216 <checkpoint+0x114>
    11b0:	f8 01       	movw	r30, r16
    11b2:	b3 e0       	ldi	r27, 0x03	; 3
    11b4:	ee 0f       	add	r30, r30
    11b6:	ff 1f       	adc	r31, r31
    11b8:	ba 95       	dec	r27
    11ba:	e1 f7       	brne	.-8      	; 0x11b4 <checkpoint+0xb2>
    11bc:	ec 0d       	add	r30, r12
    11be:	fd 1d       	adc	r31, r13
    11c0:	ca 01       	movw	r24, r20
    11c2:	01 96       	adiw	r24, 0x01	; 1
    11c4:	88 0f       	add	r24, r24
    11c6:	99 1f       	adc	r25, r25
    11c8:	e8 0f       	add	r30, r24
    11ca:	f9 1f       	adc	r31, r25
    11cc:	60 81       	ld	r22, Z
    11ce:	71 81       	ldd	r23, Z+1	; 0x01
    11d0:	61 15       	cp	r22, r1
    11d2:	71 05       	cpc	r23, r1
    11d4:	01 f1       	breq	.+64     	; 0x1216 <checkpoint+0x114>
    11d6:	fe 01       	movw	r30, r28
    11d8:	31 96       	adiw	r30, 0x01	; 1
    11da:	de 01       	movw	r26, r28
    11dc:	a7 5b       	subi	r26, 0xB7	; 183
    11de:	bf 4f       	sbci	r27, 0xFF	; 255
    11e0:	8e e3       	ldi	r24, 0x3E	; 62
    11e2:	0d 90       	ld	r0, X+
    11e4:	01 92       	st	Z+, r0
    11e6:	81 50       	subi	r24, 0x01	; 1
    11e8:	e1 f7       	brne	.-8      	; 0x11e2 <checkpoint+0xe0>
    11ea:	2d ad       	ldd	r18, Y+61	; 0x3d
    11ec:	3e ad       	ldd	r19, Y+62	; 0x3e
    11ee:	c9 01       	movw	r24, r18
    11f0:	88 0f       	add	r24, r24
    11f2:	99 1f       	adc	r25, r25
    11f4:	de 01       	movw	r26, r28
    11f6:	11 96       	adiw	r26, 0x01	; 1
    11f8:	a8 0f       	add	r26, r24
    11fa:	b9 1f       	adc	r27, r25
    11fc:	09 c0       	rjmp	.+18     	; 0x1210 <checkpoint+0x10e>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
    11fe:	8d 91       	ld	r24, X+
    1200:	9c 91       	ld	r25, X
    1202:	11 97       	sbiw	r26, 0x01	; 1
    1204:	21 50       	subi	r18, 0x01	; 1
    1206:	30 40       	sbci	r19, 0x00	; 0
    1208:	12 97       	sbiw	r26, 0x02	; 2
    120a:	68 17       	cp	r22, r24
    120c:	79 07       	cpc	r23, r25
    120e:	19 f0       	breq	.+6      	; 0x1216 <checkpoint+0x114>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
    1210:	37 ff       	sbrs	r19, 7
    1212:	f5 cf       	rjmp	.-22     	; 0x11fe <checkpoint+0xfc>
    1214:	84 c0       	rjmp	.+264    	; 0x131e <checkpoint+0x21c>
int checkpoint(int a[][4],int p,int *d,stack t)
{
 	int x=p/10;int y=p%10;
             if(x+1<=3){if(a[x+1][y]!=0 && pushcheck(t,a[x+1][y]))        *d=*d+1;}
             if(y+1<=3){if(a[x][y+1]!=0 && pushcheck(t,a[x][y+1]))        *d=*d+1;}
             if(x-1>=0){if(a[x-1][y]!=0 && pushcheck(t,a[x-1][y]))    	  *d=*d+1;}
    1216:	10 16       	cp	r1, r16
    1218:	11 06       	cpc	r1, r17
    121a:	9c f5       	brge	.+102    	; 0x1282 <checkpoint+0x180>
    121c:	f8 01       	movw	r30, r16
    121e:	31 97       	sbiw	r30, 0x01	; 1
    1220:	b3 e0       	ldi	r27, 0x03	; 3
    1222:	ee 0f       	add	r30, r30
    1224:	ff 1f       	adc	r31, r31
    1226:	ba 95       	dec	r27
    1228:	e1 f7       	brne	.-8      	; 0x1222 <checkpoint+0x120>
    122a:	ec 0d       	add	r30, r12
    122c:	fd 1d       	adc	r31, r13
    122e:	ca 01       	movw	r24, r20
    1230:	88 0f       	add	r24, r24
    1232:	99 1f       	adc	r25, r25
    1234:	e8 0f       	add	r30, r24
    1236:	f9 1f       	adc	r31, r25
    1238:	60 81       	ld	r22, Z
    123a:	71 81       	ldd	r23, Z+1	; 0x01
    123c:	61 15       	cp	r22, r1
    123e:	71 05       	cpc	r23, r1
    1240:	01 f1       	breq	.+64     	; 0x1282 <checkpoint+0x180>
    1242:	fe 01       	movw	r30, r28
    1244:	31 96       	adiw	r30, 0x01	; 1
    1246:	de 01       	movw	r26, r28
    1248:	a7 5b       	subi	r26, 0xB7	; 183
    124a:	bf 4f       	sbci	r27, 0xFF	; 255
    124c:	8e e3       	ldi	r24, 0x3E	; 62
    124e:	0d 90       	ld	r0, X+
    1250:	01 92       	st	Z+, r0
    1252:	81 50       	subi	r24, 0x01	; 1
    1254:	e1 f7       	brne	.-8      	; 0x124e <checkpoint+0x14c>
    1256:	2d ad       	ldd	r18, Y+61	; 0x3d
    1258:	3e ad       	ldd	r19, Y+62	; 0x3e
    125a:	c9 01       	movw	r24, r18
    125c:	88 0f       	add	r24, r24
    125e:	99 1f       	adc	r25, r25
    1260:	de 01       	movw	r26, r28
    1262:	11 96       	adiw	r26, 0x01	; 1
    1264:	a8 0f       	add	r26, r24
    1266:	b9 1f       	adc	r27, r25
    1268:	09 c0       	rjmp	.+18     	; 0x127c <checkpoint+0x17a>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
    126a:	8d 91       	ld	r24, X+
    126c:	9c 91       	ld	r25, X
    126e:	11 97       	sbiw	r26, 0x01	; 1
    1270:	21 50       	subi	r18, 0x01	; 1
    1272:	30 40       	sbci	r19, 0x00	; 0
    1274:	12 97       	sbiw	r26, 0x02	; 2
    1276:	68 17       	cp	r22, r24
    1278:	79 07       	cpc	r23, r25
    127a:	19 f0       	breq	.+6      	; 0x1282 <checkpoint+0x180>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
    127c:	37 ff       	sbrs	r19, 7
    127e:	f5 cf       	rjmp	.-22     	; 0x126a <checkpoint+0x168>
    1280:	55 c0       	rjmp	.+170    	; 0x132c <checkpoint+0x22a>
{
 	int x=p/10;int y=p%10;
             if(x+1<=3){if(a[x+1][y]!=0 && pushcheck(t,a[x+1][y]))        *d=*d+1;}
             if(y+1<=3){if(a[x][y+1]!=0 && pushcheck(t,a[x][y+1]))        *d=*d+1;}
             if(x-1>=0){if(a[x-1][y]!=0 && pushcheck(t,a[x-1][y]))    	  *d=*d+1;}
		     if(y-1>=0){if(a[x][y-1]!=0 && pushcheck(t,a[x][y-1]))        *d=*d+1;}
    1282:	14 16       	cp	r1, r20
    1284:	15 06       	cpc	r1, r21
    1286:	94 f5       	brge	.+100    	; 0x12ec <checkpoint+0x1ea>
    1288:	93 e0       	ldi	r25, 0x03	; 3
    128a:	00 0f       	add	r16, r16
    128c:	11 1f       	adc	r17, r17
    128e:	9a 95       	dec	r25
    1290:	e1 f7       	brne	.-8      	; 0x128a <checkpoint+0x188>
    1292:	0c 0d       	add	r16, r12
    1294:	1d 1d       	adc	r17, r13
    1296:	41 50       	subi	r20, 0x01	; 1
    1298:	50 40       	sbci	r21, 0x00	; 0
    129a:	44 0f       	add	r20, r20
    129c:	55 1f       	adc	r21, r21
    129e:	40 0f       	add	r20, r16
    12a0:	51 1f       	adc	r21, r17
    12a2:	fa 01       	movw	r30, r20
    12a4:	40 81       	ld	r20, Z
    12a6:	51 81       	ldd	r21, Z+1	; 0x01
    12a8:	41 15       	cp	r20, r1
    12aa:	51 05       	cpc	r21, r1
    12ac:	f9 f0       	breq	.+62     	; 0x12ec <checkpoint+0x1ea>
    12ae:	de 01       	movw	r26, r28
    12b0:	11 96       	adiw	r26, 0x01	; 1
    12b2:	fe 01       	movw	r30, r28
    12b4:	e7 5b       	subi	r30, 0xB7	; 183
    12b6:	ff 4f       	sbci	r31, 0xFF	; 255
    12b8:	8e e3       	ldi	r24, 0x3E	; 62
    12ba:	01 90       	ld	r0, Z+
    12bc:	0d 92       	st	X+, r0
    12be:	81 50       	subi	r24, 0x01	; 1
    12c0:	e1 f7       	brne	.-8      	; 0x12ba <checkpoint+0x1b8>
    12c2:	2d ad       	ldd	r18, Y+61	; 0x3d
    12c4:	3e ad       	ldd	r19, Y+62	; 0x3e
    12c6:	c9 01       	movw	r24, r18
    12c8:	88 0f       	add	r24, r24
    12ca:	99 1f       	adc	r25, r25
    12cc:	fe 01       	movw	r30, r28
    12ce:	31 96       	adiw	r30, 0x01	; 1
    12d0:	e8 0f       	add	r30, r24
    12d2:	f9 1f       	adc	r31, r25
    12d4:	08 c0       	rjmp	.+16     	; 0x12e6 <checkpoint+0x1e4>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
    12d6:	80 81       	ld	r24, Z
    12d8:	91 81       	ldd	r25, Z+1	; 0x01
    12da:	21 50       	subi	r18, 0x01	; 1
    12dc:	30 40       	sbci	r19, 0x00	; 0
    12de:	32 97       	sbiw	r30, 0x02	; 2
    12e0:	48 17       	cp	r20, r24
    12e2:	59 07       	cpc	r21, r25
    12e4:	19 f0       	breq	.+6      	; 0x12ec <checkpoint+0x1ea>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
    12e6:	37 ff       	sbrs	r19, 7
    12e8:	f6 cf       	rjmp	.-20     	; 0x12d6 <checkpoint+0x1d4>
    12ea:	27 c0       	rjmp	.+78     	; 0x133a <checkpoint+0x238>
             if(x+1<=3){if(a[x+1][y]!=0 && pushcheck(t,a[x+1][y]))        *d=*d+1;}
             if(y+1<=3){if(a[x][y+1]!=0 && pushcheck(t,a[x][y+1]))        *d=*d+1;}
             if(x-1>=0){if(a[x-1][y]!=0 && pushcheck(t,a[x-1][y]))    	  *d=*d+1;}
		     if(y-1>=0){if(a[x][y-1]!=0 && pushcheck(t,a[x][y-1]))        *d=*d+1;}
 	return *d;
}
    12ec:	f7 01       	movw	r30, r14
    12ee:	80 81       	ld	r24, Z
    12f0:	91 81       	ldd	r25, Z+1	; 0x01
    12f2:	ee 96       	adiw	r28, 0x3e	; 62
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	de bf       	out	0x3e, r29	; 62
    12fa:	0f be       	out	0x3f, r0	; 63
    12fc:	cd bf       	out	0x3d, r28	; 61
    12fe:	cf 91       	pop	r28
    1300:	df 91       	pop	r29
    1302:	1f 91       	pop	r17
    1304:	0f 91       	pop	r16
    1306:	ff 90       	pop	r15
    1308:	ef 90       	pop	r14
    130a:	df 90       	pop	r13
    130c:	cf 90       	pop	r12
    130e:	08 95       	ret
}

int checkpoint(int a[][4],int p,int *d,stack t)
{
 	int x=p/10;int y=p%10;
             if(x+1<=3){if(a[x+1][y]!=0 && pushcheck(t,a[x+1][y]))        *d=*d+1;}
    1310:	f7 01       	movw	r30, r14
    1312:	80 81       	ld	r24, Z
    1314:	91 81       	ldd	r25, Z+1	; 0x01
    1316:	01 96       	adiw	r24, 0x01	; 1
    1318:	91 83       	std	Z+1, r25	; 0x01
    131a:	80 83       	st	Z, r24
    131c:	46 cf       	rjmp	.-372    	; 0x11aa <checkpoint+0xa8>
             if(y+1<=3){if(a[x][y+1]!=0 && pushcheck(t,a[x][y+1]))        *d=*d+1;}
    131e:	f7 01       	movw	r30, r14
    1320:	80 81       	ld	r24, Z
    1322:	91 81       	ldd	r25, Z+1	; 0x01
    1324:	01 96       	adiw	r24, 0x01	; 1
    1326:	91 83       	std	Z+1, r25	; 0x01
    1328:	80 83       	st	Z, r24
    132a:	75 cf       	rjmp	.-278    	; 0x1216 <checkpoint+0x114>
             if(x-1>=0){if(a[x-1][y]!=0 && pushcheck(t,a[x-1][y]))    	  *d=*d+1;}
    132c:	f7 01       	movw	r30, r14
    132e:	80 81       	ld	r24, Z
    1330:	91 81       	ldd	r25, Z+1	; 0x01
    1332:	01 96       	adiw	r24, 0x01	; 1
    1334:	91 83       	std	Z+1, r25	; 0x01
    1336:	80 83       	st	Z, r24
    1338:	a4 cf       	rjmp	.-184    	; 0x1282 <checkpoint+0x180>
		     if(y-1>=0){if(a[x][y-1]!=0 && pushcheck(t,a[x][y-1]))        *d=*d+1;}
    133a:	f7 01       	movw	r30, r14
    133c:	80 81       	ld	r24, Z
    133e:	91 81       	ldd	r25, Z+1	; 0x01
    1340:	01 96       	adiw	r24, 0x01	; 1
    1342:	91 83       	std	Z+1, r25	; 0x01
    1344:	80 83       	st	Z, r24
    1346:	d2 cf       	rjmp	.-92     	; 0x12ec <checkpoint+0x1ea>

00001348 <findshortpath_1>:
 	return *d;
}
void findshortpath_1(int a[][4])
{
    1348:	2f 92       	push	r2
    134a:	3f 92       	push	r3
    134c:	4f 92       	push	r4
    134e:	5f 92       	push	r5
    1350:	6f 92       	push	r6
    1352:	7f 92       	push	r7
    1354:	8f 92       	push	r8
    1356:	9f 92       	push	r9
    1358:	af 92       	push	r10
    135a:	bf 92       	push	r11
    135c:	cf 92       	push	r12
    135e:	df 92       	push	r13
    1360:	ef 92       	push	r14
    1362:	ff 92       	push	r15
    1364:	0f 93       	push	r16
    1366:	1f 93       	push	r17
    1368:	df 93       	push	r29
    136a:	cf 93       	push	r28
    136c:	cd b7       	in	r28, 0x3d	; 61
    136e:	de b7       	in	r29, 0x3e	; 62
    1370:	cc 59       	subi	r28, 0x9C	; 156
    1372:	d1 40       	sbci	r29, 0x01	; 1
    1374:	0f b6       	in	r0, 0x3f	; 63
    1376:	f8 94       	cli
    1378:	de bf       	out	0x3e, r29	; 62
    137a:	0f be       	out	0x3f, r0	; 63
    137c:	cd bf       	out	0x3d, r28	; 61
    137e:	7c 01       	movw	r14, r24
	stack s;stack t;stack path;int c[20];int k=0;int link[50]={0};int l;
    1380:	1a 82       	std	Y+2, r1	; 0x02
    1382:	19 82       	std	Y+1, r1	; 0x01
    1384:	de 01       	movw	r26, r28
    1386:	ab 5d       	subi	r26, 0xDB	; 219
    1388:	be 4f       	sbci	r27, 0xFE	; 254
    138a:	84 e6       	ldi	r24, 0x64	; 100
    138c:	fd 01       	movw	r30, r26
    138e:	11 92       	st	Z+, r1
    1390:	8a 95       	dec	r24
    1392:	e9 f7       	brne	.-6      	; 0x138e <findshortpath_1+0x46>
 	s.top=-1;t.top=-1;path.top=-1;int j=-1;int i,n,u,q,g,w=0,v;
    1394:	fe 01       	movw	r30, r28
    1396:	e7 59       	subi	r30, 0x97	; 151
    1398:	ff 4f       	sbci	r31, 0xFF	; 255
    139a:	8f ef       	ldi	r24, 0xFF	; 255
    139c:	9f ef       	ldi	r25, 0xFF	; 255
    139e:	91 83       	std	Z+1, r25	; 0x01
    13a0:	80 83       	st	Z, r24
    13a2:	1c 82       	std	Y+4, r1	; 0x04
    13a4:	1b 82       	std	Y+3, r1	; 0x03
    13a6:	c5 56       	subi	r28, 0x65	; 101
    13a8:	de 4f       	sbci	r29, 0xFE	; 254
    13aa:	99 83       	std	Y+1, r25	; 0x01
    13ac:	88 83       	st	Y, r24
    13ae:	cb 59       	subi	r28, 0x9B	; 155
    13b0:	d1 40       	sbci	r29, 0x01	; 1
 	while(x!=xx || y!=yy)
 	{if(a[x][y]!=0)
       {     if(pushcheck(s,a[x][y]))
    13b2:	87 ee       	ldi	r24, 0xE7	; 231
    13b4:	c8 2e       	mov	r12, r24
    13b6:	d1 2c       	mov	r13, r1
    13b8:	cc 0e       	add	r12, r28
    13ba:	dd 1e       	adc	r13, r29
    13bc:	0d e2       	ldi	r16, 0x2D	; 45
    13be:	20 2e       	mov	r2, r16
    13c0:	31 2c       	mov	r3, r1
    13c2:	2c 0e       	add	r2, r28
    13c4:	3d 1e       	adc	r3, r29
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    13c6:	4f 01       	movw	r8, r30
	     return;
     p->top++;
     p->a[p->top]=n;
    13c8:	5e 01       	movw	r10, r28
    13ca:	08 94       	sec
    13cc:	a1 1c       	adc	r10, r1
    13ce:	b1 1c       	adc	r11, r1
    13d0:	b8 c3       	rjmp	.+1904   	; 0x1b42 <findshortpath_1+0x7fa>
void findshortpath_1(int a[][4])
{
	stack s;stack t;stack path;int c[20];int k=0;int link[50]={0};int l;
 	s.top=-1;t.top=-1;path.top=-1;int j=-1;int i,n,u,q,g,w=0,v;
 	while(x!=xx || y!=yy)
 	{if(a[x][y]!=0)
    13d2:	13 e0       	ldi	r17, 0x03	; 3
    13d4:	66 0f       	add	r22, r22
    13d6:	77 1f       	adc	r23, r23
    13d8:	1a 95       	dec	r17
    13da:	e1 f7       	brne	.-8      	; 0x13d4 <findshortpath_1+0x8c>
    13dc:	6e 0d       	add	r22, r14
    13de:	7f 1d       	adc	r23, r15
    13e0:	40 91 f2 00 	lds	r20, 0x00F2
    13e4:	50 91 f3 00 	lds	r21, 0x00F3
    13e8:	fa 01       	movw	r30, r20
    13ea:	ee 0f       	add	r30, r30
    13ec:	ff 1f       	adc	r31, r31
    13ee:	e6 0f       	add	r30, r22
    13f0:	f7 1f       	adc	r31, r23
    13f2:	00 81       	ld	r16, Z
    13f4:	11 81       	ldd	r17, Z+1	; 0x01
    13f6:	01 15       	cp	r16, r1
    13f8:	11 05       	cpc	r17, r1
    13fa:	09 f4       	brne	.+2      	; 0x13fe <findshortpath_1+0xb6>
    13fc:	8e c0       	rjmp	.+284    	; 0x151a <findshortpath_1+0x1d2>
       {     if(pushcheck(s,a[x][y]))
    13fe:	d6 01       	movw	r26, r12
    1400:	f1 01       	movw	r30, r2
    1402:	8e e3       	ldi	r24, 0x3E	; 62
    1404:	01 90       	ld	r0, Z+
    1406:	0d 92       	st	X+, r0
    1408:	81 50       	subi	r24, 0x01	; 1
    140a:	e1 f7       	brne	.-8      	; 0x1404 <findshortpath_1+0xbc>
    140c:	d6 01       	movw	r26, r12
    140e:	dc 96       	adiw	r26, 0x3c	; 60
    1410:	2d 91       	ld	r18, X+
    1412:	3c 91       	ld	r19, X
    1414:	dd 97       	sbiw	r26, 0x3d	; 61
    1416:	f9 01       	movw	r30, r18
    1418:	ee 0f       	add	r30, r30
    141a:	ff 1f       	adc	r31, r31
    141c:	ec 0d       	add	r30, r12
    141e:	fd 1d       	adc	r31, r13
    1420:	08 c0       	rjmp	.+16     	; 0x1432 <findshortpath_1+0xea>
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
      if(n==s.a[i])
    1422:	80 81       	ld	r24, Z
    1424:	91 81       	ldd	r25, Z+1	; 0x01
    1426:	21 50       	subi	r18, 0x01	; 1
    1428:	30 40       	sbci	r19, 0x00	; 0
    142a:	32 97       	sbiw	r30, 0x02	; 2
    142c:	08 17       	cp	r16, r24
    142e:	19 07       	cpc	r17, r25
    1430:	69 f0       	breq	.+26     	; 0x144c <findshortpath_1+0x104>
     return n;
}
int pushcheck(stack s,int n)
{
 	int i;
 	for(i=s.top;i>=0;i--)
    1432:	37 ff       	sbrs	r19, 7
    1434:	f6 cf       	rjmp	.-20     	; 0x1422 <findshortpath_1+0xda>
    1436:	35 c7       	rjmp	.+3690   	; 0x22a2 <findshortpath_1+0xf5a>
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
	     return;
     p->top++;
    1438:	31 96       	adiw	r30, 0x01	; 1
    143a:	d4 01       	movw	r26, r8
    143c:	ed 93       	st	X+, r30
    143e:	fc 93       	st	X, r31
     p->a[p->top]=n;
    1440:	ee 0f       	add	r30, r30
    1442:	ff 1f       	adc	r31, r31
    1444:	ea 0d       	add	r30, r10
    1446:	fb 1d       	adc	r31, r11
    1448:	15 a7       	std	Z+45, r17	; 0x2d
    144a:	04 a7       	std	Z+44, r16	; 0x2c
 	s.top=-1;t.top=-1;path.top=-1;int j=-1;int i,n,u,q,g,w=0,v;
 	while(x!=xx || y!=yy)
 	{if(a[x][y]!=0)
       {     if(pushcheck(s,a[x][y]))
                  push(&s,a[x][y]);
             if(y+1<=3)  right(&s,a[x][y+1],&k);
    144c:	43 30       	cpi	r20, 0x03	; 3
    144e:	51 05       	cpc	r21, r1
    1450:	6c f4       	brge	.+26     	; 0x146c <findshortpath_1+0x124>
    1452:	4f 5f       	subi	r20, 0xFF	; 255
    1454:	5f 4f       	sbci	r21, 0xFF	; 255
    1456:	44 0f       	add	r20, r20
    1458:	55 1f       	adc	r21, r21
    145a:	64 0f       	add	r22, r20
    145c:	75 1f       	adc	r23, r21
    145e:	fb 01       	movw	r30, r22
    1460:	60 81       	ld	r22, Z
    1462:	71 81       	ldd	r23, Z+1	; 0x01
    1464:	c1 01       	movw	r24, r2
    1466:	a5 01       	movw	r20, r10
    1468:	0e 94 07 05 	call	0xa0e	; 0xa0e <right>
             if(x-1>=0)  up(&s,a[x-1][y],&k);
    146c:	e0 91 f0 00 	lds	r30, 0x00F0
    1470:	f0 91 f1 00 	lds	r31, 0x00F1
    1474:	1e 16       	cp	r1, r30
    1476:	1f 06       	cpc	r1, r31
    1478:	b4 f4       	brge	.+44     	; 0x14a6 <findshortpath_1+0x15e>
    147a:	31 97       	sbiw	r30, 0x01	; 1
    147c:	83 e0       	ldi	r24, 0x03	; 3
    147e:	ee 0f       	add	r30, r30
    1480:	ff 1f       	adc	r31, r31
    1482:	8a 95       	dec	r24
    1484:	e1 f7       	brne	.-8      	; 0x147e <findshortpath_1+0x136>
    1486:	ee 0d       	add	r30, r14
    1488:	ff 1d       	adc	r31, r15
    148a:	80 91 f2 00 	lds	r24, 0x00F2
    148e:	90 91 f3 00 	lds	r25, 0x00F3
    1492:	88 0f       	add	r24, r24
    1494:	99 1f       	adc	r25, r25
    1496:	e8 0f       	add	r30, r24
    1498:	f9 1f       	adc	r31, r25
    149a:	60 81       	ld	r22, Z
    149c:	71 81       	ldd	r23, Z+1	; 0x01
    149e:	c1 01       	movw	r24, r2
    14a0:	a5 01       	movw	r20, r10
    14a2:	0e 94 5b 05 	call	0xab6	; 0xab6 <up>
             if(y-1>=0)  left(&s,a[x][y-1],&k);
    14a6:	80 91 f2 00 	lds	r24, 0x00F2
    14aa:	90 91 f3 00 	lds	r25, 0x00F3
    14ae:	18 16       	cp	r1, r24
    14b0:	19 06       	cpc	r1, r25
    14b2:	b4 f4       	brge	.+44     	; 0x14e0 <findshortpath_1+0x198>
    14b4:	e0 91 f0 00 	lds	r30, 0x00F0
    14b8:	f0 91 f1 00 	lds	r31, 0x00F1
    14bc:	13 e0       	ldi	r17, 0x03	; 3
    14be:	ee 0f       	add	r30, r30
    14c0:	ff 1f       	adc	r31, r31
    14c2:	1a 95       	dec	r17
    14c4:	e1 f7       	brne	.-8      	; 0x14be <findshortpath_1+0x176>
    14c6:	ee 0d       	add	r30, r14
    14c8:	ff 1d       	adc	r31, r15
    14ca:	01 97       	sbiw	r24, 0x01	; 1
    14cc:	88 0f       	add	r24, r24
    14ce:	99 1f       	adc	r25, r25
    14d0:	e8 0f       	add	r30, r24
    14d2:	f9 1f       	adc	r31, r25
    14d4:	60 81       	ld	r22, Z
    14d6:	71 81       	ldd	r23, Z+1	; 0x01
    14d8:	c1 01       	movw	r24, r2
    14da:	a5 01       	movw	r20, r10
    14dc:	0e 94 5f 04 	call	0x8be	; 0x8be <left>
             if(x+1<=3)  below(&s,a[x+1][y],&k);
    14e0:	e0 91 f0 00 	lds	r30, 0x00F0
    14e4:	f0 91 f1 00 	lds	r31, 0x00F1
    14e8:	e3 30       	cpi	r30, 0x03	; 3
    14ea:	f1 05       	cpc	r31, r1
    14ec:	b4 f4       	brge	.+44     	; 0x151a <findshortpath_1+0x1d2>
    14ee:	31 96       	adiw	r30, 0x01	; 1
    14f0:	a3 e0       	ldi	r26, 0x03	; 3
    14f2:	ee 0f       	add	r30, r30
    14f4:	ff 1f       	adc	r31, r31
    14f6:	aa 95       	dec	r26
    14f8:	e1 f7       	brne	.-8      	; 0x14f2 <findshortpath_1+0x1aa>
    14fa:	ee 0d       	add	r30, r14
    14fc:	ff 1d       	adc	r31, r15
    14fe:	80 91 f2 00 	lds	r24, 0x00F2
    1502:	90 91 f3 00 	lds	r25, 0x00F3
    1506:	88 0f       	add	r24, r24
    1508:	99 1f       	adc	r25, r25
    150a:	e8 0f       	add	r30, r24
    150c:	f9 1f       	adc	r31, r25
    150e:	60 81       	ld	r22, Z
    1510:	71 81       	ldd	r23, Z+1	; 0x01
    1512:	c1 01       	movw	r24, r2
    1514:	a5 01       	movw	r20, r10
    1516:	0e 94 b3 04 	call	0x966	; 0x966 <below>
       }
       j++;
    151a:	c5 56       	subi	r28, 0x65	; 101
    151c:	de 4f       	sbci	r29, 0xFE	; 254
    151e:	28 81       	ld	r18, Y
    1520:	39 81       	ldd	r19, Y+1	; 0x01
    1522:	cb 59       	subi	r28, 0x9B	; 155
    1524:	d1 40       	sbci	r29, 0x01	; 1
    1526:	2f 5f       	subi	r18, 0xFF	; 255
    1528:	3f 4f       	sbci	r19, 0xFF	; 255
    152a:	c5 56       	subi	r28, 0x65	; 101
    152c:	de 4f       	sbci	r29, 0xFE	; 254
    152e:	39 83       	std	Y+1, r19	; 0x01
    1530:	28 83       	st	Y, r18
    1532:	cb 59       	subi	r28, 0x9B	; 155
    1534:	d1 40       	sbci	r29, 0x01	; 1
	   link[j]=a[x][y]*10+k;
    1536:	e0 91 f0 00 	lds	r30, 0x00F0
    153a:	f0 91 f1 00 	lds	r31, 0x00F1
    153e:	63 e0       	ldi	r22, 0x03	; 3
    1540:	ee 0f       	add	r30, r30
    1542:	ff 1f       	adc	r31, r31
    1544:	6a 95       	dec	r22
    1546:	e1 f7       	brne	.-8      	; 0x1540 <findshortpath_1+0x1f8>
    1548:	ee 0d       	add	r30, r14
    154a:	ff 1d       	adc	r31, r15
    154c:	80 91 f2 00 	lds	r24, 0x00F2
    1550:	90 91 f3 00 	lds	r25, 0x00F3
    1554:	88 0f       	add	r24, r24
    1556:	99 1f       	adc	r25, r25
    1558:	e8 0f       	add	r30, r24
    155a:	f9 1f       	adc	r31, r25
    155c:	20 81       	ld	r18, Z
    155e:	31 81       	ldd	r19, Z+1	; 0x01
    1560:	c9 01       	movw	r24, r18
    1562:	43 e0       	ldi	r20, 0x03	; 3
    1564:	88 0f       	add	r24, r24
    1566:	99 1f       	adc	r25, r25
    1568:	4a 95       	dec	r20
    156a:	e1 f7       	brne	.-8      	; 0x1564 <findshortpath_1+0x21c>
    156c:	22 0f       	add	r18, r18
    156e:	33 1f       	adc	r19, r19
    1570:	82 0f       	add	r24, r18
    1572:	93 1f       	adc	r25, r19
    1574:	29 81       	ldd	r18, Y+1	; 0x01
    1576:	3a 81       	ldd	r19, Y+2	; 0x02
    1578:	82 0f       	add	r24, r18
    157a:	93 1f       	adc	r25, r19
    157c:	c5 56       	subi	r28, 0x65	; 101
    157e:	de 4f       	sbci	r29, 0xFE	; 254
    1580:	e8 81       	ld	r30, Y
    1582:	f9 81       	ldd	r31, Y+1	; 0x01
    1584:	cb 59       	subi	r28, 0x9B	; 155
    1586:	d1 40       	sbci	r29, 0x01	; 1
    1588:	ee 0f       	add	r30, r30
    158a:	ff 1f       	adc	r31, r31
    158c:	a5 e2       	ldi	r26, 0x25	; 37
    158e:	b1 e0       	ldi	r27, 0x01	; 1
    1590:	ac 0f       	add	r26, r28
    1592:	bd 1f       	adc	r27, r29
    1594:	ea 0f       	add	r30, r26
    1596:	fb 1f       	adc	r31, r27
    1598:	91 83       	std	Z+1, r25	; 0x01
    159a:	80 83       	st	Z, r24
	   if(link[j]%10==0 )
    159c:	6a e0       	ldi	r22, 0x0A	; 10
    159e:	70 e0       	ldi	r23, 0x00	; 0
    15a0:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    15a4:	89 2b       	or	r24, r25
    15a6:	09 f0       	breq	.+2      	; 0x15aa <findshortpath_1+0x262>
    15a8:	45 c2       	rjmp	.+1162   	; 0x1a34 <findshortpath_1+0x6ec>
    15aa:	11 c0       	rjmp	.+34     	; 0x15ce <findshortpath_1+0x286>
	   {    while(link[j]%10 <2)
	   	 	{link[j]=0;	 j--;}		
    15ac:	11 82       	std	Z+1, r1	; 0x01
    15ae:	10 82       	st	Z, r1
    15b0:	c5 56       	subi	r28, 0x65	; 101
    15b2:	de 4f       	sbci	r29, 0xFE	; 254
    15b4:	28 81       	ld	r18, Y
    15b6:	39 81       	ldd	r19, Y+1	; 0x01
    15b8:	cb 59       	subi	r28, 0x9B	; 155
    15ba:	d1 40       	sbci	r29, 0x01	; 1
    15bc:	21 50       	subi	r18, 0x01	; 1
    15be:	30 40       	sbci	r19, 0x00	; 0
    15c0:	c5 56       	subi	r28, 0x65	; 101
    15c2:	de 4f       	sbci	r29, 0xFE	; 254
    15c4:	39 83       	std	Y+1, r19	; 0x01
    15c6:	28 83       	st	Y, r18
    15c8:	cb 59       	subi	r28, 0x9B	; 155
    15ca:	d1 40       	sbci	r29, 0x01	; 1
    15cc:	32 97       	sbiw	r30, 0x02	; 2
             if(x+1<=3)  below(&s,a[x+1][y],&k);
       }
       j++;
	   link[j]=a[x][y]*10+k;
	   if(link[j]%10==0 )
	   {    while(link[j]%10 <2)
    15ce:	40 80       	ld	r4, Z
    15d0:	51 80       	ldd	r5, Z+1	; 0x01
    15d2:	c2 01       	movw	r24, r4
    15d4:	6a e0       	ldi	r22, 0x0A	; 10
    15d6:	70 e0       	ldi	r23, 0x00	; 0
    15d8:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    15dc:	9c 01       	movw	r18, r24
    15de:	82 30       	cpi	r24, 0x02	; 2
    15e0:	91 05       	cpc	r25, r1
    15e2:	24 f3       	brlt	.-56     	; 0x15ac <findshortpath_1+0x264>
	   	 	{link[j]=0;	 j--;}		
	        l=0;
	        do{c[l]=TOP(s); pop(&s);l++;
			}while(TOP(s)!=link[j]/10);
    15e4:	c2 01       	movw	r24, r4
    15e6:	6a e0       	ldi	r22, 0x0A	; 10
    15e8:	70 e0       	ldi	r23, 0x00	; 0
    15ea:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    15ee:	ab 01       	movw	r20, r22
    15f0:	be 01       	movw	r22, r28
    15f2:	6b 5f       	subi	r22, 0xFB	; 251
    15f4:	7f 4f       	sbci	r23, 0xFF	; 255
    15f6:	00 e0       	ldi	r16, 0x00	; 0
    15f8:	10 e0       	ldi	r17, 0x00	; 0
	   link[j]=a[x][y]*10+k;
	   if(link[j]%10==0 )
	   {    while(link[j]%10 <2)
	   	 	{link[j]=0;	 j--;}		
	        l=0;
	        do{c[l]=TOP(s); pop(&s);l++;
    15fa:	d6 01       	movw	r26, r12
    15fc:	f1 01       	movw	r30, r2
    15fe:	8e e3       	ldi	r24, 0x3E	; 62
    1600:	01 90       	ld	r0, Z+
    1602:	0d 92       	st	X+, r0
    1604:	81 50       	subi	r24, 0x01	; 1
    1606:	e1 f7       	brne	.-8      	; 0x1600 <findshortpath_1+0x2b8>
         return 0;
      return 1;
}
int TOP(stack s)
{
 	return s.a[s.top];
    1608:	d6 01       	movw	r26, r12
    160a:	dc 96       	adiw	r26, 0x3c	; 60
    160c:	ed 91       	ld	r30, X+
    160e:	fc 91       	ld	r31, X
    1610:	dd 97       	sbiw	r26, 0x3d	; 61
    1612:	ee 0f       	add	r30, r30
    1614:	ff 1f       	adc	r31, r31
    1616:	ec 0d       	add	r30, r12
    1618:	fd 1d       	adc	r31, r13
    161a:	60 80       	ld	r6, Z
    161c:	71 80       	ldd	r7, Z+1	; 0x01
	   link[j]=a[x][y]*10+k;
	   if(link[j]%10==0 )
	   {    while(link[j]%10 <2)
	   	 	{link[j]=0;	 j--;}		
	        l=0;
	        do{c[l]=TOP(s); pop(&s);l++;
    161e:	fb 01       	movw	r30, r22
    1620:	71 82       	std	Z+1, r7	; 0x01
    1622:	60 82       	st	Z, r6
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    1624:	d4 01       	movw	r26, r8
    1626:	8d 91       	ld	r24, X+
    1628:	9c 91       	ld	r25, X
    162a:	bf ef       	ldi	r27, 0xFF	; 255
    162c:	8f 3f       	cpi	r24, 0xFF	; 255
    162e:	9b 07       	cpc	r25, r27
    1630:	21 f0       	breq	.+8      	; 0x163a <findshortpath_1+0x2f2>
 	     return 0;
     n=p->a[p->top];
     p->top--;
    1632:	01 97       	sbiw	r24, 0x01	; 1
    1634:	f4 01       	movw	r30, r8
    1636:	91 83       	std	Z+1, r25	; 0x01
    1638:	80 83       	st	Z, r24
	   link[j]=a[x][y]*10+k;
	   if(link[j]%10==0 )
	   {    while(link[j]%10 <2)
	   	 	{link[j]=0;	 j--;}		
	        l=0;
	        do{c[l]=TOP(s); pop(&s);l++;
    163a:	0f 5f       	subi	r16, 0xFF	; 255
    163c:	1f 4f       	sbci	r17, 0xFF	; 255
			}while(TOP(s)!=link[j]/10);
    163e:	d6 01       	movw	r26, r12
    1640:	f1 01       	movw	r30, r2
    1642:	8e e3       	ldi	r24, 0x3E	; 62
    1644:	01 90       	ld	r0, Z+
    1646:	0d 92       	st	X+, r0
    1648:	81 50       	subi	r24, 0x01	; 1
    164a:	e1 f7       	brne	.-8      	; 0x1644 <findshortpath_1+0x2fc>
    164c:	6e 5f       	subi	r22, 0xFE	; 254
    164e:	7f 4f       	sbci	r23, 0xFF	; 255
    1650:	d6 01       	movw	r26, r12
    1652:	dc 96       	adiw	r26, 0x3c	; 60
    1654:	ed 91       	ld	r30, X+
    1656:	fc 91       	ld	r31, X
    1658:	dd 97       	sbiw	r26, 0x3d	; 61
    165a:	ee 0f       	add	r30, r30
    165c:	ff 1f       	adc	r31, r31
    165e:	ec 0d       	add	r30, r12
    1660:	fd 1d       	adc	r31, r13
    1662:	80 81       	ld	r24, Z
    1664:	91 81       	ldd	r25, Z+1	; 0x01
    1666:	84 17       	cp	r24, r20
    1668:	95 07       	cpc	r25, r21
    166a:	39 f6       	brne	.-114    	; 0x15fa <findshortpath_1+0x2b2>
			if(link[j]%10==2)
    166c:	22 30       	cpi	r18, 0x02	; 2
    166e:	31 05       	cpc	r19, r1
    1670:	09 f0       	breq	.+2      	; 0x1674 <findshortpath_1+0x32c>
    1672:	6d c0       	rjmp	.+218    	; 0x174e <findshortpath_1+0x406>
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
    1674:	02 50       	subi	r16, 0x02	; 2
    1676:	10 40       	sbci	r17, 0x00	; 0
    1678:	00 0f       	add	r16, r16
    167a:	11 1f       	adc	r17, r17
    167c:	0a 0d       	add	r16, r10
    167e:	1b 1d       	adc	r17, r11
    1680:	d8 01       	movw	r26, r16
    1682:	14 96       	adiw	r26, 0x04	; 4
    1684:	ed 91       	ld	r30, X+
    1686:	fc 91       	ld	r31, X
    1688:	15 97       	sbiw	r26, 0x05	; 5
    168a:	b7 01       	movw	r22, r14
    168c:	20 e0       	ldi	r18, 0x00	; 0
    168e:	30 e0       	ldi	r19, 0x00	; 0
    1690:	26 c0       	rjmp	.+76     	; 0x16de <findshortpath_1+0x396>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1692:	8d 91       	ld	r24, X+
    1694:	9c 91       	ld	r25, X
    1696:	11 97       	sbiw	r26, 0x01	; 1
    1698:	e8 17       	cp	r30, r24
    169a:	f9 07       	cpc	r31, r25
    169c:	99 f4       	brne	.+38     	; 0x16c4 <findshortpath_1+0x37c>
  				        { return 10*i+j;}
    169e:	f9 01       	movw	r30, r18
    16a0:	93 e0       	ldi	r25, 0x03	; 3
    16a2:	ee 0f       	add	r30, r30
    16a4:	ff 1f       	adc	r31, r31
    16a6:	9a 95       	dec	r25
    16a8:	e1 f7       	brne	.-8      	; 0x16a2 <findshortpath_1+0x35a>
    16aa:	22 0f       	add	r18, r18
    16ac:	33 1f       	adc	r19, r19
    16ae:	e2 0f       	add	r30, r18
    16b0:	f3 1f       	adc	r31, r19
    16b2:	e4 0f       	add	r30, r20
    16b4:	f5 1f       	adc	r31, r21
    16b6:	c7 56       	subi	r28, 0x67	; 103
    16b8:	de 4f       	sbci	r29, 0xFE	; 254
    16ba:	f9 83       	std	Y+1, r31	; 0x01
    16bc:	e8 83       	st	Y, r30
    16be:	c9 59       	subi	r28, 0x99	; 153
    16c0:	d1 40       	sbci	r29, 0x01	; 1
    16c2:	11 c0       	rjmp	.+34     	; 0x16e6 <findshortpath_1+0x39e>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    16c4:	4f 5f       	subi	r20, 0xFF	; 255
    16c6:	5f 4f       	sbci	r21, 0xFF	; 255
    16c8:	12 96       	adiw	r26, 0x02	; 2
    16ca:	44 30       	cpi	r20, 0x04	; 4
    16cc:	51 05       	cpc	r21, r1
    16ce:	09 f7       	brne	.-62     	; 0x1692 <findshortpath_1+0x34a>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    16d0:	2f 5f       	subi	r18, 0xFF	; 255
    16d2:	3f 4f       	sbci	r19, 0xFF	; 255
    16d4:	68 5f       	subi	r22, 0xF8	; 248
    16d6:	7f 4f       	sbci	r23, 0xFF	; 255
    16d8:	24 30       	cpi	r18, 0x04	; 4
    16da:	31 05       	cpc	r19, r1
    16dc:	21 f0       	breq	.+8      	; 0x16e6 <findshortpath_1+0x39e>
    16de:	db 01       	movw	r26, r22
    16e0:	40 e0       	ldi	r20, 0x00	; 0
    16e2:	50 e0       	ldi	r21, 0x00	; 0
    16e4:	d6 cf       	rjmp	.-84     	; 0x1692 <findshortpath_1+0x34a>
	   	 	{link[j]=0;	 j--;}		
	        l=0;
	        do{c[l]=TOP(s); pop(&s);l++;
			}while(TOP(s)!=link[j]/10);
			if(link[j]%10==2)
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
    16e6:	c7 56       	subi	r28, 0x67	; 103
    16e8:	de 4f       	sbci	r29, 0xFE	; 254
    16ea:	88 81       	ld	r24, Y
    16ec:	99 81       	ldd	r25, Y+1	; 0x01
    16ee:	c9 59       	subi	r28, 0x99	; 153
    16f0:	d1 40       	sbci	r29, 0x01	; 1
    16f2:	6a e0       	ldi	r22, 0x0A	; 10
    16f4:	70 e0       	ldi	r23, 0x00	; 0
    16f6:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    16fa:	fb 01       	movw	r30, r22
    16fc:	03 e0       	ldi	r16, 0x03	; 3
    16fe:	ee 0f       	add	r30, r30
    1700:	ff 1f       	adc	r31, r31
    1702:	0a 95       	dec	r16
    1704:	e1 f7       	brne	.-8      	; 0x16fe <findshortpath_1+0x3b6>
    1706:	ee 0d       	add	r30, r14
    1708:	ff 1d       	adc	r31, r15
    170a:	c7 56       	subi	r28, 0x67	; 103
    170c:	de 4f       	sbci	r29, 0xFE	; 254
    170e:	88 81       	ld	r24, Y
    1710:	99 81       	ldd	r25, Y+1	; 0x01
    1712:	c9 59       	subi	r28, 0x99	; 153
    1714:	d1 40       	sbci	r29, 0x01	; 1
    1716:	6a e0       	ldi	r22, 0x0A	; 10
    1718:	70 e0       	ldi	r23, 0x00	; 0
    171a:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    171e:	88 0f       	add	r24, r24
    1720:	99 1f       	adc	r25, r25
    1722:	e8 0f       	add	r30, r24
    1724:	f9 1f       	adc	r31, r25
    1726:	11 82       	std	Z+1, r1	; 0x01
    1728:	10 82       	st	Z, r1
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    172a:	d4 01       	movw	r26, r8
    172c:	ed 91       	ld	r30, X+
    172e:	fc 91       	ld	r31, X
    1730:	11 97       	sbiw	r26, 0x01	; 1
    1732:	ed 31       	cpi	r30, 0x1D	; 29
    1734:	f1 05       	cpc	r31, r1
    1736:	09 f4       	brne	.+2      	; 0x173a <findshortpath_1+0x3f2>
    1738:	14 c1       	rjmp	.+552    	; 0x1962 <findshortpath_1+0x61a>
	     return;
     p->top++;
    173a:	31 96       	adiw	r30, 0x01	; 1
    173c:	ed 93       	st	X+, r30
    173e:	fc 93       	st	X, r31
     p->a[p->top]=n;
    1740:	ee 0f       	add	r30, r30
    1742:	ff 1f       	adc	r31, r31
    1744:	ea 0d       	add	r30, r10
    1746:	fb 1d       	adc	r31, r11
    1748:	75 a6       	std	Z+45, r7	; 0x2d
    174a:	64 a6       	std	Z+44, r6	; 0x2c
    174c:	0a c1       	rjmp	.+532    	; 0x1962 <findshortpath_1+0x61a>
	        l=0;
	        do{c[l]=TOP(s); pop(&s);l++;
			}while(TOP(s)!=link[j]/10);
			if(link[j]%10==2)
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
		    if(link[j]%10==3)
    174e:	23 30       	cpi	r18, 0x03	; 3
    1750:	31 05       	cpc	r19, r1
    1752:	09 f0       	breq	.+2      	; 0x1756 <findshortpath_1+0x40e>
    1754:	6a c0       	rjmp	.+212    	; 0x182a <findshortpath_1+0x4e2>
			{	int z=checkarray(c[l-3],a);  a[z/10][z%10]=0;  push(&s,c[l-1]); push(&s,c[l-2]); }
    1756:	f8 01       	movw	r30, r16
    1758:	33 97       	sbiw	r30, 0x03	; 3
    175a:	ee 0f       	add	r30, r30
    175c:	ff 1f       	adc	r31, r31
    175e:	ea 0d       	add	r30, r10
    1760:	fb 1d       	adc	r31, r11
    1762:	a4 81       	ldd	r26, Z+4	; 0x04
    1764:	b5 81       	ldd	r27, Z+5	; 0x05
    1766:	b7 01       	movw	r22, r14
    1768:	20 e0       	ldi	r18, 0x00	; 0
    176a:	30 e0       	ldi	r19, 0x00	; 0
    176c:	25 c0       	rjmp	.+74     	; 0x17b8 <findshortpath_1+0x470>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    176e:	80 81       	ld	r24, Z
    1770:	91 81       	ldd	r25, Z+1	; 0x01
    1772:	a8 17       	cp	r26, r24
    1774:	b9 07       	cpc	r27, r25
    1776:	99 f4       	brne	.+38     	; 0x179e <findshortpath_1+0x456>
  				        { return 10*i+j;}
    1778:	f9 01       	movw	r30, r18
    177a:	73 e0       	ldi	r23, 0x03	; 3
    177c:	ee 0f       	add	r30, r30
    177e:	ff 1f       	adc	r31, r31
    1780:	7a 95       	dec	r23
    1782:	e1 f7       	brne	.-8      	; 0x177c <findshortpath_1+0x434>
    1784:	22 0f       	add	r18, r18
    1786:	33 1f       	adc	r19, r19
    1788:	e2 0f       	add	r30, r18
    178a:	f3 1f       	adc	r31, r19
    178c:	e4 0f       	add	r30, r20
    178e:	f5 1f       	adc	r31, r21
    1790:	c9 56       	subi	r28, 0x69	; 105
    1792:	de 4f       	sbci	r29, 0xFE	; 254
    1794:	f9 83       	std	Y+1, r31	; 0x01
    1796:	e8 83       	st	Y, r30
    1798:	c7 59       	subi	r28, 0x97	; 151
    179a:	d1 40       	sbci	r29, 0x01	; 1
    179c:	11 c0       	rjmp	.+34     	; 0x17c0 <findshortpath_1+0x478>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    179e:	4f 5f       	subi	r20, 0xFF	; 255
    17a0:	5f 4f       	sbci	r21, 0xFF	; 255
    17a2:	32 96       	adiw	r30, 0x02	; 2
    17a4:	44 30       	cpi	r20, 0x04	; 4
    17a6:	51 05       	cpc	r21, r1
    17a8:	11 f7       	brne	.-60     	; 0x176e <findshortpath_1+0x426>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    17aa:	2f 5f       	subi	r18, 0xFF	; 255
    17ac:	3f 4f       	sbci	r19, 0xFF	; 255
    17ae:	68 5f       	subi	r22, 0xF8	; 248
    17b0:	7f 4f       	sbci	r23, 0xFF	; 255
    17b2:	24 30       	cpi	r18, 0x04	; 4
    17b4:	31 05       	cpc	r19, r1
    17b6:	21 f0       	breq	.+8      	; 0x17c0 <findshortpath_1+0x478>
    17b8:	fb 01       	movw	r30, r22
    17ba:	40 e0       	ldi	r20, 0x00	; 0
    17bc:	50 e0       	ldi	r21, 0x00	; 0
    17be:	d7 cf       	rjmp	.-82     	; 0x176e <findshortpath_1+0x426>
	        do{c[l]=TOP(s); pop(&s);l++;
			}while(TOP(s)!=link[j]/10);
			if(link[j]%10==2)
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
		    if(link[j]%10==3)
			{	int z=checkarray(c[l-3],a);  a[z/10][z%10]=0;  push(&s,c[l-1]); push(&s,c[l-2]); }
    17c0:	c9 56       	subi	r28, 0x69	; 105
    17c2:	de 4f       	sbci	r29, 0xFE	; 254
    17c4:	88 81       	ld	r24, Y
    17c6:	99 81       	ldd	r25, Y+1	; 0x01
    17c8:	c7 59       	subi	r28, 0x97	; 151
    17ca:	d1 40       	sbci	r29, 0x01	; 1
    17cc:	6a e0       	ldi	r22, 0x0A	; 10
    17ce:	70 e0       	ldi	r23, 0x00	; 0
    17d0:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    17d4:	fb 01       	movw	r30, r22
    17d6:	53 e0       	ldi	r21, 0x03	; 3
    17d8:	ee 0f       	add	r30, r30
    17da:	ff 1f       	adc	r31, r31
    17dc:	5a 95       	dec	r21
    17de:	e1 f7       	brne	.-8      	; 0x17d8 <findshortpath_1+0x490>
    17e0:	ee 0d       	add	r30, r14
    17e2:	ff 1d       	adc	r31, r15
    17e4:	c9 56       	subi	r28, 0x69	; 105
    17e6:	de 4f       	sbci	r29, 0xFE	; 254
    17e8:	88 81       	ld	r24, Y
    17ea:	99 81       	ldd	r25, Y+1	; 0x01
    17ec:	c7 59       	subi	r28, 0x97	; 151
    17ee:	d1 40       	sbci	r29, 0x01	; 1
    17f0:	6a e0       	ldi	r22, 0x0A	; 10
    17f2:	70 e0       	ldi	r23, 0x00	; 0
    17f4:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    17f8:	88 0f       	add	r24, r24
    17fa:	99 1f       	adc	r25, r25
    17fc:	e8 0f       	add	r30, r24
    17fe:	f9 1f       	adc	r31, r25
    1800:	11 82       	std	Z+1, r1	; 0x01
    1802:	10 82       	st	Z, r1
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    1804:	d4 01       	movw	r26, r8
    1806:	ed 91       	ld	r30, X+
    1808:	fc 91       	ld	r31, X
    180a:	11 97       	sbiw	r26, 0x01	; 1
    180c:	ed 31       	cpi	r30, 0x1D	; 29
    180e:	f1 05       	cpc	r31, r1
    1810:	49 f0       	breq	.+18     	; 0x1824 <findshortpath_1+0x4dc>
	     return;
     p->top++;
    1812:	31 96       	adiw	r30, 0x01	; 1
    1814:	ed 93       	st	X+, r30
    1816:	fc 93       	st	X, r31
     p->a[p->top]=n;
    1818:	ee 0f       	add	r30, r30
    181a:	ff 1f       	adc	r31, r31
    181c:	ea 0d       	add	r30, r10
    181e:	fb 1d       	adc	r31, r11
    1820:	75 a6       	std	Z+45, r7	; 0x2d
    1822:	64 a6       	std	Z+44, r6	; 0x2c
	        do{c[l]=TOP(s); pop(&s);l++;
			}while(TOP(s)!=link[j]/10);
			if(link[j]%10==2)
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
		    if(link[j]%10==3)
			{	int z=checkarray(c[l-3],a);  a[z/10][z%10]=0;  push(&s,c[l-1]); push(&s,c[l-2]); }
    1824:	02 50       	subi	r16, 0x02	; 2
    1826:	10 40       	sbci	r17, 0x00	; 0
    1828:	85 c0       	rjmp	.+266    	; 0x1934 <findshortpath_1+0x5ec>
		    if(link[j]%10==4)
    182a:	24 30       	cpi	r18, 0x04	; 4
    182c:	31 05       	cpc	r19, r1
    182e:	09 f0       	breq	.+2      	; 0x1832 <findshortpath_1+0x4ea>
    1830:	98 c0       	rjmp	.+304    	; 0x1962 <findshortpath_1+0x61a>
			{	int z=checkarray(c[l-4],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);push(&s,c[l-2]);push(&s,c[l-3]);}
    1832:	f8 01       	movw	r30, r16
    1834:	34 97       	sbiw	r30, 0x04	; 4
    1836:	ee 0f       	add	r30, r30
    1838:	ff 1f       	adc	r31, r31
    183a:	ea 0d       	add	r30, r10
    183c:	fb 1d       	adc	r31, r11
    183e:	a4 81       	ldd	r26, Z+4	; 0x04
    1840:	b5 81       	ldd	r27, Z+5	; 0x05
    1842:	b7 01       	movw	r22, r14
    1844:	20 e0       	ldi	r18, 0x00	; 0
    1846:	30 e0       	ldi	r19, 0x00	; 0
    1848:	25 c0       	rjmp	.+74     	; 0x1894 <findshortpath_1+0x54c>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    184a:	80 81       	ld	r24, Z
    184c:	91 81       	ldd	r25, Z+1	; 0x01
    184e:	a8 17       	cp	r26, r24
    1850:	b9 07       	cpc	r27, r25
    1852:	99 f4       	brne	.+38     	; 0x187a <findshortpath_1+0x532>
  				        { return 10*i+j;}
    1854:	f9 01       	movw	r30, r18
    1856:	93 e0       	ldi	r25, 0x03	; 3
    1858:	ee 0f       	add	r30, r30
    185a:	ff 1f       	adc	r31, r31
    185c:	9a 95       	dec	r25
    185e:	e1 f7       	brne	.-8      	; 0x1858 <findshortpath_1+0x510>
    1860:	22 0f       	add	r18, r18
    1862:	33 1f       	adc	r19, r19
    1864:	e2 0f       	add	r30, r18
    1866:	f3 1f       	adc	r31, r19
    1868:	e4 0f       	add	r30, r20
    186a:	f5 1f       	adc	r31, r21
    186c:	cb 56       	subi	r28, 0x6B	; 107
    186e:	de 4f       	sbci	r29, 0xFE	; 254
    1870:	f9 83       	std	Y+1, r31	; 0x01
    1872:	e8 83       	st	Y, r30
    1874:	c5 59       	subi	r28, 0x95	; 149
    1876:	d1 40       	sbci	r29, 0x01	; 1
    1878:	11 c0       	rjmp	.+34     	; 0x189c <findshortpath_1+0x554>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    187a:	4f 5f       	subi	r20, 0xFF	; 255
    187c:	5f 4f       	sbci	r21, 0xFF	; 255
    187e:	32 96       	adiw	r30, 0x02	; 2
    1880:	44 30       	cpi	r20, 0x04	; 4
    1882:	51 05       	cpc	r21, r1
    1884:	11 f7       	brne	.-60     	; 0x184a <findshortpath_1+0x502>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    1886:	2f 5f       	subi	r18, 0xFF	; 255
    1888:	3f 4f       	sbci	r19, 0xFF	; 255
    188a:	68 5f       	subi	r22, 0xF8	; 248
    188c:	7f 4f       	sbci	r23, 0xFF	; 255
    188e:	24 30       	cpi	r18, 0x04	; 4
    1890:	31 05       	cpc	r19, r1
    1892:	21 f0       	breq	.+8      	; 0x189c <findshortpath_1+0x554>
    1894:	fb 01       	movw	r30, r22
    1896:	40 e0       	ldi	r20, 0x00	; 0
    1898:	50 e0       	ldi	r21, 0x00	; 0
    189a:	d7 cf       	rjmp	.-82     	; 0x184a <findshortpath_1+0x502>
			if(link[j]%10==2)
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
		    if(link[j]%10==3)
			{	int z=checkarray(c[l-3],a);  a[z/10][z%10]=0;  push(&s,c[l-1]); push(&s,c[l-2]); }
		    if(link[j]%10==4)
			{	int z=checkarray(c[l-4],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);push(&s,c[l-2]);push(&s,c[l-3]);}
    189c:	cb 56       	subi	r28, 0x6B	; 107
    189e:	de 4f       	sbci	r29, 0xFE	; 254
    18a0:	88 81       	ld	r24, Y
    18a2:	99 81       	ldd	r25, Y+1	; 0x01
    18a4:	c5 59       	subi	r28, 0x95	; 149
    18a6:	d1 40       	sbci	r29, 0x01	; 1
    18a8:	6a e0       	ldi	r22, 0x0A	; 10
    18aa:	70 e0       	ldi	r23, 0x00	; 0
    18ac:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    18b0:	fb 01       	movw	r30, r22
    18b2:	b3 e0       	ldi	r27, 0x03	; 3
    18b4:	ee 0f       	add	r30, r30
    18b6:	ff 1f       	adc	r31, r31
    18b8:	ba 95       	dec	r27
    18ba:	e1 f7       	brne	.-8      	; 0x18b4 <findshortpath_1+0x56c>
    18bc:	ee 0d       	add	r30, r14
    18be:	ff 1d       	adc	r31, r15
    18c0:	cb 56       	subi	r28, 0x6B	; 107
    18c2:	de 4f       	sbci	r29, 0xFE	; 254
    18c4:	88 81       	ld	r24, Y
    18c6:	99 81       	ldd	r25, Y+1	; 0x01
    18c8:	c5 59       	subi	r28, 0x95	; 149
    18ca:	d1 40       	sbci	r29, 0x01	; 1
    18cc:	6a e0       	ldi	r22, 0x0A	; 10
    18ce:	70 e0       	ldi	r23, 0x00	; 0
    18d0:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    18d4:	88 0f       	add	r24, r24
    18d6:	99 1f       	adc	r25, r25
    18d8:	e8 0f       	add	r30, r24
    18da:	f9 1f       	adc	r31, r25
    18dc:	11 82       	std	Z+1, r1	; 0x01
    18de:	10 82       	st	Z, r1
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    18e0:	d4 01       	movw	r26, r8
    18e2:	ed 91       	ld	r30, X+
    18e4:	fc 91       	ld	r31, X
    18e6:	11 97       	sbiw	r26, 0x01	; 1
    18e8:	ed 31       	cpi	r30, 0x1D	; 29
    18ea:	f1 05       	cpc	r31, r1
    18ec:	49 f0       	breq	.+18     	; 0x1900 <findshortpath_1+0x5b8>
	     return;
     p->top++;
    18ee:	31 96       	adiw	r30, 0x01	; 1
    18f0:	ed 93       	st	X+, r30
    18f2:	fc 93       	st	X, r31
     p->a[p->top]=n;
    18f4:	ee 0f       	add	r30, r30
    18f6:	ff 1f       	adc	r31, r31
    18f8:	ea 0d       	add	r30, r10
    18fa:	fb 1d       	adc	r31, r11
    18fc:	75 a6       	std	Z+45, r7	; 0x2d
    18fe:	64 a6       	std	Z+44, r6	; 0x2c
			if(link[j]%10==2)
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
		    if(link[j]%10==3)
			{	int z=checkarray(c[l-3],a);  a[z/10][z%10]=0;  push(&s,c[l-1]); push(&s,c[l-2]); }
		    if(link[j]%10==4)
			{	int z=checkarray(c[l-4],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);push(&s,c[l-2]);push(&s,c[l-3]);}
    1900:	f8 01       	movw	r30, r16
    1902:	32 97       	sbiw	r30, 0x02	; 2
    1904:	ee 0f       	add	r30, r30
    1906:	ff 1f       	adc	r31, r31
    1908:	ea 0d       	add	r30, r10
    190a:	fb 1d       	adc	r31, r11
    190c:	84 81       	ldd	r24, Z+4	; 0x04
    190e:	95 81       	ldd	r25, Z+5	; 0x05
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    1910:	d4 01       	movw	r26, r8
    1912:	ed 91       	ld	r30, X+
    1914:	fc 91       	ld	r31, X
    1916:	11 97       	sbiw	r26, 0x01	; 1
    1918:	ed 31       	cpi	r30, 0x1D	; 29
    191a:	f1 05       	cpc	r31, r1
    191c:	49 f0       	breq	.+18     	; 0x1930 <findshortpath_1+0x5e8>
	     return;
     p->top++;
    191e:	31 96       	adiw	r30, 0x01	; 1
    1920:	ed 93       	st	X+, r30
    1922:	fc 93       	st	X, r31
     p->a[p->top]=n;
    1924:	ee 0f       	add	r30, r30
    1926:	ff 1f       	adc	r31, r31
    1928:	ea 0d       	add	r30, r10
    192a:	fb 1d       	adc	r31, r11
    192c:	95 a7       	std	Z+45, r25	; 0x2d
    192e:	84 a7       	std	Z+44, r24	; 0x2c
			if(link[j]%10==2)
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
		    if(link[j]%10==3)
			{	int z=checkarray(c[l-3],a);  a[z/10][z%10]=0;  push(&s,c[l-1]); push(&s,c[l-2]); }
		    if(link[j]%10==4)
			{	int z=checkarray(c[l-4],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);push(&s,c[l-2]);push(&s,c[l-3]);}
    1930:	03 50       	subi	r16, 0x03	; 3
    1932:	10 40       	sbci	r17, 0x00	; 0
    1934:	00 0f       	add	r16, r16
    1936:	11 1f       	adc	r17, r17
    1938:	0a 0d       	add	r16, r10
    193a:	1b 1d       	adc	r17, r11
    193c:	f8 01       	movw	r30, r16
    193e:	84 81       	ldd	r24, Z+4	; 0x04
    1940:	95 81       	ldd	r25, Z+5	; 0x05
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    1942:	d4 01       	movw	r26, r8
    1944:	ed 91       	ld	r30, X+
    1946:	fc 91       	ld	r31, X
    1948:	11 97       	sbiw	r26, 0x01	; 1
    194a:	ed 31       	cpi	r30, 0x1D	; 29
    194c:	f1 05       	cpc	r31, r1
    194e:	49 f0       	breq	.+18     	; 0x1962 <findshortpath_1+0x61a>
	     return;
     p->top++;
    1950:	31 96       	adiw	r30, 0x01	; 1
    1952:	ed 93       	st	X+, r30
    1954:	fc 93       	st	X, r31
     p->a[p->top]=n;
    1956:	ee 0f       	add	r30, r30
    1958:	ff 1f       	adc	r31, r31
    195a:	ea 0d       	add	r30, r10
    195c:	fb 1d       	adc	r31, r11
    195e:	95 a7       	std	Z+45, r25	; 0x2d
    1960:	84 a7       	std	Z+44, r24	; 0x2c
		    if(link[j]%10==3)
			{	int z=checkarray(c[l-3],a);  a[z/10][z%10]=0;  push(&s,c[l-1]); push(&s,c[l-2]); }
		    if(link[j]%10==4)
			{	int z=checkarray(c[l-4],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);push(&s,c[l-2]);push(&s,c[l-3]);}
		    link[j]-=1;
		    int p = checkarray(TOP(s),a);
    1962:	d6 01       	movw	r26, r12
    1964:	f1 01       	movw	r30, r2
    1966:	8e e3       	ldi	r24, 0x3E	; 62
    1968:	01 90       	ld	r0, Z+
    196a:	0d 92       	st	X+, r0
    196c:	81 50       	subi	r24, 0x01	; 1
    196e:	e1 f7       	brne	.-8      	; 0x1968 <findshortpath_1+0x620>
         return 0;
      return 1;
}
int TOP(stack s)
{
 	return s.a[s.top];
    1970:	d6 01       	movw	r26, r12
    1972:	dc 96       	adiw	r26, 0x3c	; 60
    1974:	ed 91       	ld	r30, X+
    1976:	fc 91       	ld	r31, X
    1978:	dd 97       	sbiw	r26, 0x3d	; 61
    197a:	ee 0f       	add	r30, r30
    197c:	ff 1f       	adc	r31, r31
    197e:	ec 0d       	add	r30, r12
    1980:	fd 1d       	adc	r31, r13
    1982:	01 90       	ld	r0, Z+
    1984:	f0 81       	ld	r31, Z
    1986:	e0 2d       	mov	r30, r0
    1988:	b7 01       	movw	r22, r14
    198a:	20 e0       	ldi	r18, 0x00	; 0
    198c:	30 e0       	ldi	r19, 0x00	; 0
    198e:	26 c0       	rjmp	.+76     	; 0x19dc <findshortpath_1+0x694>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1990:	8d 91       	ld	r24, X+
    1992:	9c 91       	ld	r25, X
    1994:	11 97       	sbiw	r26, 0x01	; 1
    1996:	e8 17       	cp	r30, r24
    1998:	f9 07       	cpc	r31, r25
    199a:	99 f4       	brne	.+38     	; 0x19c2 <findshortpath_1+0x67a>
  				        { return 10*i+j;}
    199c:	f9 01       	movw	r30, r18
    199e:	93 e0       	ldi	r25, 0x03	; 3
    19a0:	ee 0f       	add	r30, r30
    19a2:	ff 1f       	adc	r31, r31
    19a4:	9a 95       	dec	r25
    19a6:	e1 f7       	brne	.-8      	; 0x19a0 <findshortpath_1+0x658>
    19a8:	22 0f       	add	r18, r18
    19aa:	33 1f       	adc	r19, r19
    19ac:	e2 0f       	add	r30, r18
    19ae:	f3 1f       	adc	r31, r19
    19b0:	e4 0f       	add	r30, r20
    19b2:	f5 1f       	adc	r31, r21
    19b4:	cd 56       	subi	r28, 0x6D	; 109
    19b6:	de 4f       	sbci	r29, 0xFE	; 254
    19b8:	f9 83       	std	Y+1, r31	; 0x01
    19ba:	e8 83       	st	Y, r30
    19bc:	c3 59       	subi	r28, 0x93	; 147
    19be:	d1 40       	sbci	r29, 0x01	; 1
    19c0:	11 c0       	rjmp	.+34     	; 0x19e4 <findshortpath_1+0x69c>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    19c2:	4f 5f       	subi	r20, 0xFF	; 255
    19c4:	5f 4f       	sbci	r21, 0xFF	; 255
    19c6:	12 96       	adiw	r26, 0x02	; 2
    19c8:	44 30       	cpi	r20, 0x04	; 4
    19ca:	51 05       	cpc	r21, r1
    19cc:	09 f7       	brne	.-62     	; 0x1990 <findshortpath_1+0x648>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    19ce:	2f 5f       	subi	r18, 0xFF	; 255
    19d0:	3f 4f       	sbci	r19, 0xFF	; 255
    19d2:	68 5f       	subi	r22, 0xF8	; 248
    19d4:	7f 4f       	sbci	r23, 0xFF	; 255
    19d6:	24 30       	cpi	r18, 0x04	; 4
    19d8:	31 05       	cpc	r19, r1
    19da:	21 f0       	breq	.+8      	; 0x19e4 <findshortpath_1+0x69c>
    19dc:	db 01       	movw	r26, r22
    19de:	40 e0       	ldi	r20, 0x00	; 0
    19e0:	50 e0       	ldi	r21, 0x00	; 0
    19e2:	d6 cf       	rjmp	.-84     	; 0x1990 <findshortpath_1+0x648>
			{	int z=checkarray(c[l-2],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);}
		    if(link[j]%10==3)
			{	int z=checkarray(c[l-3],a);  a[z/10][z%10]=0;  push(&s,c[l-1]); push(&s,c[l-2]); }
		    if(link[j]%10==4)
			{	int z=checkarray(c[l-4],a);  a[z/10][z%10]=0;  push(&s,c[l-1]);push(&s,c[l-2]);push(&s,c[l-3]);}
		    link[j]-=1;
    19e4:	c5 56       	subi	r28, 0x65	; 101
    19e6:	de 4f       	sbci	r29, 0xFE	; 254
    19e8:	e8 81       	ld	r30, Y
    19ea:	f9 81       	ldd	r31, Y+1	; 0x01
    19ec:	cb 59       	subi	r28, 0x9B	; 155
    19ee:	d1 40       	sbci	r29, 0x01	; 1
    19f0:	ee 0f       	add	r30, r30
    19f2:	ff 1f       	adc	r31, r31
    19f4:	25 e2       	ldi	r18, 0x25	; 37
    19f6:	31 e0       	ldi	r19, 0x01	; 1
    19f8:	2c 0f       	add	r18, r28
    19fa:	3d 1f       	adc	r19, r29
    19fc:	e2 0f       	add	r30, r18
    19fe:	f3 1f       	adc	r31, r19
    1a00:	08 94       	sec
    1a02:	41 08       	sbc	r4, r1
    1a04:	51 08       	sbc	r5, r1
    1a06:	51 82       	std	Z+1, r5	; 0x01
    1a08:	40 82       	st	Z, r4
		    int p = checkarray(TOP(s),a);
		    x=p/10; y=p%10;
    1a0a:	cd 56       	subi	r28, 0x6D	; 109
    1a0c:	de 4f       	sbci	r29, 0xFE	; 254
    1a0e:	88 81       	ld	r24, Y
    1a10:	99 81       	ldd	r25, Y+1	; 0x01
    1a12:	c3 59       	subi	r28, 0x93	; 147
    1a14:	d1 40       	sbci	r29, 0x01	; 1
    1a16:	6a e0       	ldi	r22, 0x0A	; 10
    1a18:	70 e0       	ldi	r23, 0x00	; 0
    1a1a:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1a1e:	70 93 f1 00 	sts	0x00F1, r23
    1a22:	60 93 f0 00 	sts	0x00F0, r22
    1a26:	cd 56       	subi	r28, 0x6D	; 109
    1a28:	de 4f       	sbci	r29, 0xFE	; 254
    1a2a:	88 81       	ld	r24, Y
    1a2c:	99 81       	ldd	r25, Y+1	; 0x01
    1a2e:	c3 59       	subi	r28, 0x93	; 147
    1a30:	d1 40       	sbci	r29, 0x01	; 1
    1a32:	55 c0       	rjmp	.+170    	; 0x1ade <findshortpath_1+0x796>
	   }
	   else
	   {    int b=TOP(s);
    1a34:	d6 01       	movw	r26, r12
    1a36:	f1 01       	movw	r30, r2
    1a38:	8e e3       	ldi	r24, 0x3E	; 62
    1a3a:	01 90       	ld	r0, Z+
    1a3c:	0d 92       	st	X+, r0
    1a3e:	81 50       	subi	r24, 0x01	; 1
    1a40:	e1 f7       	brne	.-8      	; 0x1a3a <findshortpath_1+0x6f2>
         return 0;
      return 1;
}
int TOP(stack s)
{
 	return s.a[s.top];
    1a42:	d6 01       	movw	r26, r12
    1a44:	dc 96       	adiw	r26, 0x3c	; 60
    1a46:	ed 91       	ld	r30, X+
    1a48:	fc 91       	ld	r31, X
    1a4a:	dd 97       	sbiw	r26, 0x3d	; 61
    1a4c:	ee 0f       	add	r30, r30
    1a4e:	ff 1f       	adc	r31, r31
    1a50:	ec 0d       	add	r30, r12
    1a52:	fd 1d       	adc	r31, r13
    1a54:	01 90       	ld	r0, Z+
    1a56:	f0 81       	ld	r31, Z
    1a58:	e0 2d       	mov	r30, r0
    1a5a:	b7 01       	movw	r22, r14
    1a5c:	20 e0       	ldi	r18, 0x00	; 0
    1a5e:	30 e0       	ldi	r19, 0x00	; 0
    1a60:	26 c0       	rjmp	.+76     	; 0x1aae <findshortpath_1+0x766>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1a62:	8d 91       	ld	r24, X+
    1a64:	9c 91       	ld	r25, X
    1a66:	11 97       	sbiw	r26, 0x01	; 1
    1a68:	e8 17       	cp	r30, r24
    1a6a:	f9 07       	cpc	r31, r25
    1a6c:	99 f4       	brne	.+38     	; 0x1a94 <findshortpath_1+0x74c>
  				        { return 10*i+j;}
    1a6e:	f9 01       	movw	r30, r18
    1a70:	b3 e0       	ldi	r27, 0x03	; 3
    1a72:	ee 0f       	add	r30, r30
    1a74:	ff 1f       	adc	r31, r31
    1a76:	ba 95       	dec	r27
    1a78:	e1 f7       	brne	.-8      	; 0x1a72 <findshortpath_1+0x72a>
    1a7a:	22 0f       	add	r18, r18
    1a7c:	33 1f       	adc	r19, r19
    1a7e:	e2 0f       	add	r30, r18
    1a80:	f3 1f       	adc	r31, r19
    1a82:	e4 0f       	add	r30, r20
    1a84:	f5 1f       	adc	r31, r21
    1a86:	cf 56       	subi	r28, 0x6F	; 111
    1a88:	de 4f       	sbci	r29, 0xFE	; 254
    1a8a:	f9 83       	std	Y+1, r31	; 0x01
    1a8c:	e8 83       	st	Y, r30
    1a8e:	c1 59       	subi	r28, 0x91	; 145
    1a90:	d1 40       	sbci	r29, 0x01	; 1
    1a92:	11 c0       	rjmp	.+34     	; 0x1ab6 <findshortpath_1+0x76e>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    1a94:	4f 5f       	subi	r20, 0xFF	; 255
    1a96:	5f 4f       	sbci	r21, 0xFF	; 255
    1a98:	12 96       	adiw	r26, 0x02	; 2
    1a9a:	44 30       	cpi	r20, 0x04	; 4
    1a9c:	51 05       	cpc	r21, r1
    1a9e:	09 f7       	brne	.-62     	; 0x1a62 <findshortpath_1+0x71a>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    1aa0:	2f 5f       	subi	r18, 0xFF	; 255
    1aa2:	3f 4f       	sbci	r19, 0xFF	; 255
    1aa4:	68 5f       	subi	r22, 0xF8	; 248
    1aa6:	7f 4f       	sbci	r23, 0xFF	; 255
    1aa8:	24 30       	cpi	r18, 0x04	; 4
    1aaa:	31 05       	cpc	r19, r1
    1aac:	21 f0       	breq	.+8      	; 0x1ab6 <findshortpath_1+0x76e>
    1aae:	db 01       	movw	r26, r22
    1ab0:	40 e0       	ldi	r20, 0x00	; 0
    1ab2:	50 e0       	ldi	r21, 0x00	; 0
    1ab4:	d6 cf       	rjmp	.-84     	; 0x1a62 <findshortpath_1+0x71a>
		    x=p/10; y=p%10;
	   }
	   else
	   {    int b=TOP(s);
            int q=checkarray(b,a);
	        x=q/10;y=q%10;
    1ab6:	cf 56       	subi	r28, 0x6F	; 111
    1ab8:	de 4f       	sbci	r29, 0xFE	; 254
    1aba:	88 81       	ld	r24, Y
    1abc:	99 81       	ldd	r25, Y+1	; 0x01
    1abe:	c1 59       	subi	r28, 0x91	; 145
    1ac0:	d1 40       	sbci	r29, 0x01	; 1
    1ac2:	6a e0       	ldi	r22, 0x0A	; 10
    1ac4:	70 e0       	ldi	r23, 0x00	; 0
    1ac6:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1aca:	70 93 f1 00 	sts	0x00F1, r23
    1ace:	60 93 f0 00 	sts	0x00F0, r22
    1ad2:	cf 56       	subi	r28, 0x6F	; 111
    1ad4:	de 4f       	sbci	r29, 0xFE	; 254
    1ad6:	88 81       	ld	r24, Y
    1ad8:	99 81       	ldd	r25, Y+1	; 0x01
    1ada:	c1 59       	subi	r28, 0x91	; 145
    1adc:	d1 40       	sbci	r29, 0x01	; 1
    1ade:	6a e0       	ldi	r22, 0x0A	; 10
    1ae0:	70 e0       	ldi	r23, 0x00	; 0
    1ae2:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1ae6:	90 93 f3 00 	sts	0x00F3, r25
    1aea:	80 93 f2 00 	sts	0x00F2, r24
       }
       if(TOP(s)==a[xx][yy]) break;
    1aee:	d6 01       	movw	r26, r12
    1af0:	f1 01       	movw	r30, r2
    1af2:	8e e3       	ldi	r24, 0x3E	; 62
    1af4:	01 90       	ld	r0, Z+
    1af6:	0d 92       	st	X+, r0
    1af8:	81 50       	subi	r24, 0x01	; 1
    1afa:	e1 f7       	brne	.-8      	; 0x1af4 <findshortpath_1+0x7ac>
    1afc:	f6 01       	movw	r30, r12
    1afe:	a4 ad       	ldd	r26, Z+60	; 0x3c
    1b00:	b5 ad       	ldd	r27, Z+61	; 0x3d
    1b02:	aa 0f       	add	r26, r26
    1b04:	bb 1f       	adc	r27, r27
    1b06:	ac 0d       	add	r26, r12
    1b08:	bd 1d       	adc	r27, r13
    1b0a:	e0 91 e2 00 	lds	r30, 0x00E2
    1b0e:	f0 91 e3 00 	lds	r31, 0x00E3
    1b12:	63 e0       	ldi	r22, 0x03	; 3
    1b14:	ee 0f       	add	r30, r30
    1b16:	ff 1f       	adc	r31, r31
    1b18:	6a 95       	dec	r22
    1b1a:	e1 f7       	brne	.-8      	; 0x1b14 <findshortpath_1+0x7cc>
    1b1c:	ee 0d       	add	r30, r14
    1b1e:	ff 1d       	adc	r31, r15
    1b20:	80 91 e4 00 	lds	r24, 0x00E4
    1b24:	90 91 e5 00 	lds	r25, 0x00E5
    1b28:	88 0f       	add	r24, r24
    1b2a:	99 1f       	adc	r25, r25
    1b2c:	e8 0f       	add	r30, r24
    1b2e:	f9 1f       	adc	r31, r25
    1b30:	2d 91       	ld	r18, X+
    1b32:	3c 91       	ld	r19, X
    1b34:	80 81       	ld	r24, Z
    1b36:	91 81       	ldd	r25, Z+1	; 0x01
    1b38:	28 17       	cp	r18, r24
    1b3a:	39 07       	cpc	r19, r25
    1b3c:	d1 f0       	breq	.+52     	; 0x1b72 <findshortpath_1+0x82a>
        k=0;
    1b3e:	1a 82       	std	Y+2, r1	; 0x02
    1b40:	19 82       	std	Y+1, r1	; 0x01
}
void findshortpath_1(int a[][4])
{
	stack s;stack t;stack path;int c[20];int k=0;int link[50]={0};int l;
 	s.top=-1;t.top=-1;path.top=-1;int j=-1;int i,n,u,q,g,w=0,v;
 	while(x!=xx || y!=yy)
    1b42:	60 91 f0 00 	lds	r22, 0x00F0
    1b46:	70 91 f1 00 	lds	r23, 0x00F1
    1b4a:	80 91 e2 00 	lds	r24, 0x00E2
    1b4e:	90 91 e3 00 	lds	r25, 0x00E3
    1b52:	68 17       	cp	r22, r24
    1b54:	79 07       	cpc	r23, r25
    1b56:	09 f0       	breq	.+2      	; 0x1b5a <findshortpath_1+0x812>
    1b58:	3c cc       	rjmp	.-1928   	; 0x13d2 <findshortpath_1+0x8a>
    1b5a:	20 91 f2 00 	lds	r18, 0x00F2
    1b5e:	30 91 f3 00 	lds	r19, 0x00F3
    1b62:	80 91 e4 00 	lds	r24, 0x00E4
    1b66:	90 91 e5 00 	lds	r25, 0x00E5
    1b6a:	28 17       	cp	r18, r24
    1b6c:	39 07       	cpc	r19, r25
    1b6e:	09 f0       	breq	.+2      	; 0x1b72 <findshortpath_1+0x82a>
    1b70:	30 cc       	rjmp	.-1952   	; 0x13d2 <findshortpath_1+0x8a>
       }
       if(TOP(s)==a[xx][yy]) break;
        k=0;
    }  
   //peep(s);
       g=s.top;
    1b72:	fe 01       	movw	r30, r28
    1b74:	e7 59       	subi	r30, 0x97	; 151
    1b76:	ff 4f       	sbci	r31, 0xFF	; 255
    1b78:	60 81       	ld	r22, Z
    1b7a:	71 81       	ldd	r23, Z+1	; 0x01
    1b7c:	cb 01       	movw	r24, r22
    1b7e:	20 e0       	ldi	r18, 0x00	; 0
    1b80:	30 e0       	ldi	r19, 0x00	; 0
    1b82:	0f ef       	ldi	r16, 0xFF	; 255
    1b84:	1f ef       	ldi	r17, 0xFF	; 255
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
 	     return 0;
     n=p->a[p->top];
    1b86:	6e 01       	movw	r12, r28
    1b88:	08 94       	sec
    1b8a:	c1 1c       	adc	r12, r1
    1b8c:	d1 1c       	adc	r13, r1
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
	     return;
     p->top++;
     p->a[p->top]=n;
    1b8e:	de 01       	movw	r26, r28
    1b90:	a5 59       	subi	r26, 0x95	; 149
    1b92:	bf 4f       	sbci	r27, 0xFF	; 255
    1b94:	1d c0       	rjmp	.+58     	; 0x1bd0 <findshortpath_1+0x888>
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    1b96:	ff ef       	ldi	r31, 0xFF	; 255
    1b98:	8f 3f       	cpi	r24, 0xFF	; 255
    1b9a:	9f 07       	cpc	r25, r31
    1b9c:	19 f4       	brne	.+6      	; 0x1ba4 <findshortpath_1+0x85c>
    1b9e:	40 e0       	ldi	r20, 0x00	; 0
    1ba0:	50 e0       	ldi	r21, 0x00	; 0
    1ba2:	08 c0       	rjmp	.+16     	; 0x1bb4 <findshortpath_1+0x86c>
 	     return 0;
     n=p->a[p->top];
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	ee 0f       	add	r30, r30
    1ba8:	ff 1f       	adc	r31, r31
    1baa:	ec 0d       	add	r30, r12
    1bac:	fd 1d       	adc	r31, r13
    1bae:	44 a5       	ldd	r20, Z+44	; 0x2c
    1bb0:	55 a5       	ldd	r21, Z+45	; 0x2d
     p->top--;
    1bb2:	01 97       	sbiw	r24, 0x01	; 1
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    1bb4:	0d 31       	cpi	r16, 0x1D	; 29
    1bb6:	11 05       	cpc	r17, r1
    1bb8:	49 f0       	breq	.+18     	; 0x1bcc <findshortpath_1+0x884>
	     return;
     p->top++;
    1bba:	0f 5f       	subi	r16, 0xFF	; 255
    1bbc:	1f 4f       	sbci	r17, 0xFF	; 255
     p->a[p->top]=n;
    1bbe:	f8 01       	movw	r30, r16
    1bc0:	ee 0f       	add	r30, r30
    1bc2:	ff 1f       	adc	r31, r31
    1bc4:	ea 0f       	add	r30, r26
    1bc6:	fb 1f       	adc	r31, r27
    1bc8:	51 83       	std	Z+1, r21	; 0x01
    1bca:	40 83       	st	Z, r20
       if(TOP(s)==a[xx][yy]) break;
        k=0;
    }  
   //peep(s);
       g=s.top;
       for(i=0;i<=g;i++)
    1bcc:	2f 5f       	subi	r18, 0xFF	; 255
    1bce:	3f 4f       	sbci	r19, 0xFF	; 255
    1bd0:	62 17       	cp	r22, r18
    1bd2:	73 07       	cpc	r23, r19
    1bd4:	04 f7       	brge	.-64     	; 0x1b96 <findshortpath_1+0x84e>
    1bd6:	c7 57       	subi	r28, 0x77	; 119
    1bd8:	de 4f       	sbci	r29, 0xFE	; 254
    1bda:	19 83       	std	Y+1, r17	; 0x01
    1bdc:	08 83       	st	Y, r16
    1bde:	c9 58       	subi	r28, 0x89	; 137
    1be0:	d1 40       	sbci	r29, 0x01	; 1
    1be2:	fe 01       	movw	r30, r28
    1be4:	e7 59       	subi	r30, 0x97	; 151
    1be6:	ff 4f       	sbci	r31, 0xFF	; 255
    1be8:	91 83       	std	Z+1, r25	; 0x01
    1bea:	80 83       	st	Z, r24
    1bec:	c5 57       	subi	r28, 0x75	; 117
    1bee:	de 4f       	sbci	r29, 0xFE	; 254
    1bf0:	19 82       	std	Y+1, r1	; 0x01
    1bf2:	18 82       	st	Y, r1
    1bf4:	cb 58       	subi	r28, 0x8B	; 139
    1bf6:	d1 40       	sbci	r29, 0x01	; 1
    1bf8:	cd c2       	rjmp	.+1434   	; 0x2194 <findshortpath_1+0xe4c>
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    1bfa:	2f ef       	ldi	r18, 0xFF	; 255
    1bfc:	0f 3f       	cpi	r16, 0xFF	; 255
    1bfe:	12 07       	cpc	r17, r18
    1c00:	19 f4       	brne	.+6      	; 0x1c08 <findshortpath_1+0x8c0>
    1c02:	a0 e0       	ldi	r26, 0x00	; 0
    1c04:	b0 e0       	ldi	r27, 0x00	; 0
    1c06:	0d c0       	rjmp	.+26     	; 0x1c22 <findshortpath_1+0x8da>
 	     return 0;
     n=p->a[p->top];
    1c08:	f8 01       	movw	r30, r16
    1c0a:	ee 0f       	add	r30, r30
    1c0c:	ff 1f       	adc	r31, r31
    1c0e:	8b e6       	ldi	r24, 0x6B	; 107
    1c10:	90 e0       	ldi	r25, 0x00	; 0
    1c12:	8c 0f       	add	r24, r28
    1c14:	9d 1f       	adc	r25, r29
    1c16:	e8 0f       	add	r30, r24
    1c18:	f9 1f       	adc	r31, r25
    1c1a:	a0 81       	ld	r26, Z
    1c1c:	b1 81       	ldd	r27, Z+1	; 0x01
     p->top--;
    1c1e:	01 50       	subi	r16, 0x01	; 1
    1c20:	10 40       	sbci	r17, 0x00	; 0
    1c22:	67 01       	movw	r12, r14
    1c24:	b7 01       	movw	r22, r14
    1c26:	20 e0       	ldi	r18, 0x00	; 0
    1c28:	30 e0       	ldi	r19, 0x00	; 0
    1c2a:	25 c0       	rjmp	.+74     	; 0x1c76 <findshortpath_1+0x92e>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1c2c:	80 81       	ld	r24, Z
    1c2e:	91 81       	ldd	r25, Z+1	; 0x01
    1c30:	a8 17       	cp	r26, r24
    1c32:	b9 07       	cpc	r27, r25
    1c34:	99 f4       	brne	.+38     	; 0x1c5c <findshortpath_1+0x914>
  				        { return 10*i+j;}
    1c36:	f9 01       	movw	r30, r18
    1c38:	63 e0       	ldi	r22, 0x03	; 3
    1c3a:	ee 0f       	add	r30, r30
    1c3c:	ff 1f       	adc	r31, r31
    1c3e:	6a 95       	dec	r22
    1c40:	e1 f7       	brne	.-8      	; 0x1c3a <findshortpath_1+0x8f2>
    1c42:	22 0f       	add	r18, r18
    1c44:	33 1f       	adc	r19, r19
    1c46:	e2 0f       	add	r30, r18
    1c48:	f3 1f       	adc	r31, r19
    1c4a:	e4 0f       	add	r30, r20
    1c4c:	f5 1f       	adc	r31, r21
    1c4e:	c1 57       	subi	r28, 0x71	; 113
    1c50:	de 4f       	sbci	r29, 0xFE	; 254
    1c52:	f9 83       	std	Y+1, r31	; 0x01
    1c54:	e8 83       	st	Y, r30
    1c56:	cf 58       	subi	r28, 0x8F	; 143
    1c58:	d1 40       	sbci	r29, 0x01	; 1
    1c5a:	11 c0       	rjmp	.+34     	; 0x1c7e <findshortpath_1+0x936>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    1c5c:	4f 5f       	subi	r20, 0xFF	; 255
    1c5e:	5f 4f       	sbci	r21, 0xFF	; 255
    1c60:	32 96       	adiw	r30, 0x02	; 2
    1c62:	44 30       	cpi	r20, 0x04	; 4
    1c64:	51 05       	cpc	r21, r1
    1c66:	11 f7       	brne	.-60     	; 0x1c2c <findshortpath_1+0x8e4>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    1c68:	2f 5f       	subi	r18, 0xFF	; 255
    1c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c6c:	68 5f       	subi	r22, 0xF8	; 248
    1c6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c70:	24 30       	cpi	r18, 0x04	; 4
    1c72:	31 05       	cpc	r19, r1
    1c74:	21 f0       	breq	.+8      	; 0x1c7e <findshortpath_1+0x936>
    1c76:	fb 01       	movw	r30, r22
    1c78:	40 e0       	ldi	r20, 0x00	; 0
    1c7a:	50 e0       	ldi	r21, 0x00	; 0
    1c7c:	d7 cf       	rjmp	.-82     	; 0x1c2c <findshortpath_1+0x8e4>
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    1c7e:	ab 96       	adiw	r28, 0x2b	; 43
    1c80:	ee ad       	ldd	r30, Y+62	; 0x3e
    1c82:	ff ad       	ldd	r31, Y+63	; 0x3f
    1c84:	ab 97       	sbiw	r28, 0x2b	; 43
    1c86:	ed 31       	cpi	r30, 0x1D	; 29
    1c88:	f1 05       	cpc	r31, r1
    1c8a:	79 f0       	breq	.+30     	; 0x1caa <findshortpath_1+0x962>
	     return;
     p->top++;
    1c8c:	31 96       	adiw	r30, 0x01	; 1
    1c8e:	ab 96       	adiw	r28, 0x2b	; 43
    1c90:	ff af       	std	Y+63, r31	; 0x3f
    1c92:	ee af       	std	Y+62, r30	; 0x3e
    1c94:	ab 97       	sbiw	r28, 0x2b	; 43
     p->a[p->top]=n;
    1c96:	ee 0f       	add	r30, r30
    1c98:	ff 1f       	adc	r31, r31
    1c9a:	21 e0       	ldi	r18, 0x01	; 1
    1c9c:	30 e0       	ldi	r19, 0x00	; 0
    1c9e:	2c 0f       	add	r18, r28
    1ca0:	3d 1f       	adc	r19, r29
    1ca2:	e2 0f       	add	r30, r18
    1ca4:	f3 1f       	adc	r31, r19
    1ca6:	b5 a7       	std	Z+45, r27	; 0x2d
    1ca8:	a4 a7       	std	Z+44, r26	; 0x2c
	   for(i=0;i<=g;i++)
       {    
	   		v=pop(&t);
            q=checkarray(v,a);
            push(&s,v);
             u=checkpoint(a,q,&w,s);
    1caa:	8d b7       	in	r24, 0x3d	; 61
    1cac:	9e b7       	in	r25, 0x3e	; 62
    1cae:	ce 97       	sbiw	r24, 0x3e	; 62
    1cb0:	0f b6       	in	r0, 0x3f	; 63
    1cb2:	f8 94       	cli
    1cb4:	9e bf       	out	0x3e, r25	; 62
    1cb6:	0f be       	out	0x3f, r0	; 63
    1cb8:	8d bf       	out	0x3d, r24	; 61
    1cba:	ad b7       	in	r26, 0x3d	; 61
    1cbc:	be b7       	in	r27, 0x3e	; 62
    1cbe:	11 96       	adiw	r26, 0x01	; 1
    1cc0:	fe 01       	movw	r30, r28
    1cc2:	bd 96       	adiw	r30, 0x2d	; 45
    1cc4:	8e e3       	ldi	r24, 0x3E	; 62
    1cc6:	01 90       	ld	r0, Z+
    1cc8:	0d 92       	st	X+, r0
    1cca:	81 50       	subi	r24, 0x01	; 1
    1ccc:	e1 f7       	brne	.-8      	; 0x1cc6 <findshortpath_1+0x97e>
    1cce:	c7 01       	movw	r24, r14
    1cd0:	c1 57       	subi	r28, 0x71	; 113
    1cd2:	de 4f       	sbci	r29, 0xFE	; 254
    1cd4:	68 81       	ld	r22, Y
    1cd6:	79 81       	ldd	r23, Y+1	; 0x01
    1cd8:	cf 58       	subi	r28, 0x8F	; 143
    1cda:	d1 40       	sbci	r29, 0x01	; 1
    1cdc:	ae 01       	movw	r20, r28
    1cde:	4d 5f       	subi	r20, 0xFD	; 253
    1ce0:	5f 4f       	sbci	r21, 0xFF	; 255
    1ce2:	0e 94 81 08 	call	0x1102	; 0x1102 <checkpoint>
    1ce6:	ac 01       	movw	r20, r24
            if(TOP(s)==a[xx][yy])      break;
    1ce8:	de 01       	movw	r26, r28
    1cea:	a9 51       	subi	r26, 0x19	; 25
    1cec:	bf 4f       	sbci	r27, 0xFF	; 255
    1cee:	fe 01       	movw	r30, r28
    1cf0:	bd 96       	adiw	r30, 0x2d	; 45
    1cf2:	8e e3       	ldi	r24, 0x3E	; 62
    1cf4:	01 90       	ld	r0, Z+
    1cf6:	0d 92       	st	X+, r0
    1cf8:	81 50       	subi	r24, 0x01	; 1
    1cfa:	e1 f7       	brne	.-8      	; 0x1cf4 <findshortpath_1+0x9ac>
    1cfc:	cd 5d       	subi	r28, 0xDD	; 221
    1cfe:	de 4f       	sbci	r29, 0xFE	; 254
    1d00:	a8 81       	ld	r26, Y
    1d02:	b9 81       	ldd	r27, Y+1	; 0x01
    1d04:	c3 52       	subi	r28, 0x23	; 35
    1d06:	d1 40       	sbci	r29, 0x01	; 1
    1d08:	aa 0f       	add	r26, r26
    1d0a:	bb 1f       	adc	r27, r27
    1d0c:	e7 ee       	ldi	r30, 0xE7	; 231
    1d0e:	f0 e0       	ldi	r31, 0x00	; 0
    1d10:	ec 0f       	add	r30, r28
    1d12:	fd 1f       	adc	r31, r29
    1d14:	ae 0f       	add	r26, r30
    1d16:	bf 1f       	adc	r27, r31
    1d18:	e0 91 e2 00 	lds	r30, 0x00E2
    1d1c:	f0 91 e3 00 	lds	r31, 0x00E3
    1d20:	63 e0       	ldi	r22, 0x03	; 3
    1d22:	ee 0f       	add	r30, r30
    1d24:	ff 1f       	adc	r31, r31
    1d26:	6a 95       	dec	r22
    1d28:	e1 f7       	brne	.-8      	; 0x1d22 <findshortpath_1+0x9da>
    1d2a:	ee 0d       	add	r30, r14
    1d2c:	ff 1d       	adc	r31, r15
    1d2e:	80 91 e4 00 	lds	r24, 0x00E4
    1d32:	90 91 e5 00 	lds	r25, 0x00E5
    1d36:	88 0f       	add	r24, r24
    1d38:	99 1f       	adc	r25, r25
    1d3a:	e8 0f       	add	r30, r24
    1d3c:	f9 1f       	adc	r31, r25
    1d3e:	2d b7       	in	r18, 0x3d	; 61
    1d40:	3e b7       	in	r19, 0x3e	; 62
    1d42:	22 5c       	subi	r18, 0xC2	; 194
    1d44:	3f 4f       	sbci	r19, 0xFF	; 255
    1d46:	0f b6       	in	r0, 0x3f	; 63
    1d48:	f8 94       	cli
    1d4a:	3e bf       	out	0x3e, r19	; 62
    1d4c:	0f be       	out	0x3f, r0	; 63
    1d4e:	2d bf       	out	0x3d, r18	; 61
    1d50:	2d 91       	ld	r18, X+
    1d52:	3c 91       	ld	r19, X
    1d54:	80 81       	ld	r24, Z
    1d56:	91 81       	ldd	r25, Z+1	; 0x01
    1d58:	28 17       	cp	r18, r24
    1d5a:	39 07       	cpc	r19, r25
    1d5c:	09 f4       	brne	.+2      	; 0x1d60 <findshortpath_1+0xa18>
    1d5e:	2a c2       	rjmp	.+1108   	; 0x21b4 <findshortpath_1+0xe6c>
            if(u==2)
    1d60:	42 30       	cpi	r20, 0x02	; 2
    1d62:	51 05       	cpc	r21, r1
    1d64:	09 f0       	breq	.+2      	; 0x1d68 <findshortpath_1+0xa20>
    1d66:	5d c0       	rjmp	.+186    	; 0x1e22 <findshortpath_1+0xada>
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    1d68:	3f ef       	ldi	r19, 0xFF	; 255
    1d6a:	0f 3f       	cpi	r16, 0xFF	; 255
    1d6c:	13 07       	cpc	r17, r19
    1d6e:	19 f4       	brne	.+6      	; 0x1d76 <findshortpath_1+0xa2e>
    1d70:	e0 e0       	ldi	r30, 0x00	; 0
    1d72:	f0 e0       	ldi	r31, 0x00	; 0
    1d74:	0e c0       	rjmp	.+28     	; 0x1d92 <findshortpath_1+0xa4a>
 	     return 0;
     n=p->a[p->top];
    1d76:	f8 01       	movw	r30, r16
    1d78:	ee 0f       	add	r30, r30
    1d7a:	ff 1f       	adc	r31, r31
    1d7c:	8b e6       	ldi	r24, 0x6B	; 107
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	8c 0f       	add	r24, r28
    1d82:	9d 1f       	adc	r25, r29
    1d84:	e8 0f       	add	r30, r24
    1d86:	f9 1f       	adc	r31, r25
    1d88:	01 90       	ld	r0, Z+
    1d8a:	f0 81       	ld	r31, Z
    1d8c:	e0 2d       	mov	r30, r0
     p->top--;
    1d8e:	01 50       	subi	r16, 0x01	; 1
    1d90:	10 40       	sbci	r17, 0x00	; 0
    1d92:	20 e0       	ldi	r18, 0x00	; 0
    1d94:	30 e0       	ldi	r19, 0x00	; 0
    1d96:	28 c0       	rjmp	.+80     	; 0x1de8 <findshortpath_1+0xaa0>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1d98:	8d 91       	ld	r24, X+
    1d9a:	9c 91       	ld	r25, X
    1d9c:	11 97       	sbiw	r26, 0x01	; 1
    1d9e:	e8 17       	cp	r30, r24
    1da0:	f9 07       	cpc	r31, r25
    1da2:	99 f4       	brne	.+38     	; 0x1dca <findshortpath_1+0xa82>
  				        { return 10*i+j;}
    1da4:	d9 01       	movw	r26, r18
    1da6:	93 e0       	ldi	r25, 0x03	; 3
    1da8:	aa 0f       	add	r26, r26
    1daa:	bb 1f       	adc	r27, r27
    1dac:	9a 95       	dec	r25
    1dae:	e1 f7       	brne	.-8      	; 0x1da8 <findshortpath_1+0xa60>
    1db0:	22 0f       	add	r18, r18
    1db2:	33 1f       	adc	r19, r19
    1db4:	a2 0f       	add	r26, r18
    1db6:	b3 1f       	adc	r27, r19
    1db8:	a4 0f       	add	r26, r20
    1dba:	b5 1f       	adc	r27, r21
    1dbc:	c3 57       	subi	r28, 0x73	; 115
    1dbe:	de 4f       	sbci	r29, 0xFE	; 254
    1dc0:	b9 83       	std	Y+1, r27	; 0x01
    1dc2:	a8 83       	st	Y, r26
    1dc4:	cd 58       	subi	r28, 0x8D	; 141
    1dc6:	d1 40       	sbci	r29, 0x01	; 1
    1dc8:	13 c0       	rjmp	.+38     	; 0x1df0 <findshortpath_1+0xaa8>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    1dca:	4f 5f       	subi	r20, 0xFF	; 255
    1dcc:	5f 4f       	sbci	r21, 0xFF	; 255
    1dce:	12 96       	adiw	r26, 0x02	; 2
    1dd0:	44 30       	cpi	r20, 0x04	; 4
    1dd2:	51 05       	cpc	r21, r1
    1dd4:	09 f7       	brne	.-62     	; 0x1d98 <findshortpath_1+0xa50>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    1dd6:	2f 5f       	subi	r18, 0xFF	; 255
    1dd8:	3f 4f       	sbci	r19, 0xFF	; 255
    1dda:	88 e0       	ldi	r24, 0x08	; 8
    1ddc:	90 e0       	ldi	r25, 0x00	; 0
    1dde:	c8 0e       	add	r12, r24
    1de0:	d9 1e       	adc	r13, r25
    1de2:	24 30       	cpi	r18, 0x04	; 4
    1de4:	31 05       	cpc	r19, r1
    1de6:	21 f0       	breq	.+8      	; 0x1df0 <findshortpath_1+0xaa8>
    1de8:	d6 01       	movw	r26, r12
    1dea:	40 e0       	ldi	r20, 0x00	; 0
    1dec:	50 e0       	ldi	r21, 0x00	; 0
    1dee:	d4 cf       	rjmp	.-88     	; 0x1d98 <findshortpath_1+0xa50>
            q=checkarray(v,a);
            push(&s,v);
             u=checkpoint(a,q,&w,s);
            if(TOP(s)==a[xx][yy])      break;
            if(u==2)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0; }
    1df0:	c3 57       	subi	r28, 0x73	; 115
    1df2:	de 4f       	sbci	r29, 0xFE	; 254
    1df4:	88 81       	ld	r24, Y
    1df6:	99 81       	ldd	r25, Y+1	; 0x01
    1df8:	cd 58       	subi	r28, 0x8D	; 141
    1dfa:	d1 40       	sbci	r29, 0x01	; 1
    1dfc:	6a e0       	ldi	r22, 0x0A	; 10
    1dfe:	70 e0       	ldi	r23, 0x00	; 0
    1e00:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1e04:	fb 01       	movw	r30, r22
    1e06:	b3 e0       	ldi	r27, 0x03	; 3
    1e08:	ee 0f       	add	r30, r30
    1e0a:	ff 1f       	adc	r31, r31
    1e0c:	ba 95       	dec	r27
    1e0e:	e1 f7       	brne	.-8      	; 0x1e08 <findshortpath_1+0xac0>
    1e10:	ee 0d       	add	r30, r14
    1e12:	ff 1d       	adc	r31, r15
    1e14:	c3 57       	subi	r28, 0x73	; 115
    1e16:	de 4f       	sbci	r29, 0xFE	; 254
    1e18:	88 81       	ld	r24, Y
    1e1a:	99 81       	ldd	r25, Y+1	; 0x01
    1e1c:	cd 58       	subi	r28, 0x8D	; 141
    1e1e:	d1 40       	sbci	r29, 0x01	; 1
    1e20:	a0 c1       	rjmp	.+832    	; 0x2162 <findshortpath_1+0xe1a>
	        if(u==3)
    1e22:	43 30       	cpi	r20, 0x03	; 3
    1e24:	51 05       	cpc	r21, r1
    1e26:	09 f0       	breq	.+2      	; 0x1e2a <findshortpath_1+0xae2>
    1e28:	a2 c0       	rjmp	.+324    	; 0x1f6e <findshortpath_1+0xc26>
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    1e2a:	9f ef       	ldi	r25, 0xFF	; 255
    1e2c:	0f 3f       	cpi	r16, 0xFF	; 255
    1e2e:	19 07       	cpc	r17, r25
    1e30:	19 f4       	brne	.+6      	; 0x1e38 <findshortpath_1+0xaf0>
    1e32:	e0 e0       	ldi	r30, 0x00	; 0
    1e34:	f0 e0       	ldi	r31, 0x00	; 0
    1e36:	0e c0       	rjmp	.+28     	; 0x1e54 <findshortpath_1+0xb0c>
 	     return 0;
     n=p->a[p->top];
    1e38:	f8 01       	movw	r30, r16
    1e3a:	ee 0f       	add	r30, r30
    1e3c:	ff 1f       	adc	r31, r31
    1e3e:	ab e6       	ldi	r26, 0x6B	; 107
    1e40:	b0 e0       	ldi	r27, 0x00	; 0
    1e42:	ac 0f       	add	r26, r28
    1e44:	bd 1f       	adc	r27, r29
    1e46:	ea 0f       	add	r30, r26
    1e48:	fb 1f       	adc	r31, r27
    1e4a:	01 90       	ld	r0, Z+
    1e4c:	f0 81       	ld	r31, Z
    1e4e:	e0 2d       	mov	r30, r0
     p->top--;
    1e50:	01 50       	subi	r16, 0x01	; 1
    1e52:	10 40       	sbci	r17, 0x00	; 0
    1e54:	b7 01       	movw	r22, r14
    1e56:	20 e0       	ldi	r18, 0x00	; 0
    1e58:	30 e0       	ldi	r19, 0x00	; 0
    1e5a:	20 c0       	rjmp	.+64     	; 0x1e9c <findshortpath_1+0xb54>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1e5c:	8d 91       	ld	r24, X+
    1e5e:	9c 91       	ld	r25, X
    1e60:	11 97       	sbiw	r26, 0x01	; 1
    1e62:	e8 17       	cp	r30, r24
    1e64:	f9 07       	cpc	r31, r25
    1e66:	69 f4       	brne	.+26     	; 0x1e82 <findshortpath_1+0xb3a>
  				        { return 10*i+j;}
    1e68:	19 01       	movw	r2, r18
    1e6a:	73 e0       	ldi	r23, 0x03	; 3
    1e6c:	22 0c       	add	r2, r2
    1e6e:	33 1c       	adc	r3, r3
    1e70:	7a 95       	dec	r23
    1e72:	e1 f7       	brne	.-8      	; 0x1e6c <findshortpath_1+0xb24>
    1e74:	22 0f       	add	r18, r18
    1e76:	33 1f       	adc	r19, r19
    1e78:	22 0e       	add	r2, r18
    1e7a:	33 1e       	adc	r3, r19
    1e7c:	24 0e       	add	r2, r20
    1e7e:	35 1e       	adc	r3, r21
    1e80:	11 c0       	rjmp	.+34     	; 0x1ea4 <findshortpath_1+0xb5c>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    1e82:	4f 5f       	subi	r20, 0xFF	; 255
    1e84:	5f 4f       	sbci	r21, 0xFF	; 255
    1e86:	12 96       	adiw	r26, 0x02	; 2
    1e88:	44 30       	cpi	r20, 0x04	; 4
    1e8a:	51 05       	cpc	r21, r1
    1e8c:	39 f7       	brne	.-50     	; 0x1e5c <findshortpath_1+0xb14>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    1e8e:	2f 5f       	subi	r18, 0xFF	; 255
    1e90:	3f 4f       	sbci	r19, 0xFF	; 255
    1e92:	68 5f       	subi	r22, 0xF8	; 248
    1e94:	7f 4f       	sbci	r23, 0xFF	; 255
    1e96:	24 30       	cpi	r18, 0x04	; 4
    1e98:	31 05       	cpc	r19, r1
    1e9a:	21 f0       	breq	.+8      	; 0x1ea4 <findshortpath_1+0xb5c>
    1e9c:	db 01       	movw	r26, r22
    1e9e:	40 e0       	ldi	r20, 0x00	; 0
    1ea0:	50 e0       	ldi	r21, 0x00	; 0
    1ea2:	dc cf       	rjmp	.-72     	; 0x1e5c <findshortpath_1+0xb14>
             u=checkpoint(a,q,&w,s);
            if(TOP(s)==a[xx][yy])      break;
            if(u==2)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0; }
	        if(u==3)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
    1ea4:	c1 01       	movw	r24, r2
    1ea6:	6a e0       	ldi	r22, 0x0A	; 10
    1ea8:	70 e0       	ldi	r23, 0x00	; 0
    1eaa:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1eae:	fb 01       	movw	r30, r22
    1eb0:	33 e0       	ldi	r19, 0x03	; 3
    1eb2:	ee 0f       	add	r30, r30
    1eb4:	ff 1f       	adc	r31, r31
    1eb6:	3a 95       	dec	r19
    1eb8:	e1 f7       	brne	.-8      	; 0x1eb2 <findshortpath_1+0xb6a>
    1eba:	ee 0d       	add	r30, r14
    1ebc:	ff 1d       	adc	r31, r15
    1ebe:	c1 01       	movw	r24, r2
    1ec0:	6a e0       	ldi	r22, 0x0A	; 10
    1ec2:	70 e0       	ldi	r23, 0x00	; 0
    1ec4:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1ec8:	88 0f       	add	r24, r24
    1eca:	99 1f       	adc	r25, r25
    1ecc:	e8 0f       	add	r30, r24
    1ece:	f9 1f       	adc	r31, r25
    1ed0:	11 82       	std	Z+1, r1	; 0x01
    1ed2:	10 82       	st	Z, r1
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    1ed4:	bf ef       	ldi	r27, 0xFF	; 255
    1ed6:	0f 3f       	cpi	r16, 0xFF	; 255
    1ed8:	1b 07       	cpc	r17, r27
    1eda:	19 f4       	brne	.+6      	; 0x1ee2 <findshortpath_1+0xb9a>
    1edc:	e0 e0       	ldi	r30, 0x00	; 0
    1ede:	f0 e0       	ldi	r31, 0x00	; 0
    1ee0:	0e c0       	rjmp	.+28     	; 0x1efe <findshortpath_1+0xbb6>
 	     return 0;
     n=p->a[p->top];
    1ee2:	f8 01       	movw	r30, r16
    1ee4:	ee 0f       	add	r30, r30
    1ee6:	ff 1f       	adc	r31, r31
    1ee8:	2b e6       	ldi	r18, 0x6B	; 107
    1eea:	30 e0       	ldi	r19, 0x00	; 0
    1eec:	2c 0f       	add	r18, r28
    1eee:	3d 1f       	adc	r19, r29
    1ef0:	e2 0f       	add	r30, r18
    1ef2:	f3 1f       	adc	r31, r19
    1ef4:	01 90       	ld	r0, Z+
    1ef6:	f0 81       	ld	r31, Z
    1ef8:	e0 2d       	mov	r30, r0
     p->top--;
    1efa:	01 50       	subi	r16, 0x01	; 1
    1efc:	10 40       	sbci	r17, 0x00	; 0
    1efe:	20 e0       	ldi	r18, 0x00	; 0
    1f00:	30 e0       	ldi	r19, 0x00	; 0
    1f02:	22 c0       	rjmp	.+68     	; 0x1f48 <findshortpath_1+0xc00>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1f04:	8d 91       	ld	r24, X+
    1f06:	9c 91       	ld	r25, X
    1f08:	11 97       	sbiw	r26, 0x01	; 1
    1f0a:	e8 17       	cp	r30, r24
    1f0c:	f9 07       	cpc	r31, r25
    1f0e:	69 f4       	brne	.+26     	; 0x1f2a <findshortpath_1+0xbe2>
  				        { return 10*i+j;}
    1f10:	29 01       	movw	r4, r18
    1f12:	83 e0       	ldi	r24, 0x03	; 3
    1f14:	44 0c       	add	r4, r4
    1f16:	55 1c       	adc	r5, r5
    1f18:	8a 95       	dec	r24
    1f1a:	e1 f7       	brne	.-8      	; 0x1f14 <findshortpath_1+0xbcc>
    1f1c:	22 0f       	add	r18, r18
    1f1e:	33 1f       	adc	r19, r19
    1f20:	42 0e       	add	r4, r18
    1f22:	53 1e       	adc	r5, r19
    1f24:	44 0e       	add	r4, r20
    1f26:	55 1e       	adc	r5, r21
    1f28:	13 c0       	rjmp	.+38     	; 0x1f50 <findshortpath_1+0xc08>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    1f2a:	4f 5f       	subi	r20, 0xFF	; 255
    1f2c:	5f 4f       	sbci	r21, 0xFF	; 255
    1f2e:	12 96       	adiw	r26, 0x02	; 2
    1f30:	44 30       	cpi	r20, 0x04	; 4
    1f32:	51 05       	cpc	r21, r1
    1f34:	39 f7       	brne	.-50     	; 0x1f04 <findshortpath_1+0xbbc>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    1f36:	2f 5f       	subi	r18, 0xFF	; 255
    1f38:	3f 4f       	sbci	r19, 0xFF	; 255
    1f3a:	88 e0       	ldi	r24, 0x08	; 8
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	c8 0e       	add	r12, r24
    1f40:	d9 1e       	adc	r13, r25
    1f42:	24 30       	cpi	r18, 0x04	; 4
    1f44:	31 05       	cpc	r19, r1
    1f46:	21 f0       	breq	.+8      	; 0x1f50 <findshortpath_1+0xc08>
    1f48:	d6 01       	movw	r26, r12
    1f4a:	40 e0       	ldi	r20, 0x00	; 0
    1f4c:	50 e0       	ldi	r21, 0x00	; 0
    1f4e:	da cf       	rjmp	.-76     	; 0x1f04 <findshortpath_1+0xbbc>
            if(TOP(s)==a[xx][yy])      break;
            if(u==2)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0; }
	        if(u==3)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
             n=checkarray(pop(&t),a);  a[n/10][n%10]=0;	}
    1f50:	c2 01       	movw	r24, r4
    1f52:	6a e0       	ldi	r22, 0x0A	; 10
    1f54:	70 e0       	ldi	r23, 0x00	; 0
    1f56:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1f5a:	fb 01       	movw	r30, r22
    1f5c:	a3 e0       	ldi	r26, 0x03	; 3
    1f5e:	ee 0f       	add	r30, r30
    1f60:	ff 1f       	adc	r31, r31
    1f62:	aa 95       	dec	r26
    1f64:	e1 f7       	brne	.-8      	; 0x1f5e <findshortpath_1+0xc16>
    1f66:	ee 0d       	add	r30, r14
    1f68:	ff 1d       	adc	r31, r15
    1f6a:	c2 01       	movw	r24, r4
    1f6c:	fa c0       	rjmp	.+500    	; 0x2162 <findshortpath_1+0xe1a>
			if(u==4)
    1f6e:	44 30       	cpi	r20, 0x04	; 4
    1f70:	51 05       	cpc	r21, r1
    1f72:	09 f0       	breq	.+2      	; 0x1f76 <findshortpath_1+0xc2e>
    1f74:	00 c1       	rjmp	.+512    	; 0x2176 <findshortpath_1+0xe2e>
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    1f76:	9f ef       	ldi	r25, 0xFF	; 255
    1f78:	0f 3f       	cpi	r16, 0xFF	; 255
    1f7a:	19 07       	cpc	r17, r25
    1f7c:	19 f4       	brne	.+6      	; 0x1f84 <findshortpath_1+0xc3c>
    1f7e:	e0 e0       	ldi	r30, 0x00	; 0
    1f80:	f0 e0       	ldi	r31, 0x00	; 0
    1f82:	0e c0       	rjmp	.+28     	; 0x1fa0 <findshortpath_1+0xc58>
 	     return 0;
     n=p->a[p->top];
    1f84:	f8 01       	movw	r30, r16
    1f86:	ee 0f       	add	r30, r30
    1f88:	ff 1f       	adc	r31, r31
    1f8a:	ab e6       	ldi	r26, 0x6B	; 107
    1f8c:	b0 e0       	ldi	r27, 0x00	; 0
    1f8e:	ac 0f       	add	r26, r28
    1f90:	bd 1f       	adc	r27, r29
    1f92:	ea 0f       	add	r30, r26
    1f94:	fb 1f       	adc	r31, r27
    1f96:	01 90       	ld	r0, Z+
    1f98:	f0 81       	ld	r31, Z
    1f9a:	e0 2d       	mov	r30, r0
     p->top--;
    1f9c:	01 50       	subi	r16, 0x01	; 1
    1f9e:	10 40       	sbci	r17, 0x00	; 0
    1fa0:	b7 01       	movw	r22, r14
    1fa2:	20 e0       	ldi	r18, 0x00	; 0
    1fa4:	30 e0       	ldi	r19, 0x00	; 0
    1fa6:	20 c0       	rjmp	.+64     	; 0x1fe8 <findshortpath_1+0xca0>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    1fa8:	8d 91       	ld	r24, X+
    1faa:	9c 91       	ld	r25, X
    1fac:	11 97       	sbiw	r26, 0x01	; 1
    1fae:	e8 17       	cp	r30, r24
    1fb0:	f9 07       	cpc	r31, r25
    1fb2:	69 f4       	brne	.+26     	; 0x1fce <findshortpath_1+0xc86>
  				        { return 10*i+j;}
    1fb4:	39 01       	movw	r6, r18
    1fb6:	63 e0       	ldi	r22, 0x03	; 3
    1fb8:	66 0c       	add	r6, r6
    1fba:	77 1c       	adc	r7, r7
    1fbc:	6a 95       	dec	r22
    1fbe:	e1 f7       	brne	.-8      	; 0x1fb8 <findshortpath_1+0xc70>
    1fc0:	22 0f       	add	r18, r18
    1fc2:	33 1f       	adc	r19, r19
    1fc4:	62 0e       	add	r6, r18
    1fc6:	73 1e       	adc	r7, r19
    1fc8:	64 0e       	add	r6, r20
    1fca:	75 1e       	adc	r7, r21
    1fcc:	11 c0       	rjmp	.+34     	; 0x1ff0 <findshortpath_1+0xca8>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    1fce:	4f 5f       	subi	r20, 0xFF	; 255
    1fd0:	5f 4f       	sbci	r21, 0xFF	; 255
    1fd2:	12 96       	adiw	r26, 0x02	; 2
    1fd4:	44 30       	cpi	r20, 0x04	; 4
    1fd6:	51 05       	cpc	r21, r1
    1fd8:	39 f7       	brne	.-50     	; 0x1fa8 <findshortpath_1+0xc60>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    1fda:	2f 5f       	subi	r18, 0xFF	; 255
    1fdc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fde:	68 5f       	subi	r22, 0xF8	; 248
    1fe0:	7f 4f       	sbci	r23, 0xFF	; 255
    1fe2:	24 30       	cpi	r18, 0x04	; 4
    1fe4:	31 05       	cpc	r19, r1
    1fe6:	21 f0       	breq	.+8      	; 0x1ff0 <findshortpath_1+0xca8>
    1fe8:	db 01       	movw	r26, r22
    1fea:	40 e0       	ldi	r20, 0x00	; 0
    1fec:	50 e0       	ldi	r21, 0x00	; 0
    1fee:	dc cf       	rjmp	.-72     	; 0x1fa8 <findshortpath_1+0xc60>
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0; }
	        if(u==3)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
             n=checkarray(pop(&t),a);  a[n/10][n%10]=0;	}
			if(u==4)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
    1ff0:	c3 01       	movw	r24, r6
    1ff2:	6a e0       	ldi	r22, 0x0A	; 10
    1ff4:	70 e0       	ldi	r23, 0x00	; 0
    1ff6:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    1ffa:	fb 01       	movw	r30, r22
    1ffc:	83 e0       	ldi	r24, 0x03	; 3
    1ffe:	ee 0f       	add	r30, r30
    2000:	ff 1f       	adc	r31, r31
    2002:	8a 95       	dec	r24
    2004:	e1 f7       	brne	.-8      	; 0x1ffe <findshortpath_1+0xcb6>
    2006:	ee 0d       	add	r30, r14
    2008:	ff 1d       	adc	r31, r15
    200a:	c3 01       	movw	r24, r6
    200c:	6a e0       	ldi	r22, 0x0A	; 10
    200e:	70 e0       	ldi	r23, 0x00	; 0
    2010:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    2014:	88 0f       	add	r24, r24
    2016:	99 1f       	adc	r25, r25
    2018:	e8 0f       	add	r30, r24
    201a:	f9 1f       	adc	r31, r25
    201c:	11 82       	std	Z+1, r1	; 0x01
    201e:	10 82       	st	Z, r1
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    2020:	bf ef       	ldi	r27, 0xFF	; 255
    2022:	0f 3f       	cpi	r16, 0xFF	; 255
    2024:	1b 07       	cpc	r17, r27
    2026:	19 f4       	brne	.+6      	; 0x202e <findshortpath_1+0xce6>
    2028:	e0 e0       	ldi	r30, 0x00	; 0
    202a:	f0 e0       	ldi	r31, 0x00	; 0
    202c:	0e c0       	rjmp	.+28     	; 0x204a <findshortpath_1+0xd02>
 	     return 0;
     n=p->a[p->top];
    202e:	f8 01       	movw	r30, r16
    2030:	ee 0f       	add	r30, r30
    2032:	ff 1f       	adc	r31, r31
    2034:	2b e6       	ldi	r18, 0x6B	; 107
    2036:	30 e0       	ldi	r19, 0x00	; 0
    2038:	2c 0f       	add	r18, r28
    203a:	3d 1f       	adc	r19, r29
    203c:	e2 0f       	add	r30, r18
    203e:	f3 1f       	adc	r31, r19
    2040:	01 90       	ld	r0, Z+
    2042:	f0 81       	ld	r31, Z
    2044:	e0 2d       	mov	r30, r0
     p->top--;
    2046:	01 50       	subi	r16, 0x01	; 1
    2048:	10 40       	sbci	r17, 0x00	; 0
    204a:	b7 01       	movw	r22, r14
    204c:	20 e0       	ldi	r18, 0x00	; 0
    204e:	30 e0       	ldi	r19, 0x00	; 0
    2050:	20 c0       	rjmp	.+64     	; 0x2092 <findshortpath_1+0xd4a>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    2052:	8d 91       	ld	r24, X+
    2054:	9c 91       	ld	r25, X
    2056:	11 97       	sbiw	r26, 0x01	; 1
    2058:	e8 17       	cp	r30, r24
    205a:	f9 07       	cpc	r31, r25
    205c:	69 f4       	brne	.+26     	; 0x2078 <findshortpath_1+0xd30>
  				        { return 10*i+j;}
    205e:	49 01       	movw	r8, r18
    2060:	73 e0       	ldi	r23, 0x03	; 3
    2062:	88 0c       	add	r8, r8
    2064:	99 1c       	adc	r9, r9
    2066:	7a 95       	dec	r23
    2068:	e1 f7       	brne	.-8      	; 0x2062 <findshortpath_1+0xd1a>
    206a:	22 0f       	add	r18, r18
    206c:	33 1f       	adc	r19, r19
    206e:	82 0e       	add	r8, r18
    2070:	93 1e       	adc	r9, r19
    2072:	84 0e       	add	r8, r20
    2074:	95 1e       	adc	r9, r21
    2076:	11 c0       	rjmp	.+34     	; 0x209a <findshortpath_1+0xd52>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    2078:	4f 5f       	subi	r20, 0xFF	; 255
    207a:	5f 4f       	sbci	r21, 0xFF	; 255
    207c:	12 96       	adiw	r26, 0x02	; 2
    207e:	44 30       	cpi	r20, 0x04	; 4
    2080:	51 05       	cpc	r21, r1
    2082:	39 f7       	brne	.-50     	; 0x2052 <findshortpath_1+0xd0a>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    2084:	2f 5f       	subi	r18, 0xFF	; 255
    2086:	3f 4f       	sbci	r19, 0xFF	; 255
    2088:	68 5f       	subi	r22, 0xF8	; 248
    208a:	7f 4f       	sbci	r23, 0xFF	; 255
    208c:	24 30       	cpi	r18, 0x04	; 4
    208e:	31 05       	cpc	r19, r1
    2090:	21 f0       	breq	.+8      	; 0x209a <findshortpath_1+0xd52>
    2092:	db 01       	movw	r26, r22
    2094:	40 e0       	ldi	r20, 0x00	; 0
    2096:	50 e0       	ldi	r21, 0x00	; 0
    2098:	dc cf       	rjmp	.-72     	; 0x2052 <findshortpath_1+0xd0a>
	        if(u==3)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
             n=checkarray(pop(&t),a);  a[n/10][n%10]=0;	}
			if(u==4)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
			 n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
    209a:	c4 01       	movw	r24, r8
    209c:	6a e0       	ldi	r22, 0x0A	; 10
    209e:	70 e0       	ldi	r23, 0x00	; 0
    20a0:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    20a4:	fb 01       	movw	r30, r22
    20a6:	33 e0       	ldi	r19, 0x03	; 3
    20a8:	ee 0f       	add	r30, r30
    20aa:	ff 1f       	adc	r31, r31
    20ac:	3a 95       	dec	r19
    20ae:	e1 f7       	brne	.-8      	; 0x20a8 <findshortpath_1+0xd60>
    20b0:	ee 0d       	add	r30, r14
    20b2:	ff 1d       	adc	r31, r15
    20b4:	c4 01       	movw	r24, r8
    20b6:	6a e0       	ldi	r22, 0x0A	; 10
    20b8:	70 e0       	ldi	r23, 0x00	; 0
    20ba:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    20be:	88 0f       	add	r24, r24
    20c0:	99 1f       	adc	r25, r25
    20c2:	e8 0f       	add	r30, r24
    20c4:	f9 1f       	adc	r31, r25
    20c6:	11 82       	std	Z+1, r1	; 0x01
    20c8:	10 82       	st	Z, r1
     p->a[p->top]=n;
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    20ca:	3f ef       	ldi	r19, 0xFF	; 255
    20cc:	0f 3f       	cpi	r16, 0xFF	; 255
    20ce:	13 07       	cpc	r17, r19
    20d0:	19 f4       	brne	.+6      	; 0x20d8 <findshortpath_1+0xd90>
    20d2:	e0 e0       	ldi	r30, 0x00	; 0
    20d4:	f0 e0       	ldi	r31, 0x00	; 0
    20d6:	0e c0       	rjmp	.+28     	; 0x20f4 <findshortpath_1+0xdac>
 	     return 0;
     n=p->a[p->top];
    20d8:	f8 01       	movw	r30, r16
    20da:	ee 0f       	add	r30, r30
    20dc:	ff 1f       	adc	r31, r31
    20de:	8b e6       	ldi	r24, 0x6B	; 107
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	8c 0f       	add	r24, r28
    20e4:	9d 1f       	adc	r25, r29
    20e6:	e8 0f       	add	r30, r24
    20e8:	f9 1f       	adc	r31, r25
    20ea:	01 90       	ld	r0, Z+
    20ec:	f0 81       	ld	r31, Z
    20ee:	e0 2d       	mov	r30, r0
     p->top--;
    20f0:	01 50       	subi	r16, 0x01	; 1
    20f2:	10 40       	sbci	r17, 0x00	; 0
    20f4:	20 e0       	ldi	r18, 0x00	; 0
    20f6:	30 e0       	ldi	r19, 0x00	; 0
    20f8:	22 c0       	rjmp	.+68     	; 0x213e <findshortpath_1+0xdf6>
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
		  	 {    if(n==p[i][j])
    20fa:	8d 91       	ld	r24, X+
    20fc:	9c 91       	ld	r25, X
    20fe:	11 97       	sbiw	r26, 0x01	; 1
    2100:	e8 17       	cp	r30, r24
    2102:	f9 07       	cpc	r31, r25
    2104:	69 f4       	brne	.+26     	; 0x2120 <findshortpath_1+0xdd8>
  				        { return 10*i+j;}
    2106:	59 01       	movw	r10, r18
    2108:	83 e0       	ldi	r24, 0x03	; 3
    210a:	aa 0c       	add	r10, r10
    210c:	bb 1c       	adc	r11, r11
    210e:	8a 95       	dec	r24
    2110:	e1 f7       	brne	.-8      	; 0x210a <findshortpath_1+0xdc2>
    2112:	22 0f       	add	r18, r18
    2114:	33 1f       	adc	r19, r19
    2116:	a2 0e       	add	r10, r18
    2118:	b3 1e       	adc	r11, r19
    211a:	a4 0e       	add	r10, r20
    211c:	b5 1e       	adc	r11, r21
    211e:	13 c0       	rjmp	.+38     	; 0x2146 <findshortpath_1+0xdfe>
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
	 {		 for(j=0;j<4;j++)
    2120:	4f 5f       	subi	r20, 0xFF	; 255
    2122:	5f 4f       	sbci	r21, 0xFF	; 255
    2124:	12 96       	adiw	r26, 0x02	; 2
    2126:	44 30       	cpi	r20, 0x04	; 4
    2128:	51 05       	cpc	r21, r1
    212a:	39 f7       	brne	.-50     	; 0x20fa <findshortpath_1+0xdb2>
         push(p,n);*d=*d+1;
     }
}
int checkarray(int n,int p[][4])
{  int i,j;
	 for(i=0;i<4;i++)
    212c:	2f 5f       	subi	r18, 0xFF	; 255
    212e:	3f 4f       	sbci	r19, 0xFF	; 255
    2130:	a8 e0       	ldi	r26, 0x08	; 8
    2132:	b0 e0       	ldi	r27, 0x00	; 0
    2134:	ca 0e       	add	r12, r26
    2136:	db 1e       	adc	r13, r27
    2138:	24 30       	cpi	r18, 0x04	; 4
    213a:	31 05       	cpc	r19, r1
    213c:	21 f0       	breq	.+8      	; 0x2146 <findshortpath_1+0xdfe>
    213e:	d6 01       	movw	r26, r12
    2140:	40 e0       	ldi	r20, 0x00	; 0
    2142:	50 e0       	ldi	r21, 0x00	; 0
    2144:	da cf       	rjmp	.-76     	; 0x20fa <findshortpath_1+0xdb2>
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
             n=checkarray(pop(&t),a);  a[n/10][n%10]=0;	}
			if(u==4)
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
			 n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
			 n=checkarray(pop(&t),a);  a[n/10][n%10]=0; }
    2146:	c5 01       	movw	r24, r10
    2148:	6a e0       	ldi	r22, 0x0A	; 10
    214a:	70 e0       	ldi	r23, 0x00	; 0
    214c:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    2150:	fb 01       	movw	r30, r22
    2152:	a3 e0       	ldi	r26, 0x03	; 3
    2154:	ee 0f       	add	r30, r30
    2156:	ff 1f       	adc	r31, r31
    2158:	aa 95       	dec	r26
    215a:	e1 f7       	brne	.-8      	; 0x2154 <findshortpath_1+0xe0c>
    215c:	ee 0d       	add	r30, r14
    215e:	ff 1d       	adc	r31, r15
    2160:	c5 01       	movw	r24, r10
    2162:	6a e0       	ldi	r22, 0x0A	; 10
    2164:	70 e0       	ldi	r23, 0x00	; 0
    2166:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__divmodhi4>
    216a:	88 0f       	add	r24, r24
    216c:	99 1f       	adc	r25, r25
    216e:	e8 0f       	add	r30, r24
    2170:	f9 1f       	adc	r31, r25
    2172:	11 82       	std	Z+1, r1	; 0x01
    2174:	10 82       	st	Z, r1
            w=0;
    2176:	1c 82       	std	Y+4, r1	; 0x04
    2178:	1b 82       	std	Y+3, r1	; 0x03
   //peep(s);
       g=s.top;
       for(i=0;i<=g;i++)
       {v=pop(&s);    push(&t,v);}
	   g=t.top;
	   for(i=0;i<=g;i++)
    217a:	c5 57       	subi	r28, 0x75	; 117
    217c:	de 4f       	sbci	r29, 0xFE	; 254
    217e:	e8 81       	ld	r30, Y
    2180:	f9 81       	ldd	r31, Y+1	; 0x01
    2182:	cb 58       	subi	r28, 0x8B	; 139
    2184:	d1 40       	sbci	r29, 0x01	; 1
    2186:	31 96       	adiw	r30, 0x01	; 1
    2188:	c5 57       	subi	r28, 0x75	; 117
    218a:	de 4f       	sbci	r29, 0xFE	; 254
    218c:	f9 83       	std	Y+1, r31	; 0x01
    218e:	e8 83       	st	Y, r30
    2190:	cb 58       	subi	r28, 0x8B	; 139
    2192:	d1 40       	sbci	r29, 0x01	; 1
    2194:	c5 57       	subi	r28, 0x75	; 117
    2196:	de 4f       	sbci	r29, 0xFE	; 254
    2198:	28 81       	ld	r18, Y
    219a:	39 81       	ldd	r19, Y+1	; 0x01
    219c:	cb 58       	subi	r28, 0x8B	; 139
    219e:	d1 40       	sbci	r29, 0x01	; 1
    21a0:	c7 57       	subi	r28, 0x77	; 119
    21a2:	de 4f       	sbci	r29, 0xFE	; 254
    21a4:	88 81       	ld	r24, Y
    21a6:	99 81       	ldd	r25, Y+1	; 0x01
    21a8:	c9 58       	subi	r28, 0x89	; 137
    21aa:	d1 40       	sbci	r29, 0x01	; 1
    21ac:	82 17       	cp	r24, r18
    21ae:	93 07       	cpc	r25, r19
    21b0:	0c f0       	brlt	.+2      	; 0x21b4 <findshortpath_1+0xe6c>
    21b2:	23 cd       	rjmp	.-1466   	; 0x1bfa <findshortpath_1+0x8b2>
            {n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
			 n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
			 n=checkarray(pop(&t),a);  a[n/10][n%10]=0; }
            w=0;
	   }
	   g=s.top;
    21b4:	fe 01       	movw	r30, r28
    21b6:	e7 59       	subi	r30, 0x97	; 151
    21b8:	ff 4f       	sbci	r31, 0xFF	; 255
    21ba:	a0 81       	ld	r26, Z
    21bc:	b1 81       	ldd	r27, Z+1	; 0x01
    21be:	cd 01       	movw	r24, r26
    21c0:	40 e0       	ldi	r20, 0x00	; 0
    21c2:	50 e0       	ldi	r21, 0x00	; 0
    21c4:	2f ef       	ldi	r18, 0xFF	; 255
    21c6:	3f ef       	ldi	r19, 0xFF	; 255
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
 	     return 0;
     n=p->a[p->top];
    21c8:	6e 01       	movw	r12, r28
    21ca:	08 94       	sec
    21cc:	c1 1c       	adc	r12, r1
    21ce:	d1 1c       	adc	r13, r1
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
	     return;
     p->top++;
     p->a[p->top]=n;
    21d0:	8e 01       	movw	r16, r28
    21d2:	07 55       	subi	r16, 0x57	; 87
    21d4:	1f 4f       	sbci	r17, 0xFF	; 255
    21d6:	1d c0       	rjmp	.+58     	; 0x2212 <findshortpath_1+0xeca>
}
int pop(stack *p)
{
 	 int n;
 	 if(p->top==-1)
    21d8:	ef ef       	ldi	r30, 0xFF	; 255
    21da:	8f 3f       	cpi	r24, 0xFF	; 255
    21dc:	9e 07       	cpc	r25, r30
    21de:	19 f4       	brne	.+6      	; 0x21e6 <findshortpath_1+0xe9e>
    21e0:	60 e0       	ldi	r22, 0x00	; 0
    21e2:	70 e0       	ldi	r23, 0x00	; 0
    21e4:	08 c0       	rjmp	.+16     	; 0x21f6 <findshortpath_1+0xeae>
 	     return 0;
     n=p->a[p->top];
    21e6:	fc 01       	movw	r30, r24
    21e8:	ee 0f       	add	r30, r30
    21ea:	ff 1f       	adc	r31, r31
    21ec:	ec 0d       	add	r30, r12
    21ee:	fd 1d       	adc	r31, r13
    21f0:	64 a5       	ldd	r22, Z+44	; 0x2c
    21f2:	75 a5       	ldd	r23, Z+45	; 0x2d
     p->top--;
    21f4:	01 97       	sbiw	r24, 0x01	; 1
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    21f6:	2d 31       	cpi	r18, 0x1D	; 29
    21f8:	31 05       	cpc	r19, r1
    21fa:	49 f0       	breq	.+18     	; 0x220e <findshortpath_1+0xec6>
	     return;
     p->top++;
    21fc:	2f 5f       	subi	r18, 0xFF	; 255
    21fe:	3f 4f       	sbci	r19, 0xFF	; 255
     p->a[p->top]=n;
    2200:	f9 01       	movw	r30, r18
    2202:	ee 0f       	add	r30, r30
    2204:	ff 1f       	adc	r31, r31
    2206:	e0 0f       	add	r30, r16
    2208:	f1 1f       	adc	r31, r17
    220a:	71 83       	std	Z+1, r23	; 0x01
    220c:	60 83       	st	Z, r22
			 n=checkarray(pop(&t),a);  a[n/10][n%10]=0;
			 n=checkarray(pop(&t),a);  a[n/10][n%10]=0; }
            w=0;
	   }
	   g=s.top;
	   for(i=0;i<=g;i++)
    220e:	4f 5f       	subi	r20, 0xFF	; 255
    2210:	5f 4f       	sbci	r21, 0xFF	; 255
    2212:	a4 17       	cp	r26, r20
    2214:	b5 07       	cpc	r27, r21
    2216:	04 f7       	brge	.-64     	; 0x21d8 <findshortpath_1+0xe90>
    2218:	fe 01       	movw	r30, r28
    221a:	e7 59       	subi	r30, 0x97	; 151
    221c:	ff 4f       	sbci	r31, 0xFF	; 255
    221e:	91 83       	std	Z+1, r25	; 0x01
    2220:	80 83       	st	Z, r24
       {v=pop(&s);    push(&path,v);}
//	   peep(s);
       travel(path,a);
    2222:	fe 01       	movw	r30, r28
    2224:	e7 55       	subi	r30, 0x57	; 87
    2226:	ff 4f       	sbci	r31, 0xFF	; 255
    2228:	35 af       	std	Z+61, r19	; 0x3d
    222a:	24 af       	std	Z+60, r18	; 0x3c
    222c:	2d b7       	in	r18, 0x3d	; 61
    222e:	3e b7       	in	r19, 0x3e	; 62
    2230:	20 54       	subi	r18, 0x40	; 64
    2232:	30 40       	sbci	r19, 0x00	; 0
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	f8 94       	cli
    2238:	3e bf       	out	0x3e, r19	; 62
    223a:	0f be       	out	0x3f, r0	; 63
    223c:	2d bf       	out	0x3d, r18	; 61
    223e:	2f 5f       	subi	r18, 0xFF	; 255
    2240:	3f 4f       	sbci	r19, 0xFF	; 255
    2242:	d9 01       	movw	r26, r18
    2244:	8e e3       	ldi	r24, 0x3E	; 62
    2246:	01 90       	ld	r0, Z+
    2248:	0d 92       	st	X+, r0
    224a:	81 50       	subi	r24, 0x01	; 1
    224c:	e1 f7       	brne	.-8      	; 0x2246 <findshortpath_1+0xefe>
    224e:	d9 01       	movw	r26, r18
    2250:	df 96       	adiw	r26, 0x3f	; 63
    2252:	fc 92       	st	X, r15
    2254:	ee 92       	st	-X, r14
    2256:	de 97       	sbiw	r26, 0x3e	; 62
    2258:	0e 94 b7 07 	call	0xf6e	; 0xf6e <travel>
}
    225c:	ed b7       	in	r30, 0x3d	; 61
    225e:	fe b7       	in	r31, 0x3e	; 62
    2260:	e0 5c       	subi	r30, 0xC0	; 192
    2262:	ff 4f       	sbci	r31, 0xFF	; 255
    2264:	0f b6       	in	r0, 0x3f	; 63
    2266:	f8 94       	cli
    2268:	fe bf       	out	0x3e, r31	; 62
    226a:	0f be       	out	0x3f, r0	; 63
    226c:	ed bf       	out	0x3d, r30	; 61
    226e:	c4 56       	subi	r28, 0x64	; 100
    2270:	de 4f       	sbci	r29, 0xFE	; 254
    2272:	0f b6       	in	r0, 0x3f	; 63
    2274:	f8 94       	cli
    2276:	de bf       	out	0x3e, r29	; 62
    2278:	0f be       	out	0x3f, r0	; 63
    227a:	cd bf       	out	0x3d, r28	; 61
    227c:	cf 91       	pop	r28
    227e:	df 91       	pop	r29
    2280:	1f 91       	pop	r17
    2282:	0f 91       	pop	r16
    2284:	ff 90       	pop	r15
    2286:	ef 90       	pop	r14
    2288:	df 90       	pop	r13
    228a:	cf 90       	pop	r12
    228c:	bf 90       	pop	r11
    228e:	af 90       	pop	r10
    2290:	9f 90       	pop	r9
    2292:	8f 90       	pop	r8
    2294:	7f 90       	pop	r7
    2296:	6f 90       	pop	r6
    2298:	5f 90       	pop	r5
    229a:	4f 90       	pop	r4
    229c:	3f 90       	pop	r3
    229e:	2f 90       	pop	r2
    22a0:	08 95       	ret
	  }
   }
}
void push(stack *p,int n)
{
 	 if(p->top==MAX-1)
    22a2:	d4 01       	movw	r26, r8
    22a4:	ed 91       	ld	r30, X+
    22a6:	fc 91       	ld	r31, X
    22a8:	ed 31       	cpi	r30, 0x1D	; 29
    22aa:	f1 05       	cpc	r31, r1
    22ac:	09 f0       	breq	.+2      	; 0x22b0 <findshortpath_1+0xf68>
    22ae:	c4 c8       	rjmp	.-3704   	; 0x1438 <findshortpath_1+0xf0>
    22b0:	cd c8       	rjmp	.-3686   	; 0x144c <findshortpath_1+0x104>

000022b2 <main>:
//	   peep(s);
       travel(path,a);
}

int main()
{
    22b2:	ff 92       	push	r15
    22b4:	0f 93       	push	r16
    22b6:	1f 93       	push	r17
   DDRI=0x00;
    22b8:	1a ba       	out	0x1a, r1	; 26
   DDRM=0xFF;
    22ba:	8f ef       	ldi	r24, 0xFF	; 255
    22bc:	84 bb       	out	0x14, r24	; 20
   DDRH=0xFF;
    22be:	81 bb       	out	0x11, r24	; 17
   DDRB=0xFF;
    22c0:	87 bb       	out	0x17, r24	; 23
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    22c2:	e1 99       	sbic	0x1c, 1	; 28
    22c4:	fe cf       	rjmp	.-4      	; 0x22c2 <main+0x10>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    22c6:	1f ba       	out	0x1f, r1	; 31
    22c8:	1e ba       	out	0x1e, r1	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    22ca:	e0 9a       	sbi	0x1c, 0	; 28
    22cc:	8d b3       	in	r24, 0x1d	; 29
   int anti=1;
  uint8_t a = eeprom_read_byte(0);
  uint8_t b,c;
 	
 if(a==0)
    22ce:	88 23       	and	r24, r24
    22d0:	09 f0       	breq	.+2      	; 0x22d4 <main+0x22>
    22d2:	77 c0       	rjmp	.+238    	; 0x23c2 <main+0x110>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
    22d4:	81 e0       	ldi	r24, 0x01	; 1
    22d6:	88 bb       	out	0x18, r24	; 24
    22d8:	80 e1       	ldi	r24, 0x10	; 16
    22da:	97 e2       	ldi	r25, 0x27	; 39
    22dc:	01 97       	sbiw	r24, 0x01	; 1
    22de:	f1 f7       	brne	.-4      	; 0x22dc <main+0x2a>
	  _delay_ms(10);
   	  PORTB=0x00;
    22e0:	18 ba       	out	0x18, r1	; 24
    22e2:	80 e5       	ldi	r24, 0x50	; 80
    22e4:	93 ec       	ldi	r25, 0xC3	; 195
    22e6:	01 97       	sbiw	r24, 0x01	; 1
    22e8:	f1 f7       	brne	.-4      	; 0x22e6 <main+0x34>
	 {
	    gridfollow();
		_delay_ms(100);
		node();
	//	buzzer();
		PORTM=STOP;
    22ea:	04 e6       	ldi	r16, 0x64	; 100
    22ec:	10 e0       	ldi	r17, 0x00	; 0
    22ee:	3f e0       	ldi	r19, 0x0F	; 15
    22f0:	f3 2e       	mov	r15, r19
    22f2:	30 c0       	rjmp	.+96     	; 0x2354 <main+0xa2>
 if(a==0)
{
    buzzer();
	 while((X!=0) || (Y!=3))
	 {
	    gridfollow();
    22f4:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
    22f8:	88 ee       	ldi	r24, 0xE8	; 232
    22fa:	93 e0       	ldi	r25, 0x03	; 3
    22fc:	f8 01       	movw	r30, r16
    22fe:	31 97       	sbiw	r30, 0x01	; 1
    2300:	f1 f7       	brne	.-4      	; 0x22fe <main+0x4c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2302:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2304:	d9 f7       	brne	.-10     	; 0x22fc <main+0x4a>
		_delay_ms(100);
		node();
    2306:	0e 94 02 02 	call	0x404	; 0x404 <node>
	//	buzzer();
		PORTM=STOP;
    230a:	f5 ba       	out	0x15, r15	; 21
		if(X==3)     //&&(x!=3))
    230c:	80 91 e0 00 	lds	r24, 0x00E0
    2310:	90 91 e1 00 	lds	r25, 0x00E1
    2314:	03 97       	sbiw	r24, 0x03	; 3
    2316:	11 f4       	brne	.+4      	; 0x231c <main+0x6a>
		{
		  turnright();
    2318:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
		}
		if((X==0)&&(Y==1))
    231c:	80 91 e0 00 	lds	r24, 0x00E0
    2320:	90 91 e1 00 	lds	r25, 0x00E1
    2324:	89 2b       	or	r24, r25
    2326:	41 f4       	brne	.+16     	; 0x2338 <main+0x86>
    2328:	80 91 ec 00 	lds	r24, 0x00EC
    232c:	90 91 ed 00 	lds	r25, 0x00ED
    2330:	01 97       	sbiw	r24, 0x01	; 1
    2332:	11 f4       	brne	.+4      	; 0x2338 <main+0x86>
		{
		  turnleft();
    2334:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
		}
		if((X==0)&&(Y==2))
    2338:	80 91 e0 00 	lds	r24, 0x00E0
    233c:	90 91 e1 00 	lds	r25, 0x00E1
    2340:	89 2b       	or	r24, r25
    2342:	41 f4       	brne	.+16     	; 0x2354 <main+0xa2>
    2344:	80 91 ec 00 	lds	r24, 0x00EC
    2348:	90 91 ed 00 	lds	r25, 0x00ED
    234c:	02 97       	sbiw	r24, 0x02	; 2
    234e:	11 f4       	brne	.+4      	; 0x2354 <main+0xa2>
		{
		  turnleft();
    2350:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
  uint8_t b,c;
 	
 if(a==0)
{
    buzzer();
	 while((X!=0) || (Y!=3))
    2354:	80 91 e0 00 	lds	r24, 0x00E0
    2358:	90 91 e1 00 	lds	r25, 0x00E1
    235c:	89 2b       	or	r24, r25
    235e:	51 f6       	brne	.-108    	; 0x22f4 <main+0x42>
    2360:	80 91 ec 00 	lds	r24, 0x00EC
    2364:	90 91 ed 00 	lds	r25, 0x00ED
    2368:	03 97       	sbiw	r24, 0x03	; 3
    236a:	09 f0       	breq	.+2      	; 0x236e <main+0xbc>
    236c:	c3 cf       	rjmp	.-122    	; 0x22f4 <main+0x42>
		if((X==0)&&(Y==2))
		{
		  turnleft();
		}
      }
	  PORTB=0x01;
    236e:	81 e0       	ldi	r24, 0x01	; 1
    2370:	88 bb       	out	0x18, r24	; 24
    2372:	80 e2       	ldi	r24, 0x20	; 32
    2374:	93 e0       	ldi	r25, 0x03	; 3
    2376:	24 e6       	ldi	r18, 0x64	; 100
    2378:	30 e0       	ldi	r19, 0x00	; 0
    237a:	f9 01       	movw	r30, r18
    237c:	31 97       	sbiw	r30, 0x01	; 1
    237e:	f1 f7       	brne	.-4      	; 0x237c <main+0xca>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2380:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2382:	d9 f7       	brne	.-10     	; 0x237a <main+0xc8>
	  _delay_ms(80);
   	  PORTB=0x00;
    2384:	18 ba       	out	0x18, r1	; 24
    2386:	80 e5       	ldi	r24, 0x50	; 80
    2388:	93 ec       	ldi	r25, 0xC3	; 195
    238a:	01 97       	sbiw	r24, 0x01	; 1
    238c:	f1 f7       	brne	.-4      	; 0x238a <main+0xd8>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    238e:	e1 99       	sbic	0x1c, 1	; 28
    2390:	fe cf       	rjmp	.-4      	; 0x238e <main+0xdc>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2392:	1f ba       	out	0x1f, r1	; 31
    2394:	1e ba       	out	0x1e, r1	; 30
#endif
    EEDR = __value;
    2396:	85 e0       	ldi	r24, 0x05	; 5
    2398:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    239a:	0f b6       	in	r0, 0x3f	; 63
    239c:	f8 94       	cli
    239e:	e2 9a       	sbi	0x1c, 2	; 28
    23a0:	e1 9a       	sbi	0x1c, 1	; 28
    23a2:	0f be       	out	0x3f, r0	; 63
	  _delay_ms(50);
        eeprom_write_byte(0,5);
		eeprom_write_byte((uint8_t*)1,j);
    23a4:	20 91 ea 00 	lds	r18, 0x00EA
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    23a8:	e1 99       	sbic	0x1c, 1	; 28
    23aa:	fe cf       	rjmp	.-4      	; 0x23a8 <main+0xf6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    23ac:	81 e0       	ldi	r24, 0x01	; 1
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	9f bb       	out	0x1f, r25	; 31
    23b2:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    23b4:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    23b6:	0f b6       	in	r0, 0x3f	; 63
    23b8:	f8 94       	cli
    23ba:	e2 9a       	sbi	0x1c, 2	; 28
    23bc:	e1 9a       	sbi	0x1c, 1	; 28
    23be:	0f be       	out	0x3f, r0	; 63
    23c0:	7e c2       	rjmp	.+1276   	; 0x28be <main+0x60c>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
    23c2:	41 e0       	ldi	r20, 0x01	; 1
    23c4:	48 bb       	out	0x18, r20	; 24
    23c6:	20 e1       	ldi	r18, 0x10	; 16
    23c8:	37 e2       	ldi	r19, 0x27	; 39
    23ca:	c9 01       	movw	r24, r18
    23cc:	01 97       	sbiw	r24, 0x01	; 1
    23ce:	f1 f7       	brne	.-4      	; 0x23cc <main+0x11a>
	  _delay_ms(10);
   	  PORTB=0x00;
    23d0:	18 ba       	out	0x18, r1	; 24
    23d2:	80 e5       	ldi	r24, 0x50	; 80
    23d4:	93 ec       	ldi	r25, 0xC3	; 195
    23d6:	fc 01       	movw	r30, r24
    23d8:	31 97       	sbiw	r30, 0x01	; 1
    23da:	f1 f7       	brne	.-4      	; 0x23d8 <main+0x126>
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
    23dc:	48 bb       	out	0x18, r20	; 24
    23de:	f9 01       	movw	r30, r18
    23e0:	31 97       	sbiw	r30, 0x01	; 1
    23e2:	f1 f7       	brne	.-4      	; 0x23e0 <main+0x12e>
	  _delay_ms(10);
   	  PORTB=0x00;
    23e4:	18 ba       	out	0x18, r1	; 24
    23e6:	01 97       	sbiw	r24, 0x01	; 1
    23e8:	f1 f7       	brne	.-4      	; 0x23e6 <main+0x134>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    23ea:	e1 99       	sbic	0x1c, 1	; 28
    23ec:	fe cf       	rjmp	.-4      	; 0x23ea <main+0x138>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    23ee:	81 e0       	ldi	r24, 0x01	; 1
    23f0:	90 e0       	ldi	r25, 0x00	; 0
    23f2:	9f bb       	out	0x1f, r25	; 31
    23f4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    23f6:	e0 9a       	sbi	0x1c, 0	; 28
    23f8:	1d b3       	in	r17, 0x1d	; 29
else
  {   
      buzzer();
	  buzzer();
	  c=eeprom_read_byte((uint8_t *)1);
	  gridfollow();
    23fa:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
    23fe:	42 e0       	ldi	r20, 0x02	; 2
    2400:	50 e0       	ldi	r21, 0x00	; 0
      for(anti=2;anti<c;anti++)
    2402:	01 2f       	mov	r16, r17
    2404:	10 e0       	ldi	r17, 0x00	; 0
    2406:	2c c0       	rjmp	.+88     	; 0x2460 <main+0x1ae>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2408:	e1 99       	sbic	0x1c, 1	; 28
    240a:	fe cf       	rjmp	.-4      	; 0x2408 <main+0x156>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    240c:	5f bb       	out	0x1f, r21	; 31
    240e:	4e bb       	out	0x1e, r20	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2410:	e0 9a       	sbi	0x1c, 0	; 28
    2412:	2d b3       	in	r18, 0x1d	; 29
      {
	    b=eeprom_read_byte((uint8_t *)anti);
		arr[b/10][b%10]=0;
    2414:	82 2f       	mov	r24, r18
    2416:	6a e0       	ldi	r22, 0x0A	; 10
    2418:	0e 94 65 14 	call	0x28ca	; 0x28ca <__udivmodqi4>
    241c:	e8 2f       	mov	r30, r24
    241e:	f0 e0       	ldi	r31, 0x00	; 0
    2420:	82 2f       	mov	r24, r18
    2422:	0e 94 65 14 	call	0x28ca	; 0x28ca <__udivmodqi4>
    2426:	ee 0f       	add	r30, r30
    2428:	ff 1f       	adc	r31, r31
    242a:	ee 0f       	add	r30, r30
    242c:	ff 1f       	adc	r31, r31
    242e:	e9 0f       	add	r30, r25
    2430:	f1 1d       	adc	r31, r1
    2432:	ee 0f       	add	r30, r30
    2434:	ff 1f       	adc	r31, r31
    2436:	df 01       	movw	r26, r30
    2438:	a0 5a       	subi	r26, 0xA0	; 160
    243a:	bf 4f       	sbci	r27, 0xFF	; 255
    243c:	1d 92       	st	X+, r1
    243e:	1c 92       	st	X, r1
		brr[b/10][b%10]=0;
    2440:	df 01       	movw	r26, r30
    2442:	a0 58       	subi	r26, 0x80	; 128
    2444:	bf 4f       	sbci	r27, 0xFF	; 255
    2446:	1d 92       	st	X+, r1
    2448:	1c 92       	st	X, r1
		crr[b/10][b%10]=0;
    244a:	df 01       	movw	r26, r30
    244c:	a0 56       	subi	r26, 0x60	; 96
    244e:	bf 4f       	sbci	r27, 0xFF	; 255
    2450:	1d 92       	st	X+, r1
    2452:	1c 92       	st	X, r1
		drr[b/10][b%10]=0;
    2454:	e0 54       	subi	r30, 0x40	; 64
    2456:	ff 4f       	sbci	r31, 0xFF	; 255
    2458:	11 82       	std	Z+1, r1	; 0x01
    245a:	10 82       	st	Z, r1
  {   
      buzzer();
	  buzzer();
	  c=eeprom_read_byte((uint8_t *)1);
	  gridfollow();
      for(anti=2;anti<c;anti++)
    245c:	4f 5f       	subi	r20, 0xFF	; 255
    245e:	5f 4f       	sbci	r21, 0xFF	; 255
    2460:	40 17       	cp	r20, r16
    2462:	51 07       	cpc	r21, r17
    2464:	8c f2       	brlt	.-94     	; 0x2408 <main+0x156>
		arr[b/10][b%10]=0;
		brr[b/10][b%10]=0;
		crr[b/10][b%10]=0;
		drr[b/10][b%10]=0;
	  }
	  findshortpath_1(arr);
    2466:	80 e6       	ldi	r24, 0x60	; 96
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	0e 94 a4 09 	call	0x1348	; 0x1348 <findshortpath_1>
	  if(arr[3][0]!=0)
    246e:	80 91 78 00 	lds	r24, 0x0078
    2472:	90 91 79 00 	lds	r25, 0x0079
    2476:	20 91 e2 00 	lds	r18, 0x00E2
    247a:	30 91 e3 00 	lds	r19, 0x00E3
    247e:	40 91 e4 00 	lds	r20, 0x00E4
    2482:	50 91 e5 00 	lds	r21, 0x00E5
    2486:	89 2b       	or	r24, r25
    2488:	49 f1       	breq	.+82     	; 0x24dc <main+0x22a>
	  {
	   x=xx;y=yy;xx=3;yy=0;
    248a:	30 93 f1 00 	sts	0x00F1, r19
    248e:	20 93 f0 00 	sts	0x00F0, r18
    2492:	50 93 f3 00 	sts	0x00F3, r21
    2496:	40 93 f2 00 	sts	0x00F2, r20
    249a:	03 e0       	ldi	r16, 0x03	; 3
    249c:	10 e0       	ldi	r17, 0x00	; 0
    249e:	10 93 e3 00 	sts	0x00E3, r17
    24a2:	00 93 e2 00 	sts	0x00E2, r16
    24a6:	10 92 e5 00 	sts	0x00E5, r1
    24aa:	10 92 e4 00 	sts	0x00E4, r1
	   findshortpath_1(brr);
    24ae:	80 e8       	ldi	r24, 0x80	; 128
    24b0:	90 e0       	ldi	r25, 0x00	; 0
    24b2:	0e 94 a4 09 	call	0x1348	; 0x1348 <findshortpath_1>
	   x=3;y=0;xx=0;yy=3;
    24b6:	10 93 f1 00 	sts	0x00F1, r17
    24ba:	00 93 f0 00 	sts	0x00F0, r16
    24be:	10 92 f3 00 	sts	0x00F3, r1
    24c2:	10 92 f2 00 	sts	0x00F2, r1
    24c6:	10 92 e3 00 	sts	0x00E3, r1
    24ca:	10 92 e2 00 	sts	0x00E2, r1
    24ce:	10 93 e5 00 	sts	0x00E5, r17
    24d2:	00 93 e4 00 	sts	0x00E4, r16
	   findshortpath_1(crr);
    24d6:	80 ea       	ldi	r24, 0xA0	; 160
    24d8:	90 e0       	ldi	r25, 0x00	; 0
    24da:	1a c0       	rjmp	.+52     	; 0x2510 <main+0x25e>
      }
	  else
	  {
	    x=xx;y=yy;xx=xxx;yy=yyy;
    24dc:	30 93 f1 00 	sts	0x00F1, r19
    24e0:	20 93 f0 00 	sts	0x00F0, r18
    24e4:	50 93 f3 00 	sts	0x00F3, r21
    24e8:	40 93 f2 00 	sts	0x00F2, r20
    24ec:	80 91 f4 00 	lds	r24, 0x00F4
    24f0:	90 91 f5 00 	lds	r25, 0x00F5
    24f4:	90 93 e3 00 	sts	0x00E3, r25
    24f8:	80 93 e2 00 	sts	0x00E2, r24
    24fc:	80 91 e6 00 	lds	r24, 0x00E6
    2500:	90 91 e7 00 	lds	r25, 0x00E7
    2504:	90 93 e5 00 	sts	0x00E5, r25
    2508:	80 93 e4 00 	sts	0x00E4, r24
		findshortpath_1(brr);
    250c:	80 e8       	ldi	r24, 0x80	; 128
    250e:	90 e0       	ldi	r25, 0x00	; 0
    2510:	0e 94 a4 09 	call	0x1348	; 0x1348 <findshortpath_1>
      }
   if(dir==2)
    2514:	80 91 e8 00 	lds	r24, 0x00E8
    2518:	90 91 e9 00 	lds	r25, 0x00E9
    251c:	02 97       	sbiw	r24, 0x02	; 2
    251e:	c9 f4       	brne	.+50     	; 0x2552 <main+0x2a0>
     {
      turnright();
    2520:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
      PORTM=FORWARD;
    2524:	89 e0       	ldi	r24, 0x09	; 9
    2526:	85 bb       	out	0x15, r24	; 21
    2528:	88 ee       	ldi	r24, 0xE8	; 232
    252a:	93 e0       	ldi	r25, 0x03	; 3
    252c:	24 e6       	ldi	r18, 0x64	; 100
    252e:	30 e0       	ldi	r19, 0x00	; 0
    2530:	f9 01       	movw	r30, r18
    2532:	31 97       	sbiw	r30, 0x01	; 1
    2534:	f1 f7       	brne	.-4      	; 0x2532 <main+0x280>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2536:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2538:	d9 f7       	brne	.-10     	; 0x2530 <main+0x27e>
	  _delay_ms(100);
	  PORTM=STOP;
    253a:	8f e0       	ldi	r24, 0x0F	; 15
    253c:	85 bb       	out	0x15, r24	; 21
    253e:	80 ed       	ldi	r24, 0xD0	; 208
    2540:	97 e0       	ldi	r25, 0x07	; 7
    2542:	24 e6       	ldi	r18, 0x64	; 100
    2544:	30 e0       	ldi	r19, 0x00	; 0
    2546:	f9 01       	movw	r30, r18
    2548:	31 97       	sbiw	r30, 0x01	; 1
    254a:	f1 f7       	brne	.-4      	; 0x2548 <main+0x296>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    254c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    254e:	d9 f7       	brne	.-10     	; 0x2546 <main+0x294>
    2550:	16 c0       	rjmp	.+44     	; 0x257e <main+0x2cc>
      _delay_ms(200);
      place();
	 }
   else
     {
      PORTM=FORWARD;
    2552:	89 e0       	ldi	r24, 0x09	; 9
    2554:	85 bb       	out	0x15, r24	; 21
    2556:	8c ed       	ldi	r24, 0xDC	; 220
    2558:	95 e0       	ldi	r25, 0x05	; 5
    255a:	24 e6       	ldi	r18, 0x64	; 100
    255c:	30 e0       	ldi	r19, 0x00	; 0
    255e:	f9 01       	movw	r30, r18
    2560:	31 97       	sbiw	r30, 0x01	; 1
    2562:	f1 f7       	brne	.-4      	; 0x2560 <main+0x2ae>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2564:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2566:	d9 f7       	brne	.-10     	; 0x255e <main+0x2ac>
	  _delay_ms(150);
	  PORTM=STOP;
    2568:	8f e0       	ldi	r24, 0x0F	; 15
    256a:	85 bb       	out	0x15, r24	; 21
    256c:	80 ed       	ldi	r24, 0xD0	; 208
    256e:	97 e0       	ldi	r25, 0x07	; 7
    2570:	24 e6       	ldi	r18, 0x64	; 100
    2572:	30 e0       	ldi	r19, 0x00	; 0
    2574:	f9 01       	movw	r30, r18
    2576:	31 97       	sbiw	r30, 0x01	; 1
    2578:	f1 f7       	brne	.-4      	; 0x2576 <main+0x2c4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    257a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    257c:	d9 f7       	brne	.-10     	; 0x2574 <main+0x2c2>
      _delay_ms(200);
      place();
    257e:	0e 94 b7 01 	call	0x36e	; 0x36e <place>
	 }
	backturn();
    2582:	0e 94 10 01 	call	0x220	; 0x220 <backturn>
	PORTM=STOP;
    2586:	8f e0       	ldi	r24, 0x0F	; 15
    2588:	85 bb       	out	0x15, r24	; 21
    258a:	88 ee       	ldi	r24, 0xE8	; 232
    258c:	93 e0       	ldi	r25, 0x03	; 3
    258e:	24 e6       	ldi	r18, 0x64	; 100
    2590:	30 e0       	ldi	r19, 0x00	; 0
    2592:	f9 01       	movw	r30, r18
    2594:	31 97       	sbiw	r30, 0x01	; 1
    2596:	f1 f7       	brne	.-4      	; 0x2594 <main+0x2e2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2598:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    259a:	d9 f7       	brne	.-10     	; 0x2592 <main+0x2e0>
    _delay_ms(100);
	PORTM=BACKWARD;
    259c:	86 e0       	ldi	r24, 0x06	; 6
    259e:	85 bb       	out	0x15, r24	; 21
    25a0:	80 e2       	ldi	r24, 0x20	; 32
    25a2:	93 e0       	ldi	r25, 0x03	; 3
    25a4:	24 e6       	ldi	r18, 0x64	; 100
    25a6:	30 e0       	ldi	r19, 0x00	; 0
    25a8:	f9 01       	movw	r30, r18
    25aa:	31 97       	sbiw	r30, 0x01	; 1
    25ac:	f1 f7       	brne	.-4      	; 0x25aa <main+0x2f8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25ae:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25b0:	d9 f7       	brne	.-10     	; 0x25a8 <main+0x2f6>
	_delay_ms(80);
	gridfollow();
    25b2:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	turnleft();
    25b6:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
	gridfollow();
    25ba:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	turnleft();
    25be:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
	PORTM=FORWARD;
    25c2:	89 e0       	ldi	r24, 0x09	; 9
    25c4:	85 bb       	out	0x15, r24	; 21
    25c6:	8c ed       	ldi	r24, 0xDC	; 220
    25c8:	95 e0       	ldi	r25, 0x05	; 5
    25ca:	24 e6       	ldi	r18, 0x64	; 100
    25cc:	30 e0       	ldi	r19, 0x00	; 0
    25ce:	f9 01       	movw	r30, r18
    25d0:	31 97       	sbiw	r30, 0x01	; 1
    25d2:	f1 f7       	brne	.-4      	; 0x25d0 <main+0x31e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25d4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25d6:	d9 f7       	brne	.-10     	; 0x25ce <main+0x31c>
    25d8:	02 c0       	rjmp	.+4      	; 0x25de <main+0x32c>
	_delay_ms(150);
	while((PINI & 0x35)!=0b00110001)
	{
	 PORTM=STOP;
    25da:	95 bb       	out	0x15, r25	; 21
    25dc:	01 c0       	rjmp	.+2      	; 0x25e0 <main+0x32e>
    25de:	9f e0       	ldi	r25, 0x0F	; 15
	turnleft();
	gridfollow();
	turnleft();
	PORTM=FORWARD;
	_delay_ms(150);
	while((PINI & 0x35)!=0b00110001)
    25e0:	89 b3       	in	r24, 0x19	; 25
    25e2:	85 73       	andi	r24, 0x35	; 53
    25e4:	81 33       	cpi	r24, 0x31	; 49
    25e6:	c9 f7       	brne	.-14     	; 0x25da <main+0x328>
	{
	 PORTM=STOP;
    }
	if((PINI & 0x35)==0b00110001)
    25e8:	89 b3       	in	r24, 0x19	; 25
    25ea:	85 73       	andi	r24, 0x35	; 53
    25ec:	81 33       	cpi	r24, 0x31	; 49
    25ee:	69 f4       	brne	.+26     	; 0x260a <main+0x358>
	{
	  PORTH=STOP;
    25f0:	8f e0       	ldi	r24, 0x0F	; 15
    25f2:	82 bb       	out	0x12, r24	; 18
    25f4:	80 ed       	ldi	r24, 0xD0	; 208
    25f6:	97 e0       	ldi	r25, 0x07	; 7
    25f8:	24 e6       	ldi	r18, 0x64	; 100
    25fa:	30 e0       	ldi	r19, 0x00	; 0
    25fc:	f9 01       	movw	r30, r18
    25fe:	31 97       	sbiw	r30, 0x01	; 1
    2600:	f1 f7       	brne	.-4      	; 0x25fe <main+0x34c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2602:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2604:	d9 f7       	brne	.-10     	; 0x25fc <main+0x34a>
	  _delay_ms(200);
	  pickup();
    2606:	0e 94 4d 01 	call	0x29a	; 0x29a <pickup>
     }
	backturn();
    260a:	0e 94 10 01 	call	0x220	; 0x220 <backturn>
	PORTM=STOP;
    260e:	8f e0       	ldi	r24, 0x0F	; 15
    2610:	85 bb       	out	0x15, r24	; 21
    2612:	88 ee       	ldi	r24, 0xE8	; 232
    2614:	93 e0       	ldi	r25, 0x03	; 3
    2616:	24 e6       	ldi	r18, 0x64	; 100
    2618:	30 e0       	ldi	r19, 0x00	; 0
    261a:	f9 01       	movw	r30, r18
    261c:	31 97       	sbiw	r30, 0x01	; 1
    261e:	f1 f7       	brne	.-4      	; 0x261c <main+0x36a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2620:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2622:	d9 f7       	brne	.-10     	; 0x261a <main+0x368>
    _delay_ms(100);
	PORTM=BACKWARD;
    2624:	86 e0       	ldi	r24, 0x06	; 6
    2626:	85 bb       	out	0x15, r24	; 21
    2628:	80 e2       	ldi	r24, 0x20	; 32
    262a:	93 e0       	ldi	r25, 0x03	; 3
    262c:	24 e6       	ldi	r18, 0x64	; 100
    262e:	30 e0       	ldi	r19, 0x00	; 0
    2630:	f9 01       	movw	r30, r18
    2632:	31 97       	sbiw	r30, 0x01	; 1
    2634:	f1 f7       	brne	.-4      	; 0x2632 <main+0x380>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2636:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2638:	d9 f7       	brne	.-10     	; 0x2630 <main+0x37e>
	_delay_ms(80);
	gridfollow();
    263a:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	turnright();
    263e:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
	gridfollow();
    2642:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
    turnleft();
    2646:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
	gridfollow();
    264a:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	turnright();
    264e:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
	PORTM=FORWARD;
    2652:	89 e0       	ldi	r24, 0x09	; 9
    2654:	85 bb       	out	0x15, r24	; 21
    2656:	8c ed       	ldi	r24, 0xDC	; 220
    2658:	95 e0       	ldi	r25, 0x05	; 5
    265a:	24 e6       	ldi	r18, 0x64	; 100
    265c:	30 e0       	ldi	r19, 0x00	; 0
    265e:	f9 01       	movw	r30, r18
    2660:	31 97       	sbiw	r30, 0x01	; 1
    2662:	f1 f7       	brne	.-4      	; 0x2660 <main+0x3ae>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2664:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2666:	d9 f7       	brne	.-10     	; 0x265e <main+0x3ac>
	_delay_ms(150);
	PORTM=STOP;
    2668:	8f e0       	ldi	r24, 0x0F	; 15
    266a:	85 bb       	out	0x15, r24	; 21
    266c:	88 ee       	ldi	r24, 0xE8	; 232
    266e:	93 e0       	ldi	r25, 0x03	; 3
    2670:	24 e6       	ldi	r18, 0x64	; 100
    2672:	30 e0       	ldi	r19, 0x00	; 0
    2674:	f9 01       	movw	r30, r18
    2676:	31 97       	sbiw	r30, 0x01	; 1
    2678:	f1 f7       	brne	.-4      	; 0x2676 <main+0x3c4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    267a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    267c:	d9 f7       	brne	.-10     	; 0x2674 <main+0x3c2>
    _delay_ms(100);
	place();
    267e:	0e 94 b7 01 	call	0x36e	; 0x36e <place>
	backturn();
    2682:	0e 94 10 01 	call	0x220	; 0x220 <backturn>
	PORTM=STOP;
    2686:	8f e0       	ldi	r24, 0x0F	; 15
    2688:	85 bb       	out	0x15, r24	; 21
    268a:	88 ee       	ldi	r24, 0xE8	; 232
    268c:	93 e0       	ldi	r25, 0x03	; 3
    268e:	24 e6       	ldi	r18, 0x64	; 100
    2690:	30 e0       	ldi	r19, 0x00	; 0
    2692:	f9 01       	movw	r30, r18
    2694:	31 97       	sbiw	r30, 0x01	; 1
    2696:	f1 f7       	brne	.-4      	; 0x2694 <main+0x3e2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2698:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    269a:	d9 f7       	brne	.-10     	; 0x2692 <main+0x3e0>
    _delay_ms(100);
	PORTM=BACKWARD;
    269c:	86 e0       	ldi	r24, 0x06	; 6
    269e:	85 bb       	out	0x15, r24	; 21
    26a0:	80 e2       	ldi	r24, 0x20	; 32
    26a2:	93 e0       	ldi	r25, 0x03	; 3
    26a4:	24 e6       	ldi	r18, 0x64	; 100
    26a6:	30 e0       	ldi	r19, 0x00	; 0
    26a8:	f9 01       	movw	r30, r18
    26aa:	31 97       	sbiw	r30, 0x01	; 1
    26ac:	f1 f7       	brne	.-4      	; 0x26aa <main+0x3f8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26ae:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26b0:	d9 f7       	brne	.-10     	; 0x26a8 <main+0x3f6>
	_delay_ms(80);
	gridfollow();
    26b2:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
  if(arr[2][3]!=0)
    26b6:	80 91 76 00 	lds	r24, 0x0076
    26ba:	90 91 77 00 	lds	r25, 0x0077
    26be:	89 2b       	or	r24, r25
    26c0:	91 f0       	breq	.+36     	; 0x26e6 <main+0x434>
	 {
	  turnright();
    26c2:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
	  gridfollow();
    26c6:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	  gridfollow();
    26ca:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
      PORTM=FORWARD;
    26ce:	89 e0       	ldi	r24, 0x09	; 9
    26d0:	85 bb       	out	0x15, r24	; 21
    26d2:	80 e2       	ldi	r24, 0x20	; 32
    26d4:	93 e0       	ldi	r25, 0x03	; 3
    26d6:	24 e6       	ldi	r18, 0x64	; 100
    26d8:	30 e0       	ldi	r19, 0x00	; 0
    26da:	f9 01       	movw	r30, r18
    26dc:	31 97       	sbiw	r30, 0x01	; 1
    26de:	f1 f7       	brne	.-4      	; 0x26dc <main+0x42a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26e0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26e2:	d9 f7       	brne	.-10     	; 0x26da <main+0x428>
    26e4:	1a c0       	rjmp	.+52     	; 0x271a <main+0x468>
	  _delay_ms(80);
     }
  else
     {
	  x=1;y=3;xx=3;yy=3;
    26e6:	81 e0       	ldi	r24, 0x01	; 1
    26e8:	90 e0       	ldi	r25, 0x00	; 0
    26ea:	90 93 f1 00 	sts	0x00F1, r25
    26ee:	80 93 f0 00 	sts	0x00F0, r24
    26f2:	83 e0       	ldi	r24, 0x03	; 3
    26f4:	90 e0       	ldi	r25, 0x00	; 0
    26f6:	90 93 f3 00 	sts	0x00F3, r25
    26fa:	80 93 f2 00 	sts	0x00F2, r24
    26fe:	90 93 e3 00 	sts	0x00E3, r25
    2702:	80 93 e2 00 	sts	0x00E2, r24
    2706:	90 93 e5 00 	sts	0x00E5, r25
    270a:	80 93 e4 00 	sts	0x00E4, r24
	  findshortpath_1(drr);
    270e:	80 ec       	ldi	r24, 0xC0	; 192
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	0e 94 a4 09 	call	0x1348	; 0x1348 <findshortpath_1>
	  turnleft();
    2716:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
     }
	 PORTH=HANDDOWN;
    271a:	84 e0       	ldi	r24, 0x04	; 4
    271c:	82 bb       	out	0x12, r24	; 18
    271e:	80 e6       	ldi	r24, 0x60	; 96
    2720:	9a ee       	ldi	r25, 0xEA	; 234
    2722:	01 97       	sbiw	r24, 0x01	; 1
    2724:	f1 f7       	brne	.-4      	; 0x2722 <main+0x470>
     _delay_ms(60);
   	 PORTH=STOP;
    2726:	8f e0       	ldi	r24, 0x0F	; 15
    2728:	82 bb       	out	0x12, r24	; 18
    272a:	8c eb       	ldi	r24, 0xBC	; 188
    272c:	92 e0       	ldi	r25, 0x02	; 2
    272e:	24 e6       	ldi	r18, 0x64	; 100
    2730:	30 e0       	ldi	r19, 0x00	; 0
    2732:	f9 01       	movw	r30, r18
    2734:	31 97       	sbiw	r30, 0x01	; 1
    2736:	f1 f7       	brne	.-4      	; 0x2734 <main+0x482>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2738:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    273a:	d9 f7       	brne	.-10     	; 0x2732 <main+0x480>
	 _delay_ms(70);
	 linefollow();
    273c:	0e 94 94 03 	call	0x728	; 0x728 <linefollow>
	 PORTM=STOP;
    2740:	8f e0       	ldi	r24, 0x0F	; 15
    2742:	85 bb       	out	0x15, r24	; 21
    2744:	80 ed       	ldi	r24, 0xD0	; 208
    2746:	97 e0       	ldi	r25, 0x07	; 7
    2748:	24 e6       	ldi	r18, 0x64	; 100
    274a:	30 e0       	ldi	r19, 0x00	; 0
    274c:	f9 01       	movw	r30, r18
    274e:	31 97       	sbiw	r30, 0x01	; 1
    2750:	f1 f7       	brne	.-4      	; 0x274e <main+0x49c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2752:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2754:	d9 f7       	brne	.-10     	; 0x274c <main+0x49a>
     _delay_ms(200);
	 pickup();
    2756:	0e 94 4d 01 	call	0x29a	; 0x29a <pickup>
	 PORTM=BACKWARD;
    275a:	86 e0       	ldi	r24, 0x06	; 6
    275c:	85 bb       	out	0x15, r24	; 21
    275e:	80 e2       	ldi	r24, 0x20	; 32
    2760:	93 e0       	ldi	r25, 0x03	; 3
    2762:	24 e6       	ldi	r18, 0x64	; 100
    2764:	30 e0       	ldi	r19, 0x00	; 0
    2766:	f9 01       	movw	r30, r18
    2768:	31 97       	sbiw	r30, 0x01	; 1
    276a:	f1 f7       	brne	.-4      	; 0x2768 <main+0x4b6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    276c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    276e:	d9 f7       	brne	.-10     	; 0x2766 <main+0x4b4>
      _delay_ms(80);
     gridfollow();
    2770:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 turnleft();
    2774:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
     gridfollow();
    2778:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 gridfollow();
    277c:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 gridfollow();
    2780:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 turnright();
    2784:	0e 94 7e 00 	call	0xfc	; 0xfc <turnright>
	 PORTM=FORWARD;
    2788:	89 e0       	ldi	r24, 0x09	; 9
    278a:	85 bb       	out	0x15, r24	; 21
    278c:	88 ee       	ldi	r24, 0xE8	; 232
    278e:	93 e0       	ldi	r25, 0x03	; 3
    2790:	24 e6       	ldi	r18, 0x64	; 100
    2792:	30 e0       	ldi	r19, 0x00	; 0
    2794:	f9 01       	movw	r30, r18
    2796:	31 97       	sbiw	r30, 0x01	; 1
    2798:	f1 f7       	brne	.-4      	; 0x2796 <main+0x4e4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    279a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    279c:	d9 f7       	brne	.-10     	; 0x2794 <main+0x4e2>
	 _delay_ms(100);
	 PORTM=STOP;
    279e:	8f e0       	ldi	r24, 0x0F	; 15
    27a0:	85 bb       	out	0x15, r24	; 21
    27a2:	80 ed       	ldi	r24, 0xD0	; 208
    27a4:	97 e0       	ldi	r25, 0x07	; 7
    27a6:	24 e6       	ldi	r18, 0x64	; 100
    27a8:	30 e0       	ldi	r19, 0x00	; 0
    27aa:	f9 01       	movw	r30, r18
    27ac:	31 97       	sbiw	r30, 0x01	; 1
    27ae:	f1 f7       	brne	.-4      	; 0x27ac <main+0x4fa>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    27b0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    27b2:	d9 f7       	brne	.-10     	; 0x27aa <main+0x4f8>
     _delay_ms(200);
     place();
    27b4:	0e 94 b7 01 	call	0x36e	; 0x36e <place>
	 backturn();
    27b8:	0e 94 10 01 	call	0x220	; 0x220 <backturn>
	 PORTM=STOP;
    27bc:	8f e0       	ldi	r24, 0x0F	; 15
    27be:	85 bb       	out	0x15, r24	; 21
    27c0:	88 ee       	ldi	r24, 0xE8	; 232
    27c2:	93 e0       	ldi	r25, 0x03	; 3
    27c4:	24 e6       	ldi	r18, 0x64	; 100
    27c6:	30 e0       	ldi	r19, 0x00	; 0
    27c8:	f9 01       	movw	r30, r18
    27ca:	31 97       	sbiw	r30, 0x01	; 1
    27cc:	f1 f7       	brne	.-4      	; 0x27ca <main+0x518>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    27ce:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    27d0:	d9 f7       	brne	.-10     	; 0x27c8 <main+0x516>
     _delay_ms(100);
	 PORTM=BACKWARD;
    27d2:	86 e0       	ldi	r24, 0x06	; 6
    27d4:	85 bb       	out	0x15, r24	; 21
    27d6:	80 e2       	ldi	r24, 0x20	; 32
    27d8:	93 e0       	ldi	r25, 0x03	; 3
    27da:	24 e6       	ldi	r18, 0x64	; 100
    27dc:	30 e0       	ldi	r19, 0x00	; 0
    27de:	f9 01       	movw	r30, r18
    27e0:	31 97       	sbiw	r30, 0x01	; 1
    27e2:	f1 f7       	brne	.-4      	; 0x27e0 <main+0x52e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    27e4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    27e6:	d9 f7       	brne	.-10     	; 0x27de <main+0x52c>
	 _delay_ms(80);
	 gridfollow();
    27e8:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 turnleft();
    27ec:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
	 gridfollow();
    27f0:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 gridfollow();
    27f4:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 turnleft();
    27f8:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
	 gridfollow();
    27fc:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 gridfollow();
    2800:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 turnleft();
    2804:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
     gridfollowfinal();
    2808:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <gridfollowfinal>
	 PORTH=HANDDOWN;
    280c:	64 e0       	ldi	r22, 0x04	; 4
    280e:	62 bb       	out	0x12, r22	; 18
    2810:	20 e4       	ldi	r18, 0x40	; 64
    2812:	3c e9       	ldi	r19, 0x9C	; 156
    2814:	c9 01       	movw	r24, r18
    2816:	01 97       	sbiw	r24, 0x01	; 1
    2818:	f1 f7       	brne	.-4      	; 0x2816 <main+0x564>
	 _delay_ms(40);
	 PORTH=STOP;
    281a:	4f e0       	ldi	r20, 0x0F	; 15
    281c:	42 bb       	out	0x12, r20	; 18
    281e:	80 e5       	ldi	r24, 0x50	; 80
    2820:	93 ec       	ldi	r25, 0xC3	; 195
    2822:	fc 01       	movw	r30, r24
    2824:	31 97       	sbiw	r30, 0x01	; 1
    2826:	f1 f7       	brne	.-4      	; 0x2824 <main+0x572>
	 _delay_ms(50);
     PORTH=HANDUP;
    2828:	58 e0       	ldi	r21, 0x08	; 8
    282a:	52 bb       	out	0x12, r21	; 18
    282c:	f9 01       	movw	r30, r18
    282e:	31 97       	sbiw	r30, 0x01	; 1
    2830:	f1 f7       	brne	.-4      	; 0x282e <main+0x57c>
	 _delay_ms(40);
	 PORTH=STOP;
    2832:	42 bb       	out	0x12, r20	; 18
    2834:	fc 01       	movw	r30, r24
    2836:	31 97       	sbiw	r30, 0x01	; 1
    2838:	f1 f7       	brne	.-4      	; 0x2836 <main+0x584>
	 _delay_ms(50);
     PORTH=HANDDOWN;
    283a:	62 bb       	out	0x12, r22	; 18
    283c:	f9 01       	movw	r30, r18
    283e:	31 97       	sbiw	r30, 0x01	; 1
    2840:	f1 f7       	brne	.-4      	; 0x283e <main+0x58c>
	 _delay_ms(40);
	 PORTH=STOP;
    2842:	42 bb       	out	0x12, r20	; 18
    2844:	fc 01       	movw	r30, r24
    2846:	31 97       	sbiw	r30, 0x01	; 1
    2848:	f1 f7       	brne	.-4      	; 0x2846 <main+0x594>
	 _delay_ms(50);
     PORTH=HANDUP;
    284a:	52 bb       	out	0x12, r21	; 18
    284c:	f9 01       	movw	r30, r18
    284e:	31 97       	sbiw	r30, 0x01	; 1
    2850:	f1 f7       	brne	.-4      	; 0x284e <main+0x59c>
	 _delay_ms(40);
	 PORTH=STOP;
    2852:	42 bb       	out	0x12, r20	; 18
    2854:	01 97       	sbiw	r24, 0x01	; 1
    2856:	f1 f7       	brne	.-4      	; 0x2854 <main+0x5a2>
	 _delay_ms(50);
	 backturn();
    2858:	0e 94 10 01 	call	0x220	; 0x220 <backturn>
	 gridfollow();
    285c:	0e 94 7e 02 	call	0x4fc	; 0x4fc <gridfollow>
	 turnleft();
    2860:	0e 94 49 00 	call	0x92	; 0x92 <turnleft>
     PORTM=FORWARD;
    2864:	89 e0       	ldi	r24, 0x09	; 9
    2866:	85 bb       	out	0x15, r24	; 21
    2868:	88 ee       	ldi	r24, 0xE8	; 232
    286a:	93 e0       	ldi	r25, 0x03	; 3
    286c:	24 e6       	ldi	r18, 0x64	; 100
    286e:	30 e0       	ldi	r19, 0x00	; 0
    2870:	f9 01       	movw	r30, r18
    2872:	31 97       	sbiw	r30, 0x01	; 1
    2874:	f1 f7       	brne	.-4      	; 0x2872 <main+0x5c0>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2876:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2878:	d9 f7       	brne	.-10     	; 0x2870 <main+0x5be>
	 _delay_ms(100);
	 PORTM=STOP;
    287a:	8f e0       	ldi	r24, 0x0F	; 15
    287c:	85 bb       	out	0x15, r24	; 21
	  dir=dir-1;
	}
}
void buzzer()
{
      PORTB=0x01;
    287e:	81 e0       	ldi	r24, 0x01	; 1
    2880:	88 bb       	out	0x18, r24	; 24
    2882:	80 e1       	ldi	r24, 0x10	; 16
    2884:	97 e2       	ldi	r25, 0x27	; 39
    2886:	01 97       	sbiw	r24, 0x01	; 1
    2888:	f1 f7       	brne	.-4      	; 0x2886 <main+0x5d4>
	  _delay_ms(10);
   	  PORTB=0x00;
    288a:	18 ba       	out	0x18, r1	; 24
    288c:	80 e5       	ldi	r24, 0x50	; 80
    288e:	93 ec       	ldi	r25, 0xC3	; 195
    2890:	01 97       	sbiw	r24, 0x01	; 1
    2892:	f1 f7       	brne	.-4      	; 0x2890 <main+0x5de>
    2894:	80 e0       	ldi	r24, 0x00	; 0
    2896:	90 e0       	ldi	r25, 0x00	; 0
    2898:	0b c0       	rjmp	.+22     	; 0x28b0 <main+0x5fe>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    289a:	e1 99       	sbic	0x1c, 1	; 28
    289c:	fe cf       	rjmp	.-4      	; 0x289a <main+0x5e8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    289e:	9f bb       	out	0x1f, r25	; 31
    28a0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    28a2:	1d ba       	out	0x1d, r1	; 29

    __asm__ __volatile__ (
    28a4:	0f b6       	in	r0, 0x3f	; 63
    28a6:	f8 94       	cli
    28a8:	e2 9a       	sbi	0x1c, 2	; 28
    28aa:	e1 9a       	sbi	0x1c, 1	; 28
    28ac:	0f be       	out	0x3f, r0	; 63
    28ae:	01 96       	adiw	r24, 0x01	; 1
	 turnleft();
     PORTM=FORWARD;
	 _delay_ms(100);
	 PORTM=STOP;
	 buzzer();
   for(reset=0;reset<10;reset++)
    28b0:	8a 30       	cpi	r24, 0x0A	; 10
    28b2:	91 05       	cpc	r25, r1
    28b4:	94 f3       	brlt	.-28     	; 0x289a <main+0x5e8>
    28b6:	90 93 f9 00 	sts	0x00F9, r25
    28ba:	80 93 f8 00 	sts	0x00F8, r24
	     eeprom_write_byte((uint8_t *)reset,0);
	  }
  }
 return 0;
 
}
    28be:	80 e0       	ldi	r24, 0x00	; 0
    28c0:	90 e0       	ldi	r25, 0x00	; 0
    28c2:	1f 91       	pop	r17
    28c4:	0f 91       	pop	r16
    28c6:	ff 90       	pop	r15
    28c8:	08 95       	ret

000028ca <__udivmodqi4>:
    28ca:	99 1b       	sub	r25, r25
    28cc:	79 e0       	ldi	r23, 0x09	; 9
    28ce:	04 c0       	rjmp	.+8      	; 0x28d8 <__udivmodqi4_ep>

000028d0 <__udivmodqi4_loop>:
    28d0:	99 1f       	adc	r25, r25
    28d2:	96 17       	cp	r25, r22
    28d4:	08 f0       	brcs	.+2      	; 0x28d8 <__udivmodqi4_ep>
    28d6:	96 1b       	sub	r25, r22

000028d8 <__udivmodqi4_ep>:
    28d8:	88 1f       	adc	r24, r24
    28da:	7a 95       	dec	r23
    28dc:	c9 f7       	brne	.-14     	; 0x28d0 <__udivmodqi4_loop>
    28de:	80 95       	com	r24
    28e0:	08 95       	ret

000028e2 <__divmodhi4>:
    28e2:	97 fb       	bst	r25, 7
    28e4:	09 2e       	mov	r0, r25
    28e6:	07 26       	eor	r0, r23
    28e8:	0a d0       	rcall	.+20     	; 0x28fe <__divmodhi4_neg1>
    28ea:	77 fd       	sbrc	r23, 7
    28ec:	04 d0       	rcall	.+8      	; 0x28f6 <__divmodhi4_neg2>
    28ee:	0c d0       	rcall	.+24     	; 0x2908 <__udivmodhi4>
    28f0:	06 d0       	rcall	.+12     	; 0x28fe <__divmodhi4_neg1>
    28f2:	00 20       	and	r0, r0
    28f4:	1a f4       	brpl	.+6      	; 0x28fc <__divmodhi4_exit>

000028f6 <__divmodhi4_neg2>:
    28f6:	70 95       	com	r23
    28f8:	61 95       	neg	r22
    28fa:	7f 4f       	sbci	r23, 0xFF	; 255

000028fc <__divmodhi4_exit>:
    28fc:	08 95       	ret

000028fe <__divmodhi4_neg1>:
    28fe:	f6 f7       	brtc	.-4      	; 0x28fc <__divmodhi4_exit>
    2900:	90 95       	com	r25
    2902:	81 95       	neg	r24
    2904:	9f 4f       	sbci	r25, 0xFF	; 255
    2906:	08 95       	ret

00002908 <__udivmodhi4>:
    2908:	aa 1b       	sub	r26, r26
    290a:	bb 1b       	sub	r27, r27
    290c:	51 e1       	ldi	r21, 0x11	; 17
    290e:	07 c0       	rjmp	.+14     	; 0x291e <__udivmodhi4_ep>

00002910 <__udivmodhi4_loop>:
    2910:	aa 1f       	adc	r26, r26
    2912:	bb 1f       	adc	r27, r27
    2914:	a6 17       	cp	r26, r22
    2916:	b7 07       	cpc	r27, r23
    2918:	10 f0       	brcs	.+4      	; 0x291e <__udivmodhi4_ep>
    291a:	a6 1b       	sub	r26, r22
    291c:	b7 0b       	sbc	r27, r23

0000291e <__udivmodhi4_ep>:
    291e:	88 1f       	adc	r24, r24
    2920:	99 1f       	adc	r25, r25
    2922:	5a 95       	dec	r21
    2924:	a9 f7       	brne	.-22     	; 0x2910 <__udivmodhi4_loop>
    2926:	80 95       	com	r24
    2928:	90 95       	com	r25
    292a:	bc 01       	movw	r22, r24
    292c:	cd 01       	movw	r24, r26
    292e:	08 95       	ret

00002930 <_exit>:
    2930:	f8 94       	cli

00002932 <__stop_program>:
    2932:	ff cf       	rjmp	.-2      	; 0x2932 <__stop_program>
